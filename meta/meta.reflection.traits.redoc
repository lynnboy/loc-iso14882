[section#ratio.reflection.traits
    [:en] Reflection type traits
    [:zh_CN] 反射的类型特征
]

[para]
[:en] This subclause specifies [`consteval] functions to query the properties of
types ([#meta.unary]), query the relationships between types ([#meta.rel]), or
transform types ([#meta.trans]), during program translation.
[:zh_CN] 本子条款规定 [`consteval] 函数可在程序翻译期间查询类型的性质（[#meta.unary]），
查询类型之间的关系（[#meta.rel]），或者进行类型变换（[#meta.trans]）。

[:en] Each [`consteval] function declared in this class
has an associated class template declared elsewhere in this document.
[:zh_CN] 这个类中声明的每个 [`consteval] 函数，都有一个在本文档的别处声明的关联类模板。

[para]
[:en] Every function and function template declared in this subclause throws an
exception of type [`meta::exception] unless the following conditions are met:
[:zh_CN] 除非满足下列条件，否则本子条款中声明的每个函数或函数模板都会抛出一个
[`meta::exception] 类型的异常。

[list]
[item]
[:en] For every parameter [`p] of type [`info], [`is_type(p)] is [`true].
[:zh_CN] 对于每个 [`info] 类型的形参 [`p]，[`is_type(p)] 均为 [`true]。

[item]
[:en] For every parameter [`r] whose type is constrained on [`:c reflection_range],
[`ranges::all_of(r, is_type)] is [`true].
[:zh_CN] 对于类型受到 [`:c reflection_range] 约束的每个形参 [`r]，
[`ranges::all_of(r, is_type)] 均为 [`true]。
[list:end]

[codeblock:synopsis]
// [:en] associated with [#meta.unary.cat], primary type categories \
[:zh_CN] 与 [#meta.unary.cat] 相关，基本类型分类
consteval bool [[redoc("`:lib>")]]is_void_type(info type);
consteval bool [[redoc("`:lib>")]]is_null_pointer_type(info type);
consteval bool [[redoc("`:lib>")]]is_integral_type(info type);
consteval bool [[redoc("`:lib>")]]is_floating_point_type(info type);
consteval bool [[redoc("`:lib>")]]is_array_type(info type);
consteval bool [[redoc("`:lib>")]]is_pointer_type(info type);
consteval bool [[redoc("`:lib>")]]is_lvalue_reference_type(info type);
consteval bool [[redoc("`:lib>")]]is_rvalue_reference_type(info type);
consteval bool [[redoc("`:lib>")]]is_member_object_pointer_type(info type);
consteval bool [[redoc("`:lib>")]]is_member_function_pointer_type(info type);
consteval bool [[redoc("`:lib>")]]is_enum_type(info type);
consteval bool [[redoc("`:lib>")]]is_union_type(info type);
consteval bool [[redoc("`:lib>")]]is_class_type(info type);
consteval bool [[redoc("`:lib>")]]is_function_type(info type);
consteval bool [[redoc("`:lib>")]]is_reflection_type(info type);

// [:en] associated with [#meta.unary.comp], composite type categories \
[:zh_CN] 与 [#meta.unary.comp] 相关，组合类型分类
consteval bool [[redoc("`:lib>")]]is_reference_type(info type);
consteval bool [[redoc("`:lib>")]]is_arithmetic_type(info type);
consteval bool [[redoc("`:lib>")]]is_fundamental_type(info type);
consteval bool [[redoc("`:lib>")]]is_object_type(info type);
consteval bool [[redoc("`:lib>")]]is_scalar_type(info type);
consteval bool [[redoc("`:lib>")]]is_compound_type(info type);
consteval bool [[redoc("`:lib>")]]is_member_pointer_type(info type);

// [:en] associated with [#meta.unary.prop], type properties \
[:zh_CN] 与 [#meta.unary.prop] 相关，类型属性
consteval bool [[redoc("`:lib>")]]is_const_type(info type);
consteval bool [[redoc("`:lib>")]]is_volatile_type(info type);
consteval bool [[redoc("`:lib>")]]is_trivially_copyable_type(info type);
consteval bool [[redoc("`:lib>")]]is_trivially_relocatable_type(info type);
consteval bool [[redoc("`:lib>")]]is_replaceable_type(info type);
consteval bool [[redoc("`:lib>")]]is_standard_layout_type(info type);
consteval bool [[redoc("`:lib>")]]is_empty_type(info type);
consteval bool [[redoc("`:lib>")]]is_polymorphic_type(info type);
consteval bool [[redoc("`:lib>")]]is_abstract_type(info type);
consteval bool [[redoc("`:lib>")]]is_final_type(info type);
consteval bool [[redoc("`:lib>")]]is_aggregate_type(info type);
consteval bool [[redoc("`:lib>")]]is_consteval_only_type(info type);
consteval bool [[redoc("`:lib>")]]is_signed_type(info type);
consteval bool [[redoc("`:lib>")]]is_unsigned_type(info type);
consteval bool [[redoc("`:lib>")]]is_bounded_array_type(info type);
consteval bool [[redoc("`:lib>")]]is_unbounded_array_type(info type);
consteval bool [[redoc("`:lib>")]]is_scoped_enum_type(info type);

template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
  consteval bool [[redoc("`:lib>")]]is_constructible_type(info type, R&& type_args);
consteval bool [[redoc("`:lib>")]]is_default_constructible_type(info type);
consteval bool [[redoc("`:lib>")]]is_copy_constructible_type(info type);
consteval bool [[redoc("`:lib>")]]is_move_constructible_type(info type);

consteval bool [[redoc("`:lib>")]]is_assignable_type(info type_dst, info type_src);
consteval bool [[redoc("`:lib>")]]is_copy_assignable_type(info type);
consteval bool [[redoc("`:lib>")]]is_move_assignable_type(info type);

consteval bool [[redoc("`:lib>")]]is_swappable_with_type(info type1, info type2);
consteval bool [[redoc("`:lib>")]]is_swappable_type(info type);

consteval bool [[redoc("`:lib>")]]is_destructible_type(info type);

template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
  consteval bool [[redoc("`:lib>")]]is_trivially_constructible_type(info type, R&& type_args);
consteval bool [[redoc("`:lib>")]]is_trivially_default_constructible_type(info type);
consteval bool [[redoc("`:lib>")]]is_trivially_copy_constructible_type(info type);
consteval bool [[redoc("`:lib>")]]is_trivially_move_constructible_type(info type);

consteval bool [[redoc("`:lib>")]]is_trivially_assignable_type(info type_dst, info type_src);
consteval bool [[redoc("`:lib>")]]is_trivially_copy_assignable_type(info type);
consteval bool [[redoc("`:lib>")]]is_trivially_move_assignable_type(info type);
consteval bool [[redoc("`:lib>")]]is_trivially_destructible_type(info type);

template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
  consteval bool [[redoc("`:lib>")]]is_nothrow_constructible_type(info type, R&& type_args);
consteval bool [[redoc("`:lib>")]]is_nothrow_default_constructible_type(info type);
consteval bool [[redoc("`:lib>")]]is_nothrow_copy_constructible_type(info type);
consteval bool [[redoc("`:lib>")]]is_nothrow_move_constructible_type(info type);

consteval bool [[redoc("`:lib>")]]is_nothrow_assignable_type(info type_dst, info type_src);
consteval bool [[redoc("`:lib>")]]is_nothrow_copy_assignable_type(info type);
consteval bool [[redoc("`:lib>")]]is_nothrow_move_assignable_type(info type);

consteval bool [[redoc("`:lib>")]]is_nothrow_swappable_with_type(info type1, info type2);
consteval bool [[redoc("`:lib>")]]is_nothrow_swappable_type(info type);

consteval bool [[redoc("`:lib>")]]is_nothrow_destructible_type(info type);
consteval bool [[redoc("`:lib>")]]is_nothrow_relocatable_type(info type);

consteval bool [[redoc("`:lib>")]]is_implicit_lifetime_type(info type);

consteval bool [[redoc("`:lib>")]]has_virtual_destructor(info type);

consteval bool [[redoc("`:lib>")]]has_unique_object_representations(info type);

consteval bool [[redoc("`:lib>")]]reference_constructs_from_temporary(info type_dst, info type_src);
consteval bool [[redoc("`:lib>")]]reference_converts_from_temporary(info type_dst, info type_src);

// [:en] associated with [#meta.rel], type relations \
[:zh_CN] 与 [#meta.rel] 相关，类型关系
consteval bool [[redoc("`:lib>")]]is_same_type(info type1, info type2);
consteval bool [[redoc("`:lib>")]]is_base_of_type(info type_base, info type_derived);
consteval bool [[redoc("`:lib>")]]is_virtual_base_of_type(info type_base, info type_derived);
consteval bool [[redoc("`:lib>")]]is_convertible_type(info type_src, info type_dst);
consteval bool [[redoc("`:lib>")]]is_nothrow_convertible_type(info type_src, info type_dst);
consteval bool [[redoc("`:lib>")]]is_layout_compatible_type(info type1, info type2);
consteval bool [[redoc("`:lib>")]]is_pointer_interconvertible_base_of_type(info type_base, info type_derived);

template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
  consteval bool [[redoc("`:lib>")]]is_invocable_type(info type, R&& type_args);
template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
  consteval bool [[redoc("`:lib>")]]is_invocable_r_type(info type_result, info type, R&& type_args);

template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
  consteval bool [[redoc("`:lib>")]]is_nothrow_invocable_type(info type, R&& type_args);
template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
  consteval bool [[redoc("`:lib>")]]is_nothrow_invocable_r_type(info type_result, info type, R&& type_args);

// [:en] associated with [#meta.trans.cv], const-volatile modifications \
[:zh_CN] 与 [#meta.trans.cv] 相关，const-volatile 改造
consteval info [[redoc("`:lib>")]]remove_const(info type);
consteval info [[redoc("`:lib>")]]remove_volatile(info type);
consteval info [[redoc("`:lib>")]]remove_cv(info type);
consteval info [[redoc("`:lib>")]]add_const(info type);
consteval info [[redoc("`:lib>")]]add_volatile(info type);
consteval info [[redoc("`:lib>")]]add_cv(info type);

// [:en] associated with [#meta.trans.ref], reference modifications \
[:zh_CN] 与 [#meta.trans.ref] 相关，引用改造
consteval info [[redoc("`:lib>")]]remove_reference(info type);
consteval info [[redoc("`:lib>")]]add_lvalue_reference(info type);
consteval info [[redoc("`:lib>")]]add_rvalue_reference(info type);

// [:en] associated with [#meta.trans.sign], sign modifications \
[:zh_CN] 与 [#meta.trans.sign] 相关，符号改造
consteval info [[redoc("`:lib>")]]make_signed(info type);
consteval info [[redoc("`:lib>")]]make_unsigned(info type);

// [:en] associated with [#meta.trans.arr], array modifications \
[:zh_CN] 与 [#meta.trans.arr] 相关，数组改造
consteval info [[redoc("`:lib>")]]remove_extent(info type);
consteval info [[redoc("`:lib>")]]remove_all_extents(info type);

// [:en] associated with [#meta.trans.ptr], pointer modifications \
[:zh_CN] 与 [#meta.trans.ptr] 相关，指针改造
consteval info [[redoc("`:lib>")]]remove_pointer(info type);
consteval info [[redoc("`:lib>")]]add_pointer(info type);

// [:en] associated with [#meta.trans.other], other modifications \
[:zh_CN] 与 [#meta.trans.other] 相关，其他改造
consteval info [[redoc("`:lib>")]]remove_cvref(info type);
consteval info [[redoc("`:lib>")]]decay(info type);
template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
  consteval info [[redoc("`:lib>")]]common_type(R&& type_args);
template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
  consteval info [[redoc("`:lib>")]]common_reference(R&& type_args);
consteval info [[redoc("`:lib>")]]underlying_type(info type);
template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
  consteval info [[redoc("`:lib>")]]invoke_result(info type, R&& type_args);
consteval info [[redoc("`:lib>")]]unwrap_reference(info type);
consteval info [[redoc("`:lib>")]]unwrap_ref_decay(info type);
[codeblock:end]

[para]
[:en] Each function or function template declared above has the following behavior
based on the signature and return type of that function or function template.
[:zh_CN] 以上声明的每个函数或函数模板，基于该函数或函数模板的签名和返回类型，具有下列行为。

[begin:note]
[:en] The associated class template need not be instantiated.
[:zh_CN] 不需要实例化关联的类模板。
[end:note]

[table:grid#meta.reflection.traits
    [:en] Reflection type traits
    [:zh_CN] 反射的类型特征
    [| [:en] Signature and Return Type [:zh_CN] 签名和返回类型 ]
    [| [=returns] ]
]
[|] [`bool meta::[^UNARY](info type);]
[|] [:en] [`std::[^UNARY]_v<[$T]>], where [$T] is the type or type alias represented by [`type]
    [:zh_CN] [`std::[^UNARY]_v<[$T]>]，其中 [$T] 为 [`type] 所表示的类型或类型别名
[-]

[|] [`bool meta::[^BINARY](info t1, info t2);] [br] [`bool meta::[^BINARY]_type(info t1, info t2);]
[|] [:en] [`std::[^BINARY]_v<[$T_1], [$T_2]>], where [$T_1] and [$T_2] are the
    types or type aliases represented by [`t1] and [`t2], respectively
    [:zh_CN] [`std::[^BINARY]_v<[$T_1], [$T_2]>]，其中 [$T_1] 和 [$T_2] 分别为
    [`t1] 和 [`t2] 所表示的类型或类型别名
[-]

[|] [`template<reflection_range R>] [br] [`bool meta::[^VARIADIC]_type(info type, R&& args);]
[|] [:en] [`std::[^VARIADIC]_v<[$T], [$U]...>], where [$T] is the type or type
    alias represented by [`type] and [`U...] is the pack of types or type aliases
    whose elements are represented by the corresponding elements of [`args]
    [:zh_CN] [`std::[^VARIADIC]_v<[$T], [$U]...>]，其中 [$T] 为 [`type] 所表示的
    类型或类型别名，而 [`U...] 为类型或类型别名的包组，其各元素由 [`args] 的对应元素所表示
[-]

[|] [`template<reflection_range R>] [br] [`bool meta::[^VARIADIC]_type(info t1, info t2, R&& args);]
[|] [:en] [`std::[^VARIADIC]_v<[$T_1], [$T_2], [$U]...>], where [$T_1] and [$T_2]
    are the types or type aliases represented by [`t1] and [`t2], respectively,
    and [`[$U]...] is the pack of types or type aliases whose elements are
    represented by the corresponding elements of [`args]
    [:zh_CN] [`std::[^VARIADIC]_v<[$T_1], [$T_2], [$U]...>]，其中 [$T_1] 和 [$T_2]
    分别为 [`t1] 和 [`t2] 所表示的类型或类型别名，而 [`[$U]...] 为类型或类型别名的包组，
    其各元素由 [`args] 的对应元素所表示
[-]

[|] [`info meta::[^UNARY](info type);]
[|] [:en] A reflection representing the type denoted by [`std::[^UNARY]_t<[$T]>],
    where [$T] is the type or type alias represented by [`type]
    [:zh_CN] 表示 [`std::[^UNARY]_t<[$T]>] 所代表的类型的反射，
    其中 [$T] 为 [`type] 所表示的类型或类型别名
[-]

[|] [`template<reflection_range R>] [br] [`info meta::[^VARIADIC](R&& args);]
[|] [:en] A reflection representing the type denoted by [`std::[^VARIADIC]_t<[$T]...>],
    where [`[$T]...] is the pack of types or type aliases whose elements are
    represented by the corresponding elements of [`args]
    [:zh_CN] 表示 [`std::[^VARIADIC]_t<[$T]...>] 所代表的类型的反射，其中
    [`[$T]...] 为类型或类型别名的包组，其各元素由 [`args] 的对应元素所表示
[-]

[|] [`template<reflection_range R>] [br] [`info meta::[^VARIADIC](info type, R&& args);]
[|] [:en] A reflection representing the type denoted by [`std::[^VARIADIC]_t<[$T], [$U]...>],
    where [$T] is the type or type alias represented by [`type] and
    [`[$U]...] is the pack of types or type aliases whose elements are
    represented by the corresponding elements of [`args]
    [:zh_CN] 表示 [`std::[^VARIADIC]_t<[$T], [$U]...>] 所代表的类型的反射，其中
    [$T] 为 [`type] 所表示的类型或类型别名，而
    [`[$U]...] 为类型或类型别名的包组，其各元素由 [`args] 的对应元素所表示
[-]
[table:end]

[para]
[begin:note]
[:en] For those functions or function templates which return a reflection,
that reflection always represents a type and never a type alias.
[:zh_CN] 对于返回反射的函数或函数模板，这个反射总是表示类型，从不报送类型别名。
[end:note]

[para]
[begin:note]
[:en] If [`t] is a reflection of the type [`int] and [`u] is a reflection of an alias
to the type [`int], then [`t == u] is [`false] but [`is_same_type(t, u)] is [`true].
[:zh_CN] 如果 [`t] 是类型 [`int] 的反射而 [`u] 是 [`int] 类型的别名的反射，那么
[`t == u] 为 [`false] 但 [`is_same_type(t, u)] 为 [`true]。

[:en] Also, [`t == dealias(u)] is [`true].
[:zh_CN] 而且，[`t == dealias(u)] 为 [`true]。
[end:note]

[%@lib rank]
[codeblock:declaration]
consteval size_t rank(info type);
[codeblock:end]

[div:description]
[para:returns]
[:en] [`rank_v<[$T]>], where [$T] is the type represented by [`dealias(type)].
[:zh_CN] [`rank_v<[$T]>]，其中 [$T] 为 [`dealias(type)] 所表示的类型。
[div:end]

[%@lib extent]
[codeblock:declaration]
consteval size_t extent(info type, unsigned i = 0);
[codeblock:end]

[div:description]
[para:returns]
[:en] [`extent_v<[$T], [$I]>], where [$T] is the type represented by [`dealias(type)]
and [$I] is a constant equal to [`i].
[:zh_CN] [`extent_v<[$T], [$I]>]，其中 [$T] 为 [`dealias(type)] 所表示的类型，
而 [$I] 为等于 [`i] 的常量。
[div:end]

[%@lib tuple_size]
[codeblock:declaration]
consteval size_t tuple_size(info type);
[codeblock:end]

[div:description]
[para:returns]
[:en] [`tuple_size_v<[$T]>], where [$T] is the type represented by [`dealias(type)].
[:zh_CN] [`tuple_size_v<[$T]>]，其中 [$T] 为 [`dealias(type)] 所表示的类型。
[div:end]

[%@lib tuple_element]
[codeblock:declaration]
consteval info tuple_element(size_t index, info type);
[codeblock:end]

[div:description]
[para:returns]
[:en] A reflection representing the type denoted by [`tuple_element_t<[$I], [$T]>],
where [$T] is the type represented by [`dealias(type)] and [$I] is a constant equal to [`index].
[:zh_CN] 表示 [`tuple_element_t<[$I], [$T]>] 所代表的类型的反射，其中 [$T] 为
[`dealias(type)] 所表示的类型，而 [$I] 为等于 [`index] 的常量。
[div:end]

[%@lib variant_size]
[codeblock:declaration]
consteval size_t variant_size(info type);
[codeblock:end]

[div:description]
[para:returns]
[:en] [`variant_size_v<[$T]>], where [$T] is the type represented by [`dealias(type)].
[:zh_CN] [`variant_size_v<[$T]>]，其中 [$T] 为 [`dealias(type)] 所表示的类型。
[div:end]

[%@lib variant_alternative]
[codeblock:declaration]
consteval info variant_alternative(size_t index, info type);
[codeblock:end]

[div:description]
[para:returns]
[:en] A reflection representing the type denoted by [`variant_alternative_t<[$I], [$T]>],
where [$T] is the type represented by [`dealias(type)] and [$I] is a constant equal to [`index].
[:zh_CN] 表示 [`variant_alternative_t<[$I], [$T]>] 所代表的类型的反射，其中 [$T] 为
[`dealias(type)] 所表示的类型，而 [$I] 为等于 [`index] 的常量。
[div:end]

[%@lib type_order]
[codeblock:declaration]
consteval strong_ordering type_order(info t1, info t2);
[codeblock:end]

[div:description]
[para:returns]
[:en] [`type_order_v<[$T_1], [$T_2]>], where [$T_1] and [$T_2] are the types
represented by [`dealias(t1)] and [`dealias(t2)], respectively.
[:zh_CN] [`type_order_v<[$T_1], [$T_2]>]，其中 [$T] 和 [$T_2] 分别为
[`dealias(t1)] 和 [`dealias(t2)] 所表示的类型。
[div:end]
