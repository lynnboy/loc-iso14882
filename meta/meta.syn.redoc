[section#ratio.syn
    [:en] Header [`<meta>] synopsis
    [:zh_CN] 头文件 [`<meta>] 纲要
]

[%@hdr@def meta]
[codeblock:synopsis]
#include <initializer_list>     // [:en] see [#initializer.list.syn] [:zh_CN] 参见 [#initializer.list.syn]

namespace std {
  // [:en] [#meta.string.literal], checking string literals \
  [:zh_CN] [#meta.string.literal]，检查字符串字面量
  consteval bool is_string_literal(const char* p);
  consteval bool is_string_literal(const wchar_t* p);
  consteval bool is_string_literal(const char8_t* p);
  consteval bool is_string_literal(const char16_t* p);
  consteval bool is_string_literal(const char32_t* p);

  // [:en] [#meta.define.static], promoting to static storage strings \
  [:zh_CN] [#meta.define.static]，提升为静态存储字符串
  template<ranges::[[redoc("`:c>")]]input_range R>
    consteval const ranges::range_value_t<R>* define_static_string(R&& r);
  template<ranges::[[redoc("`:c>")]]input_range R>
    consteval span<const ranges::range_value_t<R>> define_static_array(R&& r);
  template<class T>
    consteval const remove_cvref_t<T>* define_static_object(T&& r);
}

namespace std::meta {
  using info = decltype(^^::);

  // [:en] [#meta.reflection.exception], class [`exception] \
  [:zh_CN] [#meta.reflection.exception]，类 [`exception]
  class exception;

  // [:en] [#meta.reflection.operators], operator representations \
  [:zh_CN] [#meta.reflection.operators]，运算符的表示
  enum class operators {
    [[redoc("[=seebelow]")]];
  };
  using enum operators;
  consteval operators operator_of(info r);
  consteval string_view symbol_of(operators op);
  consteval u8string_view u8symbol_of(operators op);

  // [:en] [#meta.reflection.names], reflection names and locations \
  [:zh_CN] [#meta.reflection.names]，反射的名字与位置
  consteval bool has_identifier(info r);

  consteval string_view identifier_of(info r);
  consteval u8string_view u8identifier_of(info r);

  consteval string_view display_string_of(info r);
  consteval u8string_view u8display_string_of(info r);

  consteval source_location source_location_of(info r);

  // [:en] [#meta.reflection.queries], reflection queries \
  [:zh_CN] [#meta.reflection.queries]，反射查询
  consteval info type_of(info r);
  consteval info object_of(info r);
  consteval info constant_of(info r);

  consteval bool is_public(info r);
  consteval bool is_protected(info r);
  consteval bool is_private(info r);

  consteval bool is_virtual(info r);
  consteval bool is_pure_virtual(info r);
  consteval bool is_override(info r);
  consteval bool is_final(info r);

  consteval bool is_deleted(info r);
  consteval bool is_defaulted(info r);
  consteval bool is_user_provided(info r);
  consteval bool is_user_declared(info r);
  consteval bool is_explicit(info r);
  consteval bool is_noexcept(info r);

  consteval bool is_bit_field(info r);
  consteval bool is_enumerator(info r);
  consteval bool is_annotation(info r);

  consteval bool is_const(info r);
  consteval bool is_volatile(info r);
  consteval bool is_mutable_member(info r);
  consteval bool is_lvalue_reference_qualified(info r);
  consteval bool is_rvalue_reference_qualified(info r);

  consteval bool has_static_storage_duration(info r);
  consteval bool has_thread_storage_duration(info r);
  consteval bool has_automatic_storage_duration(info r);

  consteval bool has_internal_linkage(info r);
  consteval bool has_module_linkage(info r);
  consteval bool has_external_linkage(info r);
  consteval bool has_c_language_linkage(info r);
  consteval bool has_linkage(info r);

  consteval bool is_complete_type(info r);
  consteval bool is_enumerable_type(info r);

  consteval bool is_variable(info r);
  consteval bool is_type(info r);
  consteval bool is_namespace(info r);
  consteval bool is_type_alias(info r);
  consteval bool is_namespace_alias(info r);

  consteval bool is_function(info r);
  consteval bool is_conversion_function(info r);
  consteval bool is_operator_function(info r);
  consteval bool is_literal_operator(info r);
  consteval bool is_special_member_function(info r);
  consteval bool is_constructor(info r);
  consteval bool is_default_constructor(info r);
  consteval bool is_copy_constructor(info r);
  consteval bool is_move_constructor(info r);
  consteval bool is_assignment(info r);
  consteval bool is_copy_assignment(info r);
  consteval bool is_move_assignment(info r);
  consteval bool is_destructor(info r);

  consteval bool is_function_parameter(info r);
  consteval bool is_explicit_object_parameter(info r);
  consteval bool has_default_argument(info r);
  consteval bool has_ellipsis_parameter(info r);

  consteval bool is_template(info r);
  consteval bool is_function_template(info r);
  consteval bool is_variable_template(info r);
  consteval bool is_class_template(info r);
  consteval bool is_alias_template(info r);
  consteval bool is_conversion_function_template(info r);
  consteval bool is_operator_function_template(info r);
  consteval bool is_literal_operator_template(info r);
  consteval bool is_constructor_template(info r);
  consteval bool is_concept(info r);

  consteval bool is_value(info r);
  consteval bool is_object(info r);

  consteval bool is_structured_binding(info r);

  consteval bool is_class_member(info r);
  consteval bool is_namespace_member(info r);
  consteval bool is_nonstatic_data_member(info r);
  consteval bool is_static_member(info r);
  consteval bool is_base(info r);

  consteval bool has_default_member_initializer(info r);

  consteval bool has_parent(info r);
  consteval info parent_of(info r);

  consteval info dealias(info r);

  consteval bool has_template_arguments(info r);
  consteval info template_of(info r);
  consteval vector<info> template_arguments_of(info r);
  consteval vector<info> parameters_of(info r);
  consteval info variable_of(info r);
  consteval info return_type_of(info r);

  // [:en] [#meta.reflection.access.context], access control context \
  [:zh_CN] [#meta.reflection.access.context]，访问控制上下文
  struct access_context;

  // [:en] [#meta.reflection.access.queries], member accessibility queries \
  [:zh_CN] [#meta.reflection.access.queries]，成员可访问性查询
  consteval bool is_accessible(info r, access_context ctx);
  consteval bool has_inaccessible_nonstatic_data_members(info r, access_context ctx);
  consteval bool has_inaccessible_bases(info r, access_context ctx);
  consteval bool has_inaccessible_subobjects(info r, access_context ctx);

  // [:en] [#meta.reflection.member.queries], reflection member queries \
  [:zh_CN] [#meta.reflection.member.queries]，反射成员查询
  consteval vector<info> members_of(info r, access_context ctx);
  consteval vector<info> bases_of(info type, access_context ctx);
  consteval vector<info> static_data_members_of(info type, access_context ctx);
  consteval vector<info> nonstatic_data_members_of(info type, access_context ctx);
  consteval vector<info> subobjects_of(info type, access_context ctx);
  consteval vector<info> enumerators_of(info type_enum);

  // [:en] [#meta.reflection.layout], reflection layout queries \
  [:zh_CN] [#meta.reflection.layout]，反射布局查询
  struct member_offset;
  consteval member_offset offset_of(info r);
  consteval size_t size_of(info r);
  consteval size_t alignment_of(info r);
  consteval size_t bit_size_of(info r);

  // [:en] [#meta.reflection.extract], value extraction \
  [:zh_CN] [#meta.reflection.extract]，值的提取
  template<class T>
    consteval T extract(info);

  // [:en] [#meta.reflection.substitute], reflection substitution \
  [:zh_CN] [#meta.reflection.substitute]，反射代换
  template<class R>
    concept reflection_range = [[redoc("[=seebelow]")]];

  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval bool can_substitute(info templ, R&& arguments);
  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval info substitute(info templ, R&& arguments);

  // [:en] [#meta.reflection.result], expression result reflection \
  [:zh_CN] [#meta.reflection.result]，表达式结果的反射
  template<class T>
    consteval info reflect_constant(const T& value);
  template<class T>
    consteval info reflect_object(T& object);
  template<class T>
    consteval info reflect_function(T& fn);

  // [:en] [#meta.reflection.array], promoting to static storage arrays \
  [:zh_CN] [#meta.reflection.array]，提升为静态存储数组
  template<ranges::[[redoc("`:c>")]]input_range R>
    consteval info reflect_constant_string(R&& r);

  template<ranges::[[redoc("`:c>")]]input_range R>
    consteval info reflect_constant_array(R&& r);

  // [:en] [#meta.reflection.define.aggregate], class definition generation \
  [:zh_CN] [#meta.reflection.define.aggregate]，类定义式的生成
  struct data_member_options;
  consteval info data_member_spec(info type, data_member_options options);
  consteval bool is_data_member_spec(info r);
  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval info define_aggregate(info type_class, R&&);

  // [:en] associated with [#meta.unary.cat], primary type categories \
  [:zh_CN] 与 [#meta.unary.cat] 相关，基本类型分类
  consteval bool is_void_type(info type);
  consteval bool is_null_pointer_type(info type);
  consteval bool is_integral_type(info type);
  consteval bool is_floating_point_type(info type);
  consteval bool is_array_type(info type);
  consteval bool is_pointer_type(info type);
  consteval bool is_lvalue_reference_type(info type);
  consteval bool is_rvalue_reference_type(info type);
  consteval bool is_member_object_pointer_type(info type);
  consteval bool is_member_function_pointer_type(info type);
  consteval bool is_enum_type(info type);
  consteval bool is_union_type(info type);
  consteval bool is_class_type(info type);
  consteval bool is_function_type(info type);
  consteval bool is_reflection_type(info type);

  // [:en] associated with [#meta.unary.comp], composite type categories \
  [:zh_CN] 与 [#meta.unary.comp] 相关，组合类型分类
  consteval bool is_reference_type(info type);
  consteval bool is_arithmetic_type(info type);
  consteval bool is_fundamental_type(info type);
  consteval bool is_object_type(info type);
  consteval bool is_scalar_type(info type);
  consteval bool is_compound_type(info type);
  consteval bool is_member_pointer_type(info type);

  // [:en] associated with [#meta.unary.prop], type properties \
  [:zh_CN] 与 [#meta.unary.prop] 相关，类型属性
  consteval bool is_const_type(info type);
  consteval bool is_volatile_type(info type);
  consteval bool is_trivially_copyable_type(info type);
  consteval bool is_trivially_relocatable_type(info type);
  consteval bool is_replaceable_type(info type);
  consteval bool is_standard_layout_type(info type);
  consteval bool is_empty_type(info type);
  consteval bool is_polymorphic_type(info type);
  consteval bool is_abstract_type(info type);
  consteval bool is_final_type(info type);
  consteval bool is_aggregate_type(info type);
  consteval bool is_consteval_only_type(info type);
  consteval bool is_signed_type(info type);
  consteval bool is_unsigned_type(info type);
  consteval bool is_bounded_array_type(info type);
  consteval bool is_unbounded_array_type(info type);
  consteval bool is_scoped_enum_type(info type);

  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval bool is_constructible_type(info type, R&& type_args);
  consteval bool is_default_constructible_type(info type);
  consteval bool is_copy_constructible_type(info type);
  consteval bool is_move_constructible_type(info type);

  consteval bool is_assignable_type(info type_dst, info type_src);
  consteval bool is_copy_assignable_type(info type);
  consteval bool is_move_assignable_type(info type);

  consteval bool is_swappable_with_type(info type1, info type2);
  consteval bool is_swappable_type(info type);

  consteval bool is_destructible_type(info type);

  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval bool is_trivially_constructible_type(info type, R&& type_args);
  consteval bool is_trivially_default_constructible_type(info type);
  consteval bool is_trivially_copy_constructible_type(info type);
  consteval bool is_trivially_move_constructible_type(info type);

  consteval bool is_trivially_assignable_type(info type_dst, info type_src);
  consteval bool is_trivially_copy_assignable_type(info type);
  consteval bool is_trivially_move_assignable_type(info type);
  consteval bool is_trivially_destructible_type(info type);

  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval bool is_nothrow_constructible_type(info type, R&& type_args);
  consteval bool is_nothrow_default_constructible_type(info type);
  consteval bool is_nothrow_copy_constructible_type(info type);
  consteval bool is_nothrow_move_constructible_type(info type);

  consteval bool is_nothrow_assignable_type(info type_dst, info type_src);
  consteval bool is_nothrow_copy_assignable_type(info type);
  consteval bool is_nothrow_move_assignable_type(info type);

  consteval bool is_nothrow_swappable_with_type(info type1, info type2);
  consteval bool is_nothrow_swappable_type(info type);

  consteval bool is_nothrow_destructible_type(info type);
  consteval bool is_nothrow_relocatable_type(info type);

  consteval bool is_implicit_lifetime_type(info type);

  consteval bool has_virtual_destructor(info type);

  consteval bool has_unique_object_representations(info type);

  consteval bool reference_constructs_from_temporary(info type_dst, info type_src);
  consteval bool reference_converts_from_temporary(info type_dst, info type_src);

  // [:en] associated with [#meta.unary.prop.query], type property queries \
  [:zh_CN] 与 [#meta.unary.prop.query] 相关，类型属性查询
  consteval size_t rank(info type);
  consteval size_t extent(info type, unsigned i = 0);

  // [:en] associated with [#meta.rel], type relations \
  [:zh_CN] 与 [#meta.rel] 相关，类型关系
  consteval bool is_same_type(info type1, info type2);
  consteval bool is_base_of_type(info type_base, info type_derived);
  consteval bool is_virtual_base_of_type(info type_base, info type_derived);
  consteval bool is_convertible_type(info type_src, info type_dst);
  consteval bool is_nothrow_convertible_type(info type_src, info type_dst);
  consteval bool is_layout_compatible_type(info type1, info type2);
  consteval bool is_pointer_interconvertible_base_of_type(info type_base, info type_derived);

  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval bool is_invocable_type(info type, R&& type_args);
  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval bool is_invocable_r_type(info type_result, info type, R&& type_args);

  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval bool is_nothrow_invocable_type(info type, R&& type_args);
  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval bool is_nothrow_invocable_r_type(info type_result, info type, R&& type_args);

  // [:en] associated with [#meta.trans.cv], const-volatile modifications \
  [:zh_CN] 与 [#meta.trans.cv] 相关，const-volatile 改造
  consteval info remove_const(info type);
  consteval info remove_volatile(info type);
  consteval info remove_cv(info type);
  consteval info add_const(info type);
  consteval info add_volatile(info type);
  consteval info add_cv(info type);

  // [:en] associated with [#meta.trans.ref], reference modifications \
  [:zh_CN] 与 [#meta.trans.ref] 相关，引用改造
  consteval info remove_reference(info type);
  consteval info add_lvalue_reference(info type);
  consteval info add_rvalue_reference(info type);

  // [:en] associated with [#meta.trans.sign], sign modifications \
  [:zh_CN] 与 [#meta.trans.sign] 相关，符号改造
  consteval info make_signed(info type);
  consteval info make_unsigned(info type);

  // [:en] associated with [#meta.trans.arr], array modifications \
  [:zh_CN] 与 [#meta.trans.arr] 相关，数组改造
  consteval info remove_extent(info type);
  consteval info remove_all_extents(info type);

  // [:en] associated with [#meta.trans.ptr], pointer modifications \
  [:zh_CN] 与 [#meta.trans.ptr] 相关，指针改造
  consteval info remove_pointer(info type);
  consteval info add_pointer(info type);

  // [:en] associated with [#meta.trans.other], other modifications \
  [:zh_CN] 与 [#meta.trans.other] 相关，其他改造
  consteval info remove_cvref(info type);
  consteval info decay(info type);
  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval info common_type(R&& type_args);
  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval info common_reference(R&& type_args);
  consteval info underlying_type(info type);
  template<[[redoc("`:c>")]]reflection_range R = initializer_list<info>>
    consteval info invoke_result(info type, R&& type_args);
  consteval info unwrap_reference(info type);
  consteval info unwrap_ref_decay(info type);

  consteval size_t tuple_size(info type);
  consteval info tuple_element(size_t index, info type);

  consteval size_t variant_size(info type);
  consteval info variant_alternative(size_t index, info type);

  consteval strong_ordering type_order(info type_a, info type_b);

  // [:en] [#meta.reflection.annotation], annotation reflection \
  [:zh_CN] [#meta.reflection.annotation]，标注的反射
  consteval vector<info> annotations_of(info item);
  consteval vector<info> annotations_of_with_type(info item, info type);
}
[codeblock:end]

[para]
[:en] Unless otherwise specified, each function, and each specialization of any
function template, specified in this header is a designated addressable function ([#namespace.std]).
[:zh_CN] 除非另有规定，否则此头文件中规定的每个函数，以及任何函数模板的每个特例，
都代表的是可取地址函数（[#namespace.std]）。

[para]
[:en] The behavior of any function specified in namespace [`std::meta] is
[?impldef behavior of any function in [`std::meta] for implementation-specific
constructs] when a reflection of a construct not otherwise specified by this
document is provided as an argument.
[:zh_CN] 命名空间 [`std::meta] 中规定的任何函数，当提供本文档并未另行规定的语言构造的反射
作为实参时，其行为是[?impldef [`std::meta] 中任何函数针对实现特有语言构造的行为]。

[begin:note]
[:en] Values of type [`std::meta::info] can represent implementation-specific
constructs ([#basic.fundamental]).
[:zh_CN] [`std::meta::info] 类型的值可以表示实现特有的语言构造（[#basic.fundamental]）。
[end:note]

[begin:note]
[:en] The behavior of many of the functions specified in namespace [`std::meta]
have semantics that can be affected by the completeness of class types
represented by reflection values.
[:zh_CN] 命名空间 [`std::meta] 中规定的许多函数的行为，可能受到反射值表示的类类型完整性的影响。

[:en] For such functions, for any reflection [`r] such that [`dealias(r)]
represents a specialization of a templated class with a reachable definition,
the specialization is implicitly instantiated ([#temp.inst]).
[:zh_CN] 对于这种函数，针对使得 [`dealias(r)] 表示某个具有科大定义式的模板类的特例的
任何反射 [`r]，该特例被隐式实例化（[#temp.inst]）。

[begin:example]
[codeblock]
template<class T>
struct X {
  T mem;
};

static_assert(size_of(^^X<int>) == sizeof(int));    // [:en] instantiates [`X<int>] [:zh_CN] 实例化 [`X<int>]
[codeblock:end]
[end:example]
[end:note]

[para]
[:en] Any function in namespace [`std::meta] whose return type is [`string_view] or
[`u8string_view] returns an object [*V] such that [`[*V].data()`[[*V].size()]] equals [`'\0'].
[:zh_CN] 命名空间 [`std::meta] 中的任何返回类型为 [`string_view] 或 [`u8string_view]
的函数，所返回对象 [*V] 都满足 [`[*V].data()`[[*V].size()]] 等于 [`'\0']。

[begin:example]
[codeblock]
struct C { };

constexpr string_view sv = identifier_of(^^C);
static_assert(sv == "C");
static_assert(sv.data()[0] == 'C');
static_assert(sv.data()[1] == '\0');
[codeblock:end]
[end:example]

[para]
[:en] For the purpose of exposition, throughout this clause [`^^[^E]] is used
to indicate a reflection representing source construct [`[^E]].
[:zh_CN] 为阐释起见，本子条款通篇中使用 [`^^[^E]] 代表一个表示源代码构造 [`[^E]] 的反射。
