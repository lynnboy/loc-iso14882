333333333[section#const.wrap.class
    [:en] Class template [`constant_wrapper]
    [:zh_CN] 类模板 [`constant_wrapper]
]

[codeblock:synopsis]
template<class T>
struct [[redoc("*>")]]cw-fixed-value {                                                         // [=expos]
  using [[redoc("*>")]]type = T;                                                               // [=expos]
  constexpr [[redoc("*>")]]cw-fixed-value([[redoc("*>")]]type v) noexcept : [[redoc("*>")]]data(v) {}
  T [[redoc("*>")]]data;                                                                       // [=expos]
};

template<class T, size_t Extent>
struct [[redoc("*>")]]cw-fixed-value<T[Extent]> {                                              // [=expos]
  using [[redoc("*>")]]type = T[Extent];                                                       // [=expos]
  constexpr [[redoc("*>")]]cw-fixed-value(T (&arr)[Extent]) noexcept;
  T [[redoc("*>")]]data[Extent];                                                               // [=expos]
};

template<class T, size_t Extent>
  [[redoc("*>")]]cw-fixed-value(T (&)[Extent]) -> [[redoc("*>")]]cw-fixed-value<T[Extent]>;                   // [=expos]

struct [[redoc("*>")]]cw-operators {                                                           // [=expos]
  // [:en] unary operators [:zh_CN] 一元运算符
  template<[[redoc("*:c>")]]constexpr-param T>
    friend constexpr auto operator+(T) noexcept -> constant_wrapper<(+T::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param T>
    friend constexpr auto operator-(T) noexcept -> constant_wrapper<(-T::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param T>
    friend constexpr auto operator~(T) noexcept -> constant_wrapper<(~T::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param T>
    friend constexpr auto operator!(T) noexcept -> constant_wrapper<(!T::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param T>
    friend constexpr auto operator&(T) noexcept -> constant_wrapper<(&T::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param T>
    friend constexpr auto operator*(T) noexcept -> constant_wrapper<(*T::value)>
      { return {}; }

  // [:en] binary operators [:zh_CN] 二元运算符
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator+(L, R) noexcept -> constant_wrapper<(L::value + R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator-(L, R) noexcept -> constant_wrapper<(L::value - R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator*(L, R) noexcept -> constant_wrapper<(L::value * R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator/(L, R) noexcept -> constant_wrapper<(L::value / R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator%(L, R) noexcept -> constant_wrapper<(L::value % R::value)>
      { return {}; }

  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator<<(L, R) noexcept -> constant_wrapper<(L::value << R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator>>(L, R) noexcept -> constant_wrapper<(L::value >> R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator&(L, R) noexcept -> constant_wrapper<(L::value & R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator|(L, R) noexcept -> constant_wrapper<(L::value | R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator^(L, R) noexcept -> constant_wrapper<(L::value ^ R::value)>
      { return {}; }

  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    requires (!is_constructible_v<bool, decltype(L::value)> ||
              !is_constructible_v<bool, decltype(R::value)>)
      friend constexpr auto operator&&(L, R) noexcept -> constant_wrapper<(L::value && R::value)>
        { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    requires (!is_constructible_v<bool, decltype(L::value)> ||
              !is_constructible_v<bool, decltype(R::value)>)
      friend constexpr auto operator||(L, R) noexcept -> constant_wrapper<(L::value || R::value)>
        { return {}; }

  // [:en] comparisons [:zh_CN] 比较
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator<=>(L, R) noexcept -> constant_wrapper<(L::value <=> R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator<(L, R) noexcept -> constant_wrapper<(L::value < R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator<=(L, R) noexcept -> constant_wrapper<(L::value <= R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator==(L, R) noexcept -> constant_wrapper<(L::value == R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator!=(L, R) noexcept -> constant_wrapper<(L::value != R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator>(L, R) noexcept -> constant_wrapper<(L::value > R::value)>
      { return {}; }
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator>=(L, R) noexcept -> constant_wrapper<(L::value >= R::value)>
      { return {}; }

  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator,(L, R) noexcept = delete;
  template<[[redoc("*:c>")]]constexpr-param L, [[redoc("*:c>")]]constexpr-param R>
    friend constexpr auto operator->*(L, R) noexcept -> constant_wrapper<L::value->*(R::value)>
      { return {}; }

  // [:en] call and index [:zh_CN] 调用与索引
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param... Args>
    constexpr auto operator()(this T, Args...) noexcept
      requires requires(Args...) { constant_wrapper<T::value(Args::value...)>(); }
        { return constant_wrapper<T::value(Args::value...)>{}; }
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param... Args>
    constexpr auto operator[](this T, Args...) noexcept
      -> constant_wrapper<(T::value[Args::value...])>
        { return {}; }

  // [:en] pseudo-mutators [:zh_CN] 伪改动函数
  template<[[redoc("*:c>")]]constexpr-param T>
    constexpr auto operator++(this T) noexcept
      requires requires(T::value_type x) { ++x; }
        { return constant_wrapper<[] { auto c = T::value; return ++c; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T>
    constexpr auto operator++(this T, int) noexcept
      requires requires(T::value_type x) { x++; }
        { return constant_wrapper<[] { auto c = T::value; return c++; }()>{}; }

  template<[[redoc("*:c>")]]constexpr-param T>
    constexpr auto operator--(this T) noexcept
      requires requires(T::value_type x) { --x; }
        { return constant_wrapper<[] { auto c = T::value; return --c; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T>
    constexpr auto operator--(this T, int) noexcept
      requires requires(T::value_type x) { x--; }
        { return constant_wrapper<[] { auto c = T::value; return c--; }()>{}; }

  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator+=(this T, R) noexcept
      requires requires(T::value_type x) { x += R::value; }
        { return constant_wrapper<[] { auto v = T::value; return v += R::value; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator-=(this T, R) noexcept
      requires requires(T::value_type x) { x -= R::value; }
        { return constant_wrapper<[] { auto v = T::value; return v -= R::value; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator*=(this T, R) noexcept
      requires requires(T::value_type x) { x *= R::value; }
        { return constant_wrapper<[] { auto v = T::value; return v *= R::value; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator/=(this T, R) noexcept
      requires requires(T::value_type x) { x /= R::value; }
        { return constant_wrapper<[] { auto v = T::value; return v /= R::value; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator%=(this T, R) noexcept
      requires requires(T::value_type x) { x %= R::value; }
        { return constant_wrapper<[] { auto v = T::value; return v %= R::value; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator&=(this T, R) noexcept
      requires requires(T::value_type x) { x &= R::value; }
        { return constant_wrapper<[] { auto v = T::value; return v &= R::value; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator|=(this T, R) noexcept
      requires requires(T::value_type x) { x |= R::value; }
        { return constant_wrapper<[] { auto v = T::value; return v |= R::value; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator^=(this T, R) noexcept
      requires requires(T::value_type x) { x ^= R::value; }
        { return constant_wrapper<[] { auto v = T::value; return v ^= R::value; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator<<=(this T, R) noexcept
      requires requires(T::value_type x) { x <<= R::value; }
        { return constant_wrapper<[] { auto v = T::value; return v <<= R::value; }()>{}; }
  template<[[redoc("*:c>")]]constexpr-param T, [[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator>>=(this T, R) noexcept
      requires requires(T::value_type x) { x >>= R::value; }
        { return constant_wrapper<[] { auto v = T::value; return v >>= R::value; }()>{}; }
};

template<[[redoc("*>")]]cw-fixed-value X, class>
struct constant_wrapper : cw-operators {
  static constexpr const auto & value = X.[[redoc("*>")]]data;
  using type = constant_wrapper;
  using value_type = typename decltype(X)::[[redoc("*>")]]type;

  template<[[redoc("*:c>")]]constexpr-param R>
    constexpr auto operator=(R) const noexcept
      requires requires(value_type x) { x = R::value; }
        { return constant_wrapper<[] { auto v = value; return v = R::value; }()>{}; }

  constexpr operator decltype(auto)() const noexcept { return value; }
};
[codeblock:end]

[para]
[:en] The class template [`constant_wrapper] aids in metaprogramming by ensuring
that the evaluation of expressions comprised entirely of [`constant_wrapper]
are core constant expressions ([#expr.const]),
regardless of the context in which they appear.
[:zh_CN] 类模板 [`constant_wrapper] 有助于元编程，它可确保完全由 [`constant_wrapper]
所构成的表达式的求值为核心常量表达式（[#expr.const]），无论它出现于哪种语境。

[:en] In particular, this enables use of [`constant_wrapper] values that are
passed as arguments to constexpr functions to be used in constant expressions.
[:zh_CN] 特别是，这允许将 [`constant_wrapper] 值作为实参传递给 constexpr 函数，
以将其用在常量表达式中的做法。

[para]
[begin:note]
[:en] The unnamed second template parameter to [`constant_wrapper] is present
to aid argument-dependent lookup ([#basic.lookup.argdep]) in finding overloads
for which [`constant_wrapper][=']s wrapped value is a suitable argument,
but for which the [`constant_wrapper] itself is not.
[:zh_CN] [`constant_wrapper] 的第二个无名模板形参是为辅助实参依赖查找（[#basic.lookup.argdep]）
而提供的，用于查找重载时 [`constant_wrapper] 所包装的值为合适实参但 [`constant_wrapper]
自身却不合适的情形。
[end:note]

[para]
[begin:example]
[codeblock]
  constexpr auto initial_phase(auto quantity_1, auto quantity_2) {
    return quantity_1 + quantity_2;
  }

  constexpr auto middle_phase(auto tbd) {
    return tbd;
  }

  void final_phase(auto gathered, auto available) {
    if constexpr (gathered == available)
      std::cout << "Profit!\n";
  }

  void impeccable_underground_planning() {
    auto gathered_quantity = middle_phase(initial_phase(std::cw<42>, std::cw<13>));
    static_assert(gathered_quantity == 55);
    auto all_available = std::cw<55>;
    final_phase(gathered_quantity, all_available);
  }

  void deeply_flawed_underground_planning() {
    constexpr auto gathered_quantity = middle_phase(initial_phase(42, 13));
    constexpr auto all_available = 55;
    final_phase(gathered_quantity, all_available);  // [:en] error: [`gathered == available] [:zh_CN] 错误：[`gathered == available]
                                                    // [:en@~] is not a constant expression [:zh_CN@~] 不是常量表达式
  }
[codeblock:end]
[end:example]

[codeblock:declaration]
constexpr [[redoc("*>")]]cw-fixed-value(T (&arr)[Extent]) noexcept;
[codeblock:end]

[div:description]
[para:effects]
[:en] Initialize elements of [*data] with corresponding elements of [`arr].
[:zh_CN] 以 [`arr] 的对应元素初始化 [*data] 的各元素。
[div:end]
