[section#concept.swappable
    [:en] Concept [`Swappable]
    [:zh_CN] 概念 [`Swappable]
]

[%@library Swappable]
[codeblock:declaration]
template<class T>
  concept Swappable = is_swappable_v<T>;
[codeblock:end]

[enter:description]
[para]
[:en] Let [`a1] and [`a2] denote distinct equal objects of type [`T], and let
[`b1] and [`b2] similarly denote distinct equal objects of type [`T].
[:zh_CN] 令 [`a1] 和 [`a2] 代表 [`T] 类型的不同但相等的对象，类似地令 [`b1] 和
[`b2] 代表 [`T] 类型的不同但相等的对象。

[:en] [`Swappable<T>] is satisfied only if after evaluating either
[`swap(a1, b1)] or [`swap(b1, a1)] in the context described below, [`a1] is
equal to [`b2] and [`b1] is equal to [`a2].
[:zh_CN] 仅当在下述语境中对 [`swap(a1, b1)] 或者 [`swap(b1, a1)] 求值之后，
[`a1] 等于 [`b2] 并且 [`b1] 等于 [`a2] 时，[`Swappable<T>] 得以满足。

[para]
[:en] The context in which [`swap(a1, b1)] or [`swap(b1, a1)] is evaluated
shall ensure that a binary non-member function named [`swap] is selected via
overload resolution ([#over.match]) on a candidate set that includes:
[:zh_CN] 对 [`swap(a1, b1)] 或 [`swap(b1, a1)] 进行求值的语境，应当保证在包含
以下各项的候选函数集合中通过重载决议（[#over.match]）选取名为 [`swap] 的二元
非成员函数：

[list]
[item]
[:en] the two [`swap] function templates defined in [`<utility>] ([#utility])
and
[:zh_CN] [`<utility>]（[#utility]）中所定义的两个 [`swap] 函数模板，以及
[item]
[:en] the lookup set produced by argument-dependent lookup
([#basic.lookup.argdep]).
[:zh_CN] 由依赖于实参的名字查找（[#basic.lookup.argdep]）所产生的查找集合。
[list:end]
[exit:description]

[%@library SwappableWith]
[codeblock:declaration]
template<class T, class U>
  concept SwappableWith =
    is_swappable_with_v<T, T> && is_swappable_with_v<U, U> &&
    CommonReference<const remove_reference_t<T>&, const remove_reference_t<U>&> &&
    is_swappable_with_v<T, U> && is_swappable_with_v<U, T>;
[codeblock:end]

[enter:description]
[para]
[:en] Let:
[:zh_CN] 令：

[list]
[item]
[:en] [`t1] and [`t2] denote distinct equal objects of type [`remove_cvref_t<T>],
[:zh_CN] [`t1] 和 [`t2] 代表 [`remove_cvref_t<T>] 类型的不同但相等的对象，
[item]
[:en] [$E_t] be an expression that denotes [`t1] such that [`decltype(([$E_t]))]
is [`T],
[:zh_CN] [$E_t] 为代表 [`t1] 的表达式，使得 [`decltype(([$E_t]))] 为 [`T]，
[item]
[:en] [`u1] and [`u2] similarly denote distinct equal objects of type
[`remove_cvref_t<U>],
[:zh_CN] 类似地，[`u1] 和 [`u2] 代表 [`remove_cvref_t<U>] 类型的不同但相等的对象，
[item]
[:en] [$E_u] be an expression that denotes [`u1] such that [`decltype(([$E_u]))]
is [`U], and
[:zh_CN] [$E_u] 为代表 [`u1] 的表达式，使得 [`decltype(([$E_u]))] 为 [`U]，以及
[item]
[:en] [`C] be
[:zh_CN] [`C] 为
[codeblock:notation]
common_reference_t<const remove_reference_t<T>&, const remove_reference_t<U>&>
[codeblock:end]
[list:end]

[:en] [`SwappableWith<T, U>] is satisfied only if after evaluating either
[`swap([$E_t], [$E_u])] or [`swap([$E_u], [$E_t])] in the context described
above, [`C(t1)] is equal to [`C(u2)] and [`C(u1)] is equal to [`C(t2)].
[:zh_CN] 仅当在上述语境中对 [`swap([$E_t], [$E_u])] 或者 [`swap([$E_u], [$E_t])]
求值之后，[`C(t1)] 等于 [`C(u2)] 并且 [`C(u1)] 等于 [`C(t2)] 时，
[`SwappableWith<T, U>] 得以满足。

[para]
[:en] The context in which [`swap([$E_t], [$E_u])] or [`swap([$E_u], [$E_t])] is
evaluated shall ensure that a binary non-member function named [`swap] is
selected via overload resolution ([#over.match]) on a candidate set that
includes:
[:zh_CN] 对 [`swap([$E_t], [$E_u])] 或 [`swap([$E_u], [$E_t])] 进行求值的语境，
应当保证在包含以下各项的候选函数集合中通过重载决议（[#over.match]）选取名为
[`swap] 的二元非成员函数：

[list]
[item]
[:en] the two [`swap] function templates defined in [`<utility>] ([#utility])
and
[:zh_CN] [`<utility>]（[#utility]）中所定义的两个 [`swap] 函数模板，以及
[item]
[:en] the lookup set produced by argument-dependent lookup
([#basic.lookup.argdep]).
[:zh_CN] 由依赖于实参的名字查找（[#basic.lookup.argdep]）所产生的查找集合。
[list:end]
[exit:description]

[para]
[enter:example]
[:en] User code can ensure that the evaluation of [`swap] calls is performed in
an appropriate context under the various conditions as follows:
[:zh_CN] 用户可以用如下方式来保证对 [`swap] 调用在不同条件下都在适当的语境中进行
求值：

[codeblock]
#include <cassert>
#include <concepts>
#include <utility>

template<class T, std::SwappableWith<T> U>
void value_swap(T&& t, U&& u) {
  using std::swap;
  swap(std::forward<T>(t), std::forward<U>(u)); // [:en] OK: uses ["swappable with] conditions
                                                // [|:zh_CN] OK：使用左值和右值的
                                                // [:en@~] for rvalues and lvalues
                                                // [|:zh_CN@~] “可互相交换”条件
}

template<std::Swappable T>
void lv_swap(T& t1, T& t2) {
  using std::swap;
  swap(t1, t2);                                 // [:en] OK: uses swappable conditions for
                                                // [|:zh_CN] OK：使用 [`T] 类型的
}                                               // [:en@~] lvalues of type [`T]
                                                // [|:zh_CN@~] “可交换”条件

namespace N {
  struct A { int m; };
  struct Proxy { A* a; };
  Proxy proxy(A& a) { return Proxy{ &a }; }

  void swap(A& x, Proxy p) {
    std::swap(x.m, p.a->m);                     // [:en] OK: uses context equivalent to swappable
                                                // [|:zh_CN] OK：使用等价于基础类型的
                                                // [:en@~] conditions for fundamental types
                                                // [|:zh_CN@~] 可交换条件的语境
  }
  void swap(Proxy p, A& x) { swap(x, p); }      // [:en] satisfy symmetry constraint
                                                // [|:zh_CN] 满足对称性约束
}

int main() {
  int i = 1, j = 2;
  lv_swap(i, j);
  assert(i == 2 && j == 1);

  N::A a1 = { 5 }, a2 = { -5 };
  value_swap(a1, proxy(a2));
  assert(a1.m == -5 && a2.m == 5);
}
[codeblock:end]
[exit:example]
