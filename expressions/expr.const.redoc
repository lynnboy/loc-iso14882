[section#expr.const
    [:en] Constant expressions
    [:zh_CN] 常量表达式

[:en] [%expression[!constant]]
[:zh_CN] [%表达式[!常量～]]
]

[para]
[:en] Certain contexts require expressions that satisfy additional requirements
as detailed in this subclause; other contexts have different semantics depending
on whether or not an expression satisfies these requirements.
[:zh_CN] 一些特定的语境中，需要符合本子条款中所详述的额外规定的表达式；其他一些语境中则
根据表达式能否满足这些规定而具有不同的语义。

[:en] Expressions that satisfy these requirements, assuming that copy elision
([#class.copy.elision]) is performed, are called [%@defn expression[!constant]]
[+constant expressions [%constant expression]].
[:zh_CN] 符合这些规定的表达式，假定其实施了复制消除（[#class.copy.elision]），被称作
[%@defn 表达式[!常量～]][+常量表达式]。

[begin:note]
[:en] Constant expressions can be evaluated during translation.
[:zh_CN] 常量表达式可以在翻译期间求值。
[end:note]

[syntax]
[rule constant-expression [:zh_CN] 常量表达式 ]
    [| conditional-expression ]
[rule:end]
[syntax:end]

[para]
[:en] The [+constituent values[%constituent value]] of an object [$o] are
[:zh_CN] 对象 [$o] 的[+成分值]有：
[list]
[item]
[:en@~] if [$o] has scalar type, the value of [$o];
[:zh_CN@~] 如果 [$o] 具有标量类型，则有 [$o] 的值；
[item]
[:en@~] otherwise, the constituent values of any direct subobjects of [$o]
other than inactive union members.
[:zh_CN@~] 否则，为 [$o] 的任何并非不活跃联合体成员的直接子对象的成分值。
[list:end]

[:en] The [+constituent references[%constituent reference]] of an object [$o] are
[:zh_CN] 对象 [$o] 的[+成分引用]有：
[list]
[item]
[:en@~] any direct members of [$o] that have reference type, and
[:zh_CN@~] [$o] 的引用类型的直接成员，以及
[item]
[:en@~] the constituent references of any direct subobjects of [$o]
other than inactive union members.
[:zh_CN@~] [$o] 的任何并非不活跃联合体成员的直接子对象的成分引用。
[list:end]

[para]
[:en] The constituent values and constituent references of a variable [`x]
are defined as follows:
[:zh_CN] 变量 [`x] 的成分值和成分引用定义如下：
[list]
[item]
[:en] If [`x] declares an object, the constituent values and references of that
object are constituent values and references of [`x].
[:zh_CN] 若 [`x] 声明的是对象，则该对象的成分值和引用就是 [`x] 的成分值和引用。
[item]
[:en] If [`x] declares a reference, that reference is a constituent reference of [`x].
[:zh_CN] 如果 [`x] 声明的是引用，则该引用是 [`x] 的成分引用。
[list:end]

[:en] For any constituent reference [`r] of a variable [`x], if [`r] is bound to
a temporary object or subobject thereof whose lifetime is extended to that of [`r],
the constituent values and references of that temporary object
are also constituent values and references of [`x], recursively.
[:zh_CN] 对于变量 [`x] 的任何成分引用 [`r]，如果 [`r] 绑定到了临时对象或其子对象
且其生存期超出 [`r] 的生存期，则该临时对象的成分值和引用也是 [`x] 的成分值和引用，递归适用。

[para]
[:en] An object [$o] is [+constexpr-referenceable] from a point [$P] if
[:zh_CN] 以下情况下，对象 [$o] 从位置 [$P] [+可 constexpr 引用]：

[list]
[item]
[:en] [$o] has static storage duration, or
[:zh_CN] [$o] 具有静态存储期，或者

[item]
[:en] [$o] has automatic storage duration, and, letting [`v] denote
[:zh_CN] [$o] 具有自动存储期，以及，令 [`v] 代表
[list]
[item]
[:en@~] the variable corresponding to [$o][=']s complete object or
[:zh_CN@~] 对应于 [$o] 的完整对象的变量或
[item]
[:en@~] the variable to whose lifetime that of [$o] is extended,
[:zh_CN] [$o] 扩展了其生存期的变量，
[list:end]
[:en@~] the smallest scope enclosing [`v] and the smallest scope enclosing [$P]
that are neither
[:zh_CN@~] 包围 [`v] 的最小作用域和包围 [$P] 的并非
[list]
[item]
[:en@~] block scopes nor
[:zh_CN@~] 块作用域或
[item]
[:en@~] function parameter scopes associated with a [~requirement-parameter-list]
[:zh_CN@~] 与某个[~要求形参列表]关联的函数形参作用域
[list:end]
[:en@~] are the same function parameter scope.
[:zh_CN@~] 的最小作用域是同一个函数形参作用域。
[list:end]

[begin:example]
[codeblock]
struct A {
  int m;
  const int& r;
};
void f() {
  static int sx;
  thread_local int tx;                  // [:en] [`tx] is never constexpr-referenceable \
                                        [:zh_CN] [`tx] 从不是可 constexpr 引用的
  int ax;
  A aa = {1, 2};
  static A sa = {3, 4};
  // [:en] The objects [`sx], [`ax], and [`aa.m], [`sa.m], and the temporaries to which [`aa.r] and [`sa.r] are bound, are constexpr-referenceable. \
  [:zh_CN] 对象 [`sx]、[`ax] 和 [`aa.m]、[`sa.m]，以及 [`aa.r] 和 [`sa.r] 所绑定的临时对象，都可 constexpr 引用
  auto lambda = [] {
    int ay;
    // [:en] The objects [`sx], [`sa.m], and [`ay] (but not [`ax] or [`aa]), and the \
    [:zh_CN] 对象 [`sx]、[`sa.m] 和 [`ay]（但并非 [`ax] 或 [`aa]），以及
    // [:en@~] temporary to which [`sa.r] is bound, are constexpr-referenceable. \
    [:zh_CN@~] [`sa.r] 所绑定的临时对象，可 constexpr 引用。
  };
}
[codeblock:end]
[end:example]

[para]
[:en] An object or reference [`x] is [+constexpr-representable] at a point [$P] if,
for each constituent value of [`x] that points to or past an object [$o],
and for each constituent reference of [`x] that refers to an object [$o],
[$o] is constexpr-referenceable from [$P].
[:zh_CN] 如果对象或引用 [`x] 的每个指向或越过某个对象 [$o] 的成分值，以及 [`x]
的每个指代某个对象 [$o] 的成分引用，[$o] 都从 [$P] 可 constexpr 引用，
则 [`x] 在 [$P] 处[+可 constexpr 表示]。


[para]
[:en] A variable [`v] is [+constant-initializable] if
[:zh_CN] 满足以下条件时，变量 [`v] [+可常量初始化]：

[list]
[item]
[:en] the full-expression of its initialization is a constant expression when
interpreted as a [~constant-expression],
[:zh_CN] 其初始化的全表达式当作为[~常量表达式]解释时是常量表达式，

[begin:note]
[:en] Within this evaluation, [`std::is_constant_evaluated()] ([#meta.const.eval])
returns [`:key true].
[:zh_CN] 在这种求值之中时，[`std::is_constant_evaluated()]（[#meta.const.eval]）
将返回 [`:key true]。
[end:note]

[:en] and
[:zh_CN] 并且

[item]
[:en] immediately after the initializing declaration of [`v], the object or
reference [`x] declared by [`v] is constexpr-representable, and
[:zh_CN] 紧接 [`v] 的初始化声明式之后，[`v] 所声明的对象或引用 [`x] 即可 constexpr 表示，并且

[item]
[:en] if [`x] has static or thread storage duration, [`x] is
constexpr-representable at the nearest point whose immediate scope is a
namespace scope that follows the initializing declaration of [`v].
[:zh_CN] 如果 [`x] 具有静态或线程存储期，则在 [`v] 的初始化声明式之后的以
命名空间作用域为直接作用域的最近位置，[`x] 可 constexpr 表示。
[list:end]

[para]
[:en] A constant-initializable variable is [+constant-initialized]
if either it has an initializer or
its default-initialization results in some initialization being performed.
[:zh_CN] 如果可常量初始化的变量要么具有初始化式要么其默认初始化造成某项初始化被实施，
那么它[+被常量初始化]。

[begin:example]
[codeblock]
void f() {
  int ax = 0;                   // [:en] [`ax] is constant-initialized [:zh_CN] [`ax] 被常量初始化
  thread_local int tx = 0;      // [:en] [`tx] is constant-initialized [:zh_CN] [`tx] 被常量初始化
  static int sx;                // [:en] [`sx] is not constant-initialized [:zh_CN] [`sx] 未被常量初始化
  static int& rss = sx;         // [:en] [`rss] is constant-initialized [:zh_CN] [`rss] 被常量初始化
  static int& rst = tx;         // [:en] [`rst] is not constant-initialized [:zh_CN] [`rst] 未被常量初始化
  static int& rsa = ax;         // [:en] [`rsa] is not constant-initialized [:zh_CN] [`rsa] 未被常量初始化
  thread_local int& rts = sx;   // [:en] [`rts] is constant-initialized [:zh_CN] [`rts] 被常量初始化
  thread_local int& rtt = tx;   // [:en] [`rtt] is not constant-initialized [:zh_CN] [`rtt] 未被常量初始化
  thread_local int& rta = ax;   // [:en] [`rta] is not constant-initialized [:zh_CN] [`rta] 未被常量初始化
  int& ras = sx;                // [:en] [`ras] is constant-initialized [:zh_CN] [`ras] 被常量初始化
  int& rat = tx;                // [:en] [`rat] is not constant-initialized [:zh_CN] [`rat] 未被常量初始化
  int& raa = ax;                // [:en] [`raa] is constant-initialized [:zh_CN] [`raa] 被常量初始化
}
[codeblock:end]
[end:example]

[para]
[:en] A variable is [+potentially-constant] if it is constexpr or it has
reference or non-volatile const-qualified integral or enumeration type.
[:zh_CN] 如果变量是 constexpr 变量，或者它具有引用或非 volatile 的 const 限定的
整型或枚举类型，则它是[+潜在常量]。

[para]
[:en] A constant-initialized potentially-constant variable [$V] is [+usable in
constant expressions] at a point [$P] if [$V][=']s initializating declaration
[$D] is reachable from [$P] and
[:zh_CN] 以常量初始化的潜在常量变量 [$V]，如果 [$V] 的初始化声明式 [$D] 从某点
[$P] 处可达，且符合以下情况，则它在 [$P] 点[+可被用在常量表达式之中]。

[list]
[item]
[:en@~] it is constexpr,
[:zh_CN@~] 它为 constexpr，
[item]
[:en@~] it is not initialized to a TU-local value, or
[:zh_CN@~] 它并非以翻译单元局部的值所初始化，或
[item]
[:en@~] [$P] is in the same translation unit as [$D].
[:zh_CN@~] [$P] 与 [$D] 处于相同翻译单元中。
[list:end]

[:en] An object or reference is [+potentially usable in constant expressions]
at point [$P] if it is
[:zh_CN] 以下情况下，对象或引用在位置 [$P] [+潜在可被用在常量表达式之中]：

[list]
[item]
[:en@~] the object or reference declared by a variable that is usable in
constant expressions at [$P], or
[:zh_CN@~] 它是在 [$P] 处可被用在常量表达式之中的变量所声明的对象或引用，或
[item]
[:en@~] a temporary object of non-volatile const-qualified literal type whose
lifetime is extended ([#class.temporary]) to that of a variable that is usable
in constant expressions at [$P],
[:zh_CN@~] 非 volatile 且 const 限定的字面量类型的临时对象，并且其生存期已扩展
（[#class.temporary]）到某个在 [$P] 处可在常量表达式中使用的变量的生存期，
[item]
[:en@~] a template parameter object ([#temp.param]),
[:zh_CN@~] 模板形参对象（[#temp.param]），
[item]
[:en@~] a string literal object ([#lex.string]),
[:zh_CN@~] 字符串字面量对象（[#lex.string]），
[item]
[:en@~] a non-mutable subobject of any of the above, or
[:zh_CN@~] 以上任一的非 mutable 子对象，或
[item]
[:en@~] a reference member of any of the above.
[:zh_CN@~] 以上任一的引用成员。
[list:end]

[:en] An object or reference is [+usable in constant expressions] at point [$P]
if it is an object or reference that is potentially usable in constant
expressions at [$P] and is constexpr-representable at [$P].
[:zh_CN] 如果对象或引用是在位置 [$P] 潜在可被用在常量表达式之中且在 [$P] 可 constexpr
表示，那么它[+可被用在常量表达式之中]。

[begin:example]
[codeblock]
struct A {
  int* const & r;
};
void f(int x) {
  constexpr A a = {&x};
  static_assert(a.r == &x);             // OK
  [&] {
    static_assert(a.r != nullptr);      // [:en] error: [`a.r] is not usable in constant expressions at this point \
                                        [:zh_CN] 错误：[`a.r] 在此处不可被用在常量表达式之中
  }();
}
[codeblock:end]
[end:example]

[para]
[:en] An expression [$E] is a [+:adj core constant[!expression]] unless the
evaluation of [$E], following the rules of the abstract machine ([#intro.execution]),
would evaluate one of the following:
[:zh_CN] 表达式 [$E] 是[+:adj 核心常量[!表达式]]，但根据抽象机器的规则（[#intro.execution]）
对 [$E] 进行求值中，不能包含下列求值：

[list]
[item]
[:en] [`:key this] ([#expr.prim.this]), except
[:zh_CN] [`:key this]（[#expr.prim.this]），但
[list]
[item]
[:en@~] in a constexpr function ([#dcl.constexpr]) that is being evaluated as
part of [$E] or
[:zh_CN@~] 作为 [$E] 的求值的一部分而求值的 constexpr 函数（[#dcl.constexpr]）
中的，或者
[item]
[:en@~] when appearing as the [~postfix-expression] of an implicit or explicit
class member access expression ([#expr.ref]);
[:zh_CN@~] 作为隐式或显式成员访问表达式（[#expr.ref]）的[~后缀表达式]不算作其中；
[list:end]

[item]
[:en] a control flow that passes through a declaration of a block variable
([#basic.scope.block]) with static ([#basic.stc.static]) or thread
([#basic.stc.thread]) storage duration, unless that variable is usable in
constant expressions;
[:zh_CN] 控制流通过具有静态（[#basic.stc.static]）或线程（[#basic.stc.thread]）
存储期的块变量（[#basic.scope.block]）的声明式，除非该变量可在常量表达式中使用；

[begin:example]
[codeblock]
constexpr char test() {
  static const int x = 5;
  static constexpr char c[] = "Hello World";
  return *(c + x);
}
static_assert(' ' == test());
[codeblock:end]
[end:example]

[item]
[:en] an invocation of a non-constexpr function;[#:fn]
[:zh_CN] 进行了非 constexpr 函数的调用[#:fn]；

[note:foot]
[:en] Overload resolution ([#over.match]) is applied as usual
[:zh_CN] 照常进行重载决议（[#over.match]）
[note:end]

[item]
[:en] an invocation of an undefined constexpr function;
[:zh_CN] 进行了未定义的 constexpr 函数的调用；

[item]
[:en] an invocation of an instantiated constexpr function that is not
constexpr-suitable;
[:zh_CN] 调用所实例化的 constexpr 函数但其并不适于 constexpr；

[item]
[:en] an invocation of a virtual function ([#class.virtual]) for an object whose
dynamic type is constexpr-unknown;
[:zh_CN] 为某个动态类型 constexpr 未知的对象调用虚函数（[#class.virtual]）；

[item]
[:en] an expression that would exceed the implementation-defined limits (see
[#implimits]);
[:zh_CN] 可能超出由实现定义的限制额度的表达式（参见 [#implimits]）；

[item]
[:en] an operation that would have undefined or erroneous behavior as specified
in [#intro] through [#[=lastcorechapter]];[#:fn]
[:zh_CN] 可能具有在本文档从 [#intro] 到 [#[=lastcorechapter]][#:fn]；

[note:foot]
[:en] This includes, for example, signed integer overflow ([#expr.pre]), certain
pointer arithmetic ([#expr.add]), division by zero ([#expr.mul]), or certain
shift operations ([#expr.shift])
[:zh_CN] 这包括，（例如）有符号整数的溢出（[#expr.pre]），某些指针算术（[#expr.add]），
被零除（[#expr.mul]），或者某些移位操作（[#expr.shift]）
[note:end]

[item]
[:en] an lvalue-to-rvalue conversion unless it is applied to
[:zh_CN] 左值向右值转换，但排除实施于下列情况的左值

[list]
[item]
[:en] a glvalue of type [=cv] [`std::nullptr_t],
[:zh_CN] [=cv] [`std::nullptr_t] 类型的泛左值，

[item]
[:en] a non-volatile glvalue that refers to an object that is usable in constant
expressions, or
[:zh_CN] 指代某个可被用在常量表达式中的对象的非 volatile 泛左值，或者

[item]
[:en] a non-volatile glvalue of literal type that refers to a non-volatile object
whose lifetime began within the evaluation of [$E];
[:zh_CN] 字面类型的非 volatile 泛左值，指代在 [$E] 的求值中开始其生存期的非
volatile 对象；
[list:end]

[item]
[:en] an lvalue-to-rvalue conversion ([#conv.lval]) that is applied to a glvalue
that refers to a non-active member of a union or a subobject thereof;
[:zh_CN] 对指代某个联合体的非活跃成员或其子对象的泛左值，所实施的左值向右值转换（[#conv.lval]）；

[item]
[:en] an lvalue-to-rvalue conversion that is applied to an object with an
indeterminate value ([#basic.indet]);
[:zh_CN] 对具有不确定值的对象（[#basic.indet]）实施左值向右值转换；

[item]
[:en] an invocation of an implicitly-defined copy/move constructor or copy/move
assignment operator for a union whose active member (if any) is mutable, unless
the lifetime of the union object began within the evaluation of [$E];
[:zh_CN] 对其活跃成员（如果有）为 mutable 成员的联合体调用隐式定义的复制/移动
构造函数或复制/移动赋值运算符，除非该联合体对象的生存期开始于 [$E] 的求值之中；

[item]
[:en] in a [~lambda-expression], a reference to [`:key this] or to a variable
with automatic storage duration defined outside that [~lambda-expression], where
the reference would be an odr-use ([#term.odr.use], [#expr.prim.lambda]);
[:zh_CN] 在 [~lambda-表达式]中，涉指了 [`:key this] 或者在该 [~lambda-表达式]
之外定义的具有动态存储期的变量，而该涉指可能是一次 ODR 式使用（[#term.odr.use]，
[#expr.prim.lambda]）；

[begin:example]
[codeblock]
void g() {
  const int n = 0;
  [=] {
    constexpr int i = n;        // [:en] OK, [`n] is not odr-used here \
                                [:zh_CN] OK，这里 [`n] 并未被 ODR 式使用
    constexpr int j = *&n;      // [:en] error: [`&n] would be an odr-use of [`n] \
                                [:zh_CN] 错误：[`&n] 可能是对 [`n] 的 ODR 式使用
  };
}
[codeblock:end]
[end:example]

[begin:note]
[:en] If the odr-use occurs in an invocation of a function call operator of a
closure type, it no longer refers to [`:key this] or to an enclosing variable
with automatic storage duration due to the transformation ([#expr.prim.lambda.capture])
of the [~id-expression] into an access of the corresponding data member.
[:zh_CN] 如果这次 ODR 式使用发生于某个闭包类型的函数调用运算符的执行中，则它不再
指代 [`:key this] 或者指代某个外围具有自动存储期的变量了，这是由于[~标识表达式]已被
变换为其对应的数据成员的访问（[#expr.prim.lambda.capture]）。

[begin:example]
[codeblock]
auto monad = [](auto v) { return [=] { return v; }; };
auto bind = [](auto m) {
  return [=](auto fvm) { return fvm(m()); };
};

// [:en] OK to capture objects with automatic storage duration created during constant expression evaluation. \
[:zh_CN] 俘获在常量表达式的求值过程中创建的具有自动存储期的对象是没问题的。
static_assert(bind(monad(2))(monad)() == monad(2)());
[codeblock:end]
[end:example]
[end:note]

[item]
[:en] a conversion from a prvalue [`P] of type [=lq]pointer to [=cv] [`:key void][=rq]
to a type [=lq][=cv cv1] pointer to [`T][=rq], where [`T] is not
[=cv cv2] [`:key void], unless [`P] is a null pointer value or points to an
object whose type is similar to [`T];
[:zh_CN] 从类型“[=cv] [`:key void] 的指针”的纯右值 [`P] 向类型
“[`T] 的 [=cv cv1] 指针”的转换，其中 [`T] 并非 [=cv cv2] [`:key void]，但排除
[`P] 为空指针值或所指向的对象的类型与 [`T] 相似的情况；

[item]
[:en] a [`:key reinterpret_cast] ([#expr.reinterpret.cast]);
[:zh_CN] [`:key reinterpret_cast]（[#expr.reinterpret.cast]）；

[item]
[:en] a modification of an object ([#expr.ass], [#expr.post.incr], [#expr.pre.incr])
unless it is applied to a non-volatile lvalue of literal type that refers to a
non-volatile object whose lifetime began within the evaluation of [$E];
[:zh_CN] 对对象的改动（[#expr.ass]，[#expr.post.incr]，[#expr.pre.incr]），除非
实施于非 volatile 的字面类型的左值，并且它指代某个生存期开始于 [$E] 的求值中的非
volatile 对象；

[item]
[:en] an invocation of a destructor ([#class.dtor]) or a function call whose
[~postfix-expression] names a pseudo-destructor ([#expr.call]), in either case
for an object whose lifetime did not begin within the evaluation of [$E];
[:zh_CN] 调用析构函数（[#class.dtor]）或者[~后缀表达式]指名伪析构函数（[#expr.call]）
的函数调用，任何情况中均针对并非在 [$E] 的求值中开始其生存期的对象；

[item]
[:en] a [~new-expression] ([#expr.new]), unless
[:zh_CN] [~new-表达式]（[#expr.new]），除非
[list]
[item]
[:en@~] the selected allocation function is a replaceable global allocation
function ([#new.delete.single], [#new.delete.array]) and the allocated storage
is deallocated within the evaluation of [$E], or
[:zh_CN@~] 所选中的分配函数为可替换的全局分配函数（[#new.delete.single]，[#new.delete.array]），
并且所分配的存储在 [$E] 的求值之内被回收，或者
[item]
[:en@~] the selected allocation function is a non-allocating form ([#new.delete.placement])
with an allocated type [`T], where
[:zh_CN@~] 所选中的分配函数是分配类型为 [`T] 的非分配形式（[#new.delete.placement]），其中
[list]
[item]
[:en@~] the placement argument to the [~new-expression] points to an object
whose type is similar to [`T] ([#conv.qual]) or, if [`T] is an array type,
to the first element of an object of a type similar to [`T], and
[:zh_CN@~] [~new-表达式]的放置实参指向某个类型与 [`T] 相似（[#conv.qual]）
的对象，或者当 [`T] 为数组类型时，指向某个类型与 [`T] 相似的对象的首个元素，并且
[item]
[:en@~] the placement argument points to storage whose duration began within the
evaluation of [$E];
[:zh_CN@~] 放置实参指向在 [$E] 的求值之中开始其持续期的存储；
[list:end]
[list:end]

[item]
[:en] a [~delete-expression] ([#expr.delete]), unless it deallocates a region of
storage allocated within the evaluation of [$E];
[:zh_CN] [~delete-表达式]（[#expr.delete]），除非其回收在 [$E] 的求值之中所分配
的存储区域；

[item]
[:en] a call to an instance of [`std::allocator<T>::allocate] ([#allocator.members]),
unless the allocated storage is deallocated within the evaluation of [$E];
[:zh_CN] 对 [`std::allocator<T>::allocate]（[#allocator.members]）的某个实例的
调用，除非所分配的存储在 [$E] 的求值之中被回收；

[item]
[:en] a call to an instance of [`std::allocator<T>::deallocate] ([#allocator.members]),
unless it deallocates a region of storage allocated within the evaluation of [$E];
[:zh_CN] 对 [`std::allocator<T>::deallocate]（[#allocator.members]）的某个实例
的调用，除非它回收 [$E] 的求值之中所分配的存储区域；

[item]
[:en] a construction of an exception object, unless the exception object and
all of its implicit copies created by invocations of
[`std::current_exception] or [`std::rethrow_exception] ([#propagation])
are destroyed within the evaluation of [$E];
[:zh_CN] 异常对象的构造，除非该异常对象和所有由 [`std::current_exception] 或
[`std::rethrow_exception]（[#propagation]）的调用中所创建的隐含副本都在 [$E] 的
求值之中销毁；

[item]
[:en] an [~await-expression] ([#expr.await]);
[:zh_CN] [~等待表达式]（[#expr.await]）；

[item]
[:en] a [~yield-expression] ([#expr.yield]);
[:zh_CN] [~产出表达式]（[#expr.yield]）；

[item]
[:en] a three-way comparison ([#expr.spaceship]), relational ([#expr.rel]),
or equality ([#expr.eq]) operator where the result is unspecified;
[:zh_CN] 未指明结果的三路比较（[#expr.spaceship]）、关系（[#expr.rel]）或相等性
（[#expr.eq]）运算符；

[item]
[:en] a [`:key dynamic_cast] ([#expr.dynamic.cast]) or [`:key typeid] ([#expr.typeid])
expression on a glvalue that refers to an object whose dynamic type is
constexpr-unknown;
[:zh_CN] 运用于代表具有 constexpr 未知的动态类型的对象的泛左值上的
[`:key dynamic_cast]（[#expr.dynamic.cast]）或 [`typeid]（[#expr.typeid]）表达式；

[item]
[:en] a [`:key dynamic_cast] ([#expr.dynamic.cast]) expression,
[`typeid] ([#expr.typeid]) expression, or [~new-expression] ([#expr.new]) that
would throw an exception where no definition of the exception type is reachable;
[:zh_CN] 可能抛出异常的 [`:key dynamic_cast]（[#expr.dynamic.cast]）表达式，
[`typeid]（[#expr.typeid]）表达式，或 [~new-表达式]（[#expr.new]），
且没有可达的异常类型的定义式；

[item]
[:en] an [~asm-declaration] ([#dcl.asm]);
[:zh_CN] [~asm-声明式]（[#dcl.asm]）；

[item]
[:en] an invocation of the [`va_arg] macro ([#cstdarg.syn]);
[:zh_CN] 对 [`va_arg] 宏的调用（[#cstdarg.syn]）；

[item]
[:en] a non-constant library call ([#defns.nonconst.libcall]); or
[:zh_CN] 非常量程序库调用（[#defns.nonconst.libcall]）；或者

[item]
[:en] a [`:key goto] statement ([#stmt.goto]).
[:zh_CN] [`:key goto] 语句（[#stmt.goto]）。

[begin:note]
[:en] A [`:key goto] statement introduced by equivalence ([#stmt.stmt]) is not
in scope.
[:zh_CN] 以等价形式引入（[#stmt.stmt]）的 [`:key goto] 语句并不在作用域中。

[:en] For example, a [`:key while] statement ([#stmt.while]) can be executed
during constant evaluation.
[:zh_CN] 例如，可以在常量求值中执行 [`:key while] 语句（[#stmt.while]）。
[end:note]
[list:end]

[para]
[:en] It is [?impldef whether an expression is a core constant expression]
whether [$E] is a core constant expression if [$E] satisfies the constraints of
a core constant expression, but evaluation of [$E] has runtime-undefined behavior.
[:zh_CN] 如果 [$E] 满足对核心常量表达式的约束，但 [$E] 的求值具有运行时未定义行为，
那么 [$E] 是否是核心常量表达式是[?impldef 表达式是否是核心常量表达式]。

[para]
[:en] It is unspecified whether [$E] is a core constant expression if [$E]
satisfies the constraints of a core constant expression, but evaluation of [$E]
would evaluate
[:zh_CN] 如果 [$E] 满足对核心常量表达式的约束，但对 [$E] 的求值可能会求值以下各项，
那么 [$E] 是否是核心常量表达式是未指明的：

[list]
[item]
[:en@~] an operation that has undefined behavior as specified in [#library]
through [#[=lastlibchapter]], or
[:zh_CN@~] 某个具有在从 [#library] 到 [#[=lastlibchapter]] 中所述的未定义行为的操作，或者
[item]
[:en@~] an invocation of the [`va_start] macro ([#cstdarg.syn]).
[:zh_CN@~] 调用了 [`va_start] 宏（[#cstdarg.syn]）。
[list:end]

[para]
[begin:example]
[codeblock]
int x;                              // [:en] not constant [:zh_CN] 不是常量
struct A {
  constexpr A(bool b) : m(b?42:x) { }
  int m;
};
constexpr int v = A(true).m;        // [:en] OK, constructor call initializes [`m] with the value [`42] \
                                    [:zh_CN] OK，构造函数的调用以 [`42] 初始化了 [`m]

constexpr int w = A(false).m;       // [:en] error: initializer for [`m] is [`x], which is non-constant \
                                    [:zh_CN] 错误：[`m] 的初始化式为 [`x]，并且不是常量

constexpr int f1(int k) {
  constexpr int x = k;              // [:en] error: [`x] is not initialized by a constant expression \
                                    [:zh_CN] 错误：[`x] 不是以常量表达式进行的初始化，
                                    // [:en@~] because lifetime of [`k] began outside the initializer of [`x] \
                                    [:zh_CN@~] 因为 [`k] 的生存期开始于 [`x] 的初始化式之外
  return x;
}
constexpr int f2(int k) {
  int x = k;                        // [:en] OK, not required to be a constant expression \
                                    [:zh_CN] OK，不需要其为常量表达式
                                    // [:en@~] because [`x] is not [`:key constexpr] \
                                    [:zh_CN@~] 因为 [`x] 不是 [`:key constexpr]
  return x;
}

constexpr int incr(int &n) {
  return ++n;
}
constexpr int g(int k) {
  constexpr int x = incr(k);        // [:en] error: [`incr(k)] is not a core constant expression \
                                    [:zh_CN] 错误：[`incr(k)] 不是核心常量表达式，
                                    // [:en@~] because lifetime of [`k] began outside the expression [`incr(k)] \
                                    [:zh_CN@~] 因为 [`k] 的生存期开始于表达式 [`incr(k)] 之外
  return x;
}
constexpr int h(int k) {
  int x = incr(k);                  // [:en] OK, [`incr(k)] is not required to be a core constant expression \
                                    [:zh_CN] OK，[`incr(k)] 不需要是核心常量表达式
  return x;
}
constexpr int y = h(1);             // [:en] OK, initializes [`y] with the value [`2] \
                                    [:zh_CN] OK，以值 [`2] 初始化 [`y]
                                    // [:en@~] [`h(1)] is a core constant expression because \
                                    [:zh_CN@~] [`h(1)] 是核心常量表达式，因为
                                    // [:en@~] the lifetime of [`k] begins inside [`h(1)] \
                                    [:zh_CN@~] [`k] 的生存期开始于 [`h(1)] 之内
[codeblock:end]
[end:example]

[para]
[:en] For the purposes of determining whether an expression [$E] is a core
constant expression, the evaluation of the body of a member function of
[`std::allocator<T>] as defined in [#allocator.members], where [`T] is a literal
type, is ignored.
[:zh_CN] 在确定某个表达式 [$E] 是否是核心常量表达式时，忽略对 [#allocator.members]
中所定义的 [`std::allocator<T>]（其中 [`T] 为字面类型）的成员函数的函数体的求值。

[para]
[:en] For the purposes of determining whether [$E] is a core constant expression,
the evaluation of a call to a trivial copy/move constructor or copy/move
assignment operator of a union is considered to copy/move the active member of
the union, if any.
[:zh_CN] 在确定 [$E] 是否是核心常量表达式时，对联合体调用平凡的复制/移动构造函数或
复制/移动赋值运算符的求值被当做对该联合体的活跃成员进行复制/移动（如果有）。

[begin:note]
[:en] The copy/move of the active member is trivial.
[:zh_CN] 活跃成员的复制/移动是平凡操作。
[end:note]

[para]
[:en] For the purposes of determining whether [$E] is a core constant expression,
the evaluation of an [~id-expression] that names a structured binding
[`v] ([#dcl.struct.bind]) has the following semantics:
[:zh_CN] 为确定 [$E] 是否是核心常量表达式，对指明结构化绑定 [`v] 的[~标识表达式]
（[#dcl.struct.bind]）的求值具有如下语义：

[list]
[item]
[:en] If [`v] is an lvalue referring to the object bound to an invented
reference [`r], the behavior is as if [`r] were nominated.
[:zh_CN] 如果 [`v] 是指代绑定到虚构引用 [`r] 的对象的左值，则其行为如同指名的是 [`r]。
[item]
[:en] Otherwise, if [`v] names an array element or class member, the behavior is
that of evaluating [`[$e]`[[$i]`]] or [`[$e].[$m]], respectively, where [$e] is
the name of the variable initialized from the initializer of the structured
binding declaration, and [$i] is the index of the element referred to by [`v] or
[$m] is the name of the member referred to by [`v], respectively.
[:zh_CN] 否则，如果 [`v] 指名的事数组元素或者类成员，则其行为分别为求值 [`[$e]`[[$i]`]]
或 [`[$e].[$m]] 的行为，其中 [$e] 是以结构化绑定声明式的初始化式所初始化的变量的名字，
而 [$i] 是 [`v] 所指代的元素的索引，或者 [$m] 是 [`v] 所指代的成员的名字。
[list:end]

[begin:example]
[codeblock]
#include <tuple>
struct S {
  mutable int m;
  constexpr S(int m): m(m) {}
  virtual int g() const;
};
void f(std::tuple<S&> t) {
  auto [r] = t;
  static_assert(r.g() >= 0);            // [:en] error: dynamic type is constexpr-unknown \
                                        [:zh_CN] 错误：动态类型 constexpr 未知
  constexpr auto [m] = S(1);
  static_assert(m == 1);                // [:en] error: lvalue-to-rvalue conversion on mutable \
                                        [:zh_CN] 错误：对 mutable 子对象 [`e.m] 实施左值向右值转换，
                                        // [:en] subobject [`e.m], where [`e] is a constexpr object of type [`S] \
                                        [:zh_CN] 其中 [`e] 是 [`S] 类型的 constepr 对象
  using A = int[2];
  constexpr auto [v0, v1] = A{2, 3};
  static_assert(v0 + v1 == 5);          // [:en] OK, equivalent to [`e`[0`] + e`[1`]] where [`e] is a constexpr array \
                                        [:zh_CN] OK，等价于 [`e`[0`] + e`[1`]]，其中 [`e] 为 constexpr 数组
}
[codeblock:end]
[end:example]

[para]
[:en] During the evaluation of an expression [$E] as a core constant expression,
all [~id-expression]s and uses of [`*[`:key this]] that refer to an object or
reference whose lifetime did not begin with the evaluation of [$E] are treated
as referring to a specific instance of that object or reference whose lifetime
and that of all subobjects (including all union members) includes the entire
constant evaluation.
[:zh_CN] 将表达式 [$E] 作为核心常量表达式的求值过程中，所有[~标识表达式]和对
[`*[`:key this]] 的使用，若其所代表的对象或引用的生存期并非开始于 [$E] 的求值，
则均被当做代表该对象或引用的一个特定实例，其生存期和其所有子对象（包括所有联合体
成员）的生存期均包含整个常量求值。

[:en] For such an object that is not usable in constant expressions, the dynamic
type of the object is [+constexpr-unknown].
[:zh_CN] 不能在常量表达式中使用的这种对象，其动态类型是 [+constexpr 未知]的。

[:en] For such a reference that is not usable in constant expressions, the
reference is treated as binding to an unspecified object of the referenced type
whose lifetime and that of all subobjects includes the entire constant
evaluation and whose dynamic type is constexpr-unknown.
[:zh_CN] 不能在常量表达式中使用的这种引用，被当作绑定到某个被引用类型的一个特定对象，
其生存期和所有子对象的生存期均包含整个常量求值，且其动态类型是 constexpr 未知的。

[begin:example]
[codeblock]
template <typename T, size_t N>
constexpr size_t array_size(T (&)[N]) {
  return N;
}

void use_array(int const (&gold_medal_mel)[2]) {
  constexpr auto gold = array_size(gold_medal_mel);     // OK
}

constexpr auto olympic_mile() {
  const int ledecky = 1500;
  return []{ return ledecky; };
}
static_assert(olympic_mile()() == 1500);                // OK

struct Swim {
  constexpr int phelps() { return 28; }
  virtual constexpr int lochte() { return 12; }
  int coughlin = 12;
};

constexpr int how_many(Swim& swam) {
  Swim* p = &swam;
  return (p + 1 - 1)->phelps();
}

void splash(Swim& swam) {
  static_assert(swam.phelps() == 28);           // OK
  static_assert((&swam)->phelps() == 28);       // OK

  Swim* pswam = &swam;
  static_assert(pswam->phelps() == 28);         // [:en] error: lvalue-to-rvalue conversion on a pointer \
                                                [:zh_CN] 错误：对不能用与常量表达式的指针
                                                // [:en@~] not usable in constant expressions \
                                                [:zh_CN] 进行左值向右值转换

  static_assert(how_many(swam) == 28);          // OK
  static_assert(Swim().lochte() == 12);         // OK

  static_assert(swam.lochte() == 12);           // [:en] error: invoking virtual function on reference \
                                                [:zh_CN] 错误：在具有 constexpr 未知动态类型的引用上
                                                // [:en@~] with constexpr-unknown dynamic type \
                                                [:zh_CN@~] 调用虚函数

  static_assert(swam.coughlin == 12);           // [:en] error: lvalue-to-rvalue conversion on an object \
                                                [:zh_CN] 错误：对不能用与常量表达式的对象
                                                // [:en@~] not usable in constant expressions \
                                                [:zh_CN] 进行左值向右值转换
}

extern Swim dc;
extern Swim& trident;

constexpr auto& sandeno   = typeid(dc);         // [:en] OK, can only be [`typeid(Swim)] \
                                                [:zh_CN] OK，只能是 [`typeid(Swim)]
constexpr auto& gallagher = typeid(trident);    // [:en] error: constexpr-unknown dynamic type \
                                                [:zh_CN] 错误：constexpr 未知的动态类型
[codeblock:end]
[end:example]

[para]
[:en] An object [`a] is said to have [+:adj constant[!destruction]] if
[:zh_CN] 以下情况下，称对象 [`a] 具有[+:adj 常量[!销毁]]：

[list]
[item]
[:en] it is not of class type nor (possibly multidimensional) array thereof, or
[:zh_CN] 它不为类类型或其（可能多维的）数组，或者
[item]
[:en] it is of class type or (possibly multidimensional) array thereof, that
class type has a constexpr destructor, and for a hypothetical expression [$E]
whose only effect is to destroy [`a], [$E] would be a core constant expression
if the lifetime of [`a] and its non-mutable subobjects (but not its mutable
subobjects) were considered to start within [$E].
[:zh_CN] 它为类类型或其（可能多维的）数组，此类类型具有 constexpr 析构函数，并且
对于仅有效果为销毁 [`a] 的虚构的表达式 [$E]，如果 [`a] 及其非 mutable 子对象
（但不包括其 mutable 子对象）的生存期被当做开始于 [$E] 之内，则 [$E] 可为核心
常量表达式。
[list:end]

[para]
[:en] An [+:adj integral constant[!expression]] is an expression of integral or
unscoped enumeration type, implicitly converted to a prvalue, where the
converted expression is a core constant expression.
[:zh_CN] [+:adj 整型常量[!表达式]]是整型或无作用域枚举类型的表达式，被隐式转换为
纯右值，其中的转换后的表达式是核心常量表达式。

[begin:note]
[:en] Such expressions can be used as bit-field lengths ([#class.bit]), as
enumerator initializers if the underlying type is not fixed ([#dcl.enum]), and
as alignments ([#dcl.align]).
[:zh_CN] 此种表达式可用作位字段的长度（[#class.bit]），底层类型并未固定的枚举符的
初始化式（[#dcl.enum]），以及对齐（[#dcl.align]）。
[end:note]

[para]
[:en] If an expression of literal class type is used in a context where an
integral constant expression is required, then that expression is contextually
implicitly converted ([#conv]) to an integral or unscoped enumeration type and
the selected conversion function shall be [`:key constexpr].
[:zh_CN] 如果字面类类型的表达式用在需要整型常量表达式的语境中，则该表达式被按语境
隐式转换（[#conv]）为某种整型或无作用域枚举类型，且所选择的转换函数应当为
[`:key constexpr]。

[begin:example]
[codeblock]
struct A {
  constexpr A(int i) : val(i) { }
  constexpr operator int() const { return val; }
  constexpr operator long() const { return 42; }
private:
  int val;
};
constexpr A a = alignof(int);
alignas(a) int n;               // [:en] error: ambiguous conversion [:zh_CN] 错误：有歧义的转换
struct B { int n : a; };        // [:en] error: ambiguous conversion [:zh_CN] 错误：有歧义的转换
[codeblock:end]
[end:example]

[para]
[:en] A [+:adj converted constant[!expression]] of type [`T] is an expression,
implicitly converted to type [`T], where the converted expression is a constant
expression and the implicit conversion sequence contains only
[:zh_CN] 类型 [`T] 的[+:adj 经转换的常量[!表达式]]是被隐式转换为类型 [`T] 的表达式，
其中的转换后的表达式是常量表达式，并且隐式转换序列中只包含

[list]
[item]
[:en@~] user-defined conversions,
[:zh_CN@~] 用户定义转换，
[item]
[:en@~] lvalue-to-rvalue conversions ([#conv.lval]),
[:zh_CN@~] 左值向右值转换（[#conv.lval]]），
[item]
[:en@~] array-to-pointer conversions ([#conv.array]),
[:zh_CN@~] 数组向指针转换（[#conv.array]），
[item]
[:en@~] function-to-pointer conversions ([#conv.func]),
[:zh_CN@~] 函数向指针转换（[#conv.func]），
[item]
[:en@~] qualification conversions ([#conv.qual]),
[:zh_CN@~] 限定转换（[#conv.qual]），
[item]
[:en@~] integral promotions ([#conv.prom]),
[:zh_CN@~] 整型提升（[#conv.prom]），
[item]
[:en@~] integral conversions ([#conv.integral]) other than narrowing conversions
([#dcl.init.list]),
[:zh_CN@~] 除了窄化转换（[#dcl.init.list]）之外的整型转换（[#conv.integral]），
[item]
[:en@~] floating-point promotions ([#conv.fpprom]),
[:zh_CN@~] 浮点提升（[#conv.fpprom]），
[item]
[:en@~] floating-point conversions ([#conv.double]) where the source value can
be represented exactly in the destination type,
[:zh_CN@~] 源值可以被目标类型精确表示的浮点转换（[#conv.double]），
[item]
[:en@~] null pointer conversions ([#conv.ptr]) from [`std::nullptr_t], and
[:zh_CN@~] 从 [`std::nullptr_t] 进行的空指针转换（[#conv.ptr]），
[item]
[:en@~] null member pointer conversions ([#conv.mem]) from [`std::nullptr_t],
[:zh_CN@~] 从 [`std::nullptr_t] 进行的空成员指针转换（[#conv.mem]），以及
[item]
[:en@~] function pointer conversions ([#conv.fctptr]),
[:zh_CN@~] 函数指针转换（[#conv.fctptr]），
[list:end]

[:en@~] and where the reference binding (if any) binds directly.
[:zh_CN@~] 并且其中的引用绑定（如果有）是直接绑定。

[begin:note]
[:en] Such expressions can be used in [`:key new] expressions ([#expr.new]), as
case expressions ([#stmt.switch]), as enumerator initializers if the underlying
type is fixed ([#dcl.enum]), as array bounds ([#dcl.array]), and as non-type
template arguments ([#temp.arg]).
[:zh_CN] 此种表达式可用在 [`:key new] 表达式中（[#expr.new]），用作 case 表达式
（[#stmt.switch]），用作底层类型已固定的枚举符的初始化式（[#dcl.enum]），用作
数组边界（[#dcl.array]），以及用作整型或枚举的非类型模板实参（[#temp.arg]）。
[end:note]

[:en]
[%contextually converted constant expression of type [`bool]
[%conversion[!contextual]]]
[%conversion[!contextual to constant expression of type [`bool]]]
A [+:% contextually converted constant expression of type [`bool]] is an
expression, contextually converted to [`:key bool] ([#conv]), where the
converted expression is a constant expression and the conversion sequence
contains only the conversions above.
[:zh_CN]
[%按语境转换为类型 [`bool] 的常量表达式 [%转换[!按语境～]]]
[%转换[!按语境～为类型 [`bool] 的常量表达式]]
[+:% 按语境转换为类型 [`bool] 的常量表达式]，是按语境转换为 [`:key bool]（[#conv]）
的表达式，所转换的表达式是常量表达式，且其转换序列中仅包含上述转换。

[para]
[:en] A [+:adj constant[!expression]] is either a glvalue core constant
expression that refers to an object or a non-immediate function, or a prvalue
core constant expression whose value satisfies the following constraints:
[:zh_CN] [+:adj 常量[!表达式]]是泛左值核心常量表达式，其值所指代的是对象或非立即函数，
或者是纯右值核心常量表达式，其值满足如下约束条件：

[list]
[item]
[:en] each constituent reference refers to an object or a non-immediate function,
[:zh_CN] 每个成分引用都指代对象或非立即函数，

[item]
[:en] no constituent value of scalar type is an indeterminate value ([#basic.indet]),
[:zh_CN] 没有标量类型成分值具有不确定值（[#basic.indet]），

[item]
[:en] no constituent value of pointer type is a pointer to an immediate function
or an invalid pointer value ([#basic.compound]), and
[:zh_CN] 没有指针类型的成分值指向立即函数的指针或无效指针值（[#basic.compound]），并且

[item]
[:en] no constituent value of pointer-to-member type designates an immediate function.
[:zh_CN] 没有成员指针类型的成分值指代立即函数。
[list:end]

[begin:note]
[:en] A glvalue core constant expression that either refers to or points to an
unspecified object is not a constant expression.
[:zh_CN] 指代或指向未指明对象的泛左值核心常量表达式不是常量表达式。
[end:note]

[begin:example]
[codeblock]
consteval int f() { return 42; }
consteval auto g() { return f; }
consteval int h(int (*p)() = g()) { return p(); }
constexpr int r = h();                          // OK
constexpr auto e = g();                         // [:en] error: a pointer to an immediate function is \
                                                [:zh_CN] 错误：指向直接函数的指针不能
                                                // [:en@~] not a permitted result of a constant expression \
                                                [:zh_CN@~] 作为常量表达式的结果

struct S {
  int x;
  constexpr S() {}
};
int i() {
  constexpr S s;                                // [:en] error: [`s.x] has erroneous value [:zh_CN] 错误：[`s.x] 具有错误值
}
[codeblock:end]
[end:example]

[para:recommended]
[:en] Implementations should provide consistent results of floating-point
evaluations, irrespective of whether the evaluation is performed during
translation or during program execution.
[:zh_CN] 实现最好为浮点求值提供一致的结果，与求值是否实际发生于翻译过程中还是程序
执行过程中无关。

[begin:note]
[:en] Since this document imposes no restrictions on the accuracy of
floating-point operations, it is unspecified whether the evaluation of a
floating-point expression during translation yields the same result as the
evaluation of the same expression (or the same operations on the same values)
during program execution.
[:zh_CN] 由于本文档并不对浮点运算的精度施加任何限制，所以在翻译过程中对浮点表达式
进行的求值所产生的结果，与同一个表达式（或者对相同的值进行相同的运算）在程序执行过程中
所产生的结果是否相同，是未指明的。

[begin:example]
[codeblock]
bool f() {
    char array[1 + int(1 + 0.2 - 0.1 - 0.1)];   // [:en] Must be evaluated during translation \
                                                [:zh_CN] 必须在翻译过程中求值
    int size = 1 + int(1 + 0.2 - 0.1 - 0.1);    // [:en] May be evaluated at runtime \
                                                [:zh_CN] 可以在运行时求值
    return sizeof(array) == size;
}
[codeblock:end]

[:en] It is unspecified whether the value of [`f()] will be [`true] or [`false].
[:zh_CN] [`f()] 的值是 [`true] 还是 [`false] 是未指明的。
[end:example]
[end:note]

[para]
[:en] An expression or conversion is in an [+immediate function context] if it
is potentially evaluated and either:
[:zh_CN] 一个表达式或转换，如果它是潜在求值的且满足以下情况，则它处于[+直接函数语境]之中：
[list]
[item]
[:en@~] its innermost enclosing non-block scope is a function parameter scope of
an immediate function,
[:zh_CN@~] 其最内层外围非块作用域是某个直接函数的函数形参作用域，
[item]
[:en@~] it is a subexpression of a manifestly constant-evaluated expression or
conversion, or
[:zh_CN@~] 它是显然常量求值的表达式或转换的子表达式，或者
[item]
[:en@~] its enclosing statement is enclosed ([#stmt.pre]) by the
[~compound-statement] of a consteval if statement ([#stmt.if]).
[:zh_CN@~] 其外围语句被 consteval if 语句（[#stmt.if]）的[~复合语句]所包围（[#stmt.pre]）。
[list:end]

[:en] An invocation is an [+immediate invocation] if it is a
potentially-evaluated explicit or implicit invocation of an immediate function
and is not in an immediate function context.
[:zh_CN] 一次调用，如果它是潜在求值的对某个直接函数的显式或隐式调用，且并非处于
直接函数语境之中，则它是一次[+直接调用]。

[:en] An aggregate initialization is an immediate invocation
if it evaluates a default member initializer
that has a subexpression that is an immediate-escalating expression.
[:zh_CN] 如果聚合初始化求值的某个默认成员初始化式带有子表达式是直接性扩散表达式，
则它是一次直接调用。

[para]
[:en]
[%@defn expression[!immediate-escalating]]
[%@defn conversion[!immediate-escalating]]
[%@defn immediate-escalating[!expression][%expression[!immediate-escalating]]]
[%@defn immediate-escalating[!conversion][%conversion[!immediate-escalating]]]
An expression or conversion is [+immediate-escalating] if it is not initially in
an immediate function context and it is either
[:zh_CN]
[%@defn 表达式[!直接性扩散]]
[%@defn 转换[!直接性扩散]]
[%@defn 直接性扩散[!表达式][%表达式[!直接性扩散]]]
[%@defn 直接性扩散[!转换][%转换[!直接性扩散]]]
如果表达式或转换并非起初处于直接函数语境中，且其为以下之一，则它是[+直接性扩散]的：
[list]
[item]
[:en] a potentially-evaluated [~id-expression] that denotes an immediate
function that is not a subexpression of an immediate invocation, or
[:zh_CN] 代表某个直接函数的潜在求值的[~标识表达式]，它不是某个直接调用的子表达式，或者
[item]
[:en] an immediate invocation that is not a constant expression and is not a
subexpression of an immediate invocation.
[:zh_CN] 并非常量表达式且并非直接调用的子表达式的直接调用。
[list:end]

[para]
[:en] [%@defn immediate-escalating[!function][%function[!immediate-escalating]]]
An [+immediate-escalating[%function[!immediate-escalating]]] function is
[:zh_CN] [%@defn 直接性扩散[!函数][%函数[!直接性扩散]]]
[+直接性扩散[%函数[!直接性扩散]]]函数是
[list]
[item]
[:en] the call operator of a lambda that is not declared
with the [`:key consteval] specifier,
[:zh_CN] 并非以 [`:key consteval] 说明符声明的 lambda 表达式的的与运算符，
[item]
[:en] a defaulted special member function that is not declared with the
[`:key consteval] specifier, or
[:zh_CN] 并非以 [`:key consteval] 说明符声明的预置的特殊成员函数，或者
[item]
[:en] a function that results from the instantiation of a templated entity
defined with the [`:key constexpr] specifier.
[:zh_CN] 从对以 [`:key constexpr] 说明符定义的模板化实体进行实例化所得到的函数。
[list:end]

[:en] An immediate-escalating expression shall appear only in an
immediate-escalating function.
[:zh_CN] 直接性扩散表达式只能出现于直接性扩散函数之中。

[para]
[:en] An [+:adj immediate[!function]] is a function or constructor that is
[:zh_CN] [+:adj 直接[!函数]]是以下函数或构造函数：
[list]
[item]
[:en] declared with the [`:key consteval] specifier, or
[:zh_CN] 以 [`:key consteval] 声明，或者
[item]
[:en] an immediate-escalating function [`[^F]] whose function body contains an
immediate-escalating expression [`[^E]] such that [`[^E]][=']s innermost
enclosing non-block scope is [`[^F]][=']s function parameter scope.
[:zh_CN] 直接性扩散函数 [`[^F]]，其函数体包含某个直接性扩散表达式 [`[^E]]，
使得 [`[^E]] 的最内层外围非块作用域是 [`[^F]] 的函数形参作用域。

[begin:note@tail]
[:en] Default member initializers used to initialize a base or member subobject
([#class.base.init]) are considered to be part of the function body
([#dcl.fct.def.general]).
[:zh_CN] 用于初始化基类和成员子对象的默认成员初始化式（[#class.base.init]）被
当做函数体的一部分（[#dcl.fct.def.general]）。
[end:note]
[list:end]

[begin:example]
[codeblock]
consteval int id(int i) { return i; }
constexpr char id(char c) { return c; }

template<class T>
constexpr int f(T t) {
  return t + id(t);
}

auto a = &f<char>;              // [:en] OK, [`f<char>] is not an immediate function \
                                [:zh_CN] OK，[`f<char>] 不是直接函数
auto b = &f<int>;               // [:en] error: [`f<int>] is an immediate function \
                                [:zh_CN] 初吻：[`f<int>] 是直接函数

static_assert(f(3) == 6);       // OK

template<class T>
constexpr int g(T t) {          // [:en] [`g<int>] is not an immediate function \
                                [:zh_CN] [`g<int>] 不是直接函数
  return t + id(42);            // [:en@~] because [`id(42)] is already a constant \
                                [:zh_CN@~] 因为 [`id(42)] 已经是常量
}

template<class T, class F>
constexpr bool is_not(T t, F f) {
  return not f(t);
}

consteval bool is_even(int i) { return i % 2 == 0; }

static_assert(is_not(5, is_even));      // OK

int x = 0;

template<class T>
constexpr T h(T t = id(x)) {    // [:en] [`h<int>] is not an immediate function \
                                [:zh_CN] [`h<int>] 不是直接函数
                                // [:en] [`id(x)] is not evaluated when parsing the default argument ([#dcl.fct.default], [#temp.inst]) \
                                [:zh_CN] 解析默认实参时并未对 [`id(x)] 求值（[#dcl.fct.default]，[#temp.inst]）
    return t;
}

template<class T>
constexpr T hh() {              // [:en] [`hh<int>] is an immediate function because of the invocation \
                                [:zh_CN] [`hh<int>] 是直接函数，这是源于在 [`h<int>]
  return h<T>();                // [:en@~] of the immediate function [`id] in the default argument of [`h<int>] \
                                [:zh_CN@~] 的默认实参中对直接函数 [`id] 进行的调用
}

int i = hh<int>();              // [:en] error: [`hh<int>()] is an immediate-escalating expression \
                                [:zh_CN] 错误：[`hh<int>()] 是直接性扩散函数 \
                                // [:en@~] outside of an immediate-escalating function \
                                [:zh_CN@~] 外面的直接性扩散表达式

struct A {
  int x;
  int y = id(x);
};

template<class T>
constexpr int k(int) {          // [:en] [`k<int>] is not an immediate function because [`A(42)] is a \
                                [:zh_CN] [`k<int>] 不是直接函数，因为 [`A(42)] 是
  return A(42).y;               // [:en@~] constant expression and thus not immediate-escalating \
                                [:zh_CN@~] 常量表达式因而不是直接性扩散的
}
[codeblock:end]
[end:example]

[para]
[:en] An expression or conversion is [+manifestly constant-evaluated] if it is:
[:zh_CN] 符合以下情况的表达式或转换是[+显然常量求值的]：

[list]
[item]
[:en@~] a [~constant-expression], or
[:zh_CN@~] [~常量表达式]，或
[item]
[:en@~] the condition of a constexpr if statement ([#stmt.if]), or
[:zh_CN@~] [`constexpr if] 语句的条件（[#stmt.if]），或
[item]
[:en@~] an immediate invocation, or
[:zh_CN@~] 直接调用，或
[item]
[:en@~] the result of substitution into an atomic constraint expression
to determine whether it is satisfied ([#temp.constr.atomic]), or
[:zh_CN@~] 向原子约束表达式中进行代换以确定其是否被满足（[#temp.constr.atomic]）
的结果，或
[item]
[:en@~] the initializer of a variable that is usable in constant expressions or
has constant initialization ([#basic.start.static]).[#:fn]
[:zh_CN@~] 可被用在常量表达式中，或具有常量初始化的变量的初始化式
（[#basic.start.static]）[#:fn]。

[note:foot]
[:en] Testing this condition can involve a trial evaluation of its initializer
as described above.
[:zh_CN] 这个条件的测试可以涉及对其初始化式进行如上所述的平凡求值。
[note:end]

[begin:example]
[codeblock]
template<bool> struct X {};
X<std::is_constant_evaluated()> x;                      // [:en] type [`X<true>] [:zh_CN] 类型 [`X<true>]
int y;
const int a = std::is_constant_evaluated() ? y : 1;     // [:en] dynamic initialization to 1 [:zh_CN] 动态初始化为 1
double z[a];                                            // [:en] error: [`a] is not usable [:zh_CN] 错误：[`a] 不能被用在
                                                        // [:en@~] in constant expressions [:zh_CN@~] 常量表达式值中
const int b = std::is_constant_evaluated() ? 2 : y;     // [:en] static initialization to 2 [:zh_CN] 静态初始化为 2
int c = y + (std::is_constant_evaluated() ? 2 : y);     // [:en] dynamic initialization to [`y+y] \
                                                        [:zh_CN] 动态初始化为 [`y+y]

constexpr int f() {
  const int n = std::is_constant_evaluated() ? 13 : 17; // [:en] [`n] is 13 [:zh_CN] [`n] 为 13
  int m = std::is_constant_evaluated() ? 13 : 17;       // [:en] [`m] can be 13 or 17 (see below) \
                                                        [:zh_CN] [`m] 可为 13 或 17（见下文）
  char arr[n] = {}; // char[13]
  return m + sizeof(arr);
}
int p = f();                                            // [:en] [`m] is 13; initialized to 26 [:zh_CN] [`m] 为 13；初始化为 26
int q = p + f();                                        // [:en] [`m] is 17 for this call; initialized to 56 \
                                                        [:zh_CN] [`m] 在本次调用中为 17；初始化为 56
[codeblock:end]
[end:example]
[list:end]

[begin:note]
[:en] Except for a [~static_assert-message], a manifestly constant-evaluated
expression is evaluated even in an unevaluated operand
([#term.unevaluated.operand]).
[:zh_CN] 除了 [~static_assert-消息]，显然常量求值表达式即便在免求值操作数中仍被
求值（[#term.unevaluated.operand]）。
[end:note]

[para]
[:en] [%expression[!potentially constant evaluated]]
An expression or conversion is [+potentially constant evaluated] if it is:
[:zh_CN] [%表达式[!潜在常量求值]]
如下情况下表达式或转换被[+潜在常量求值]：

[list]
[item]
[:en] a manifestly constant-evaluated expression,
[:zh_CN] 显然常量求值表达式，

[item]
[:en] a potentially-evaluated expression ([#basic.def.odr]),
[:zh_CN] 潜在求值表达式（[#basic.def.odr]），

[item]
[:en] an immediate subexpression of a [~braced-init-list],[#:fn]
[:zh_CN] [~花括号初始化列表]的直接子表达式[#:fn]，

[note:foot]
[:en] In some cases, constant evaluation is needed to determine whether a
narrowing conversion is performed ([#dcl.init.list]).
[:zh_CN] 某些情况下，为确定是否会实施窄化转换需要进行常量求值（[#dcl.init.list]）。
[note:end]

[item]
[:en] an expression of the form [`&] [~cast-expression] that occurs within a
templated entity,[#:fn] or
[:zh_CN] 在模板化的实体中出现的形式为“[`&] [~转型表达式]”的表达式[#:fn]，或者

[note:foot]
[:en] In some cases, constant evaluation is needed to determine whether such an
expression is value-dependent ([#temp.dep.constexpr]).
[:zh_CN] 某些情况下，为确定这种表达式是否是值待决的需要进行常量求值（[#temp.dep.constexpr]）。
[note:end]

[item]
[:en] a potentially-evaluated subexpression ([#intro.execution]) of one of the
above.
[:zh_CN] 以上各项之一的潜在求值子表达式（[#intro.execution]）。
[list:end]

[:en]
[%function[!needed for constant evaluation]]
[%variable[!needed for constant evaluation]]
A function or variable is [+needed for constant evaluation] if it is:
[:zh_CN]
[%函数[!常量求值所需的]]
[%变量[!常量求值所需的]]
以下情况下函数或变量是[+常量求值所需的]：

[list]
[item]
[:en] a constexpr function that is named by an expression ([#basic.def.odr])
that is potentially constant evaluated, or
[:zh_CN] 被潜在常量求值的表达式所指名（[#basic.def.odr]）的 constexpr 函数，或者

[item]
[:en] a potentially-constant variable named by a potentially constant evaluated
expression.
[:zh_CN] 被潜在常量求值表达式所指名的潜在常量变量。
[list:end]
