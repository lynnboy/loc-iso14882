[section#expr.const
    [:en] Constant expressions
    [:zh_CN] 常量表达式

[:en]
[%expression[!constant]]
[:zh_CN]
[%表达式[!常量～]]
]

[para]
[:en]
Certain contexts require expressions that satisfy additional requirements as
detailed in this subclause; other contexts have different semantics depending
on whether or not an expression satisfies these requirements.
[:zh_CN]
一些特定的语境中，需要符合本子条款中所详述的额外规定的表达式；其他一些语境中则
根据表达式能否满足这些规定而具有不同的语义。

[:en]
Expressions that satisfy these requirements, assuming that copy elision
([#class.copy.elision]) is performed, are called [%@defn expression[!constant]]
[+constant expressions [%constant expression]].
[:zh_CN]
符合这些规定的表达式，假定其实施了复制消除（[#class.copy.elision]），被称作
[%@defn 表达式[!常量～]][+常量表达式]。

[begin:note]
[:en]
Constant expressions can be evaluated during translation.
[:zh_CN]
常量表达式可以在翻译期间求值。
[end:note]

[syntax]
[rule constant-expression [:zh_CN] 常量表达式 ]
    [| conditional-expression ]
[rule:end]
[syntax:end]

[para]
[:en]
A variable or temporary object [`o] is [+constant-initialized] if
[:zh_CN]
满足以下条件时，变量或临时对象 [`o] 被[+以常量初始化]：

[list]
[item]
[:en] either it has an initializer or its default-initialization results in some
initialization being performed, and
[:zh_CN] 要么它带有一个初始化式，要么其默认初始化导致进行某种初始化，并且

[item]
[:en] the full-expression of its initialization is a constant expression when
interpreted as a [~constant-expression], except that if [`o] is an object, that
full-expression may also invoke constexpr constructors for [`o] and its
subobjects even if those objects are of non-literal class types.
[:zh_CN] 其初始化的全表达式当作为[~常量表达式]解释时是常量表达式，不过当 [`o] 是
对象时，该全表达式还可以为 [`o] 及其子对象调用 constexpr 构造函数，即便这些对象
具有非字面类类型也是如此。

[begin:note]
[:en]
Such a class can have a non-trivial destructor.
[:zh_CN]
这样的类可以带有非平凡的析构函数。

[:en]
Within this evaluation, [`std::is_constant_evaluated()] ([#meta.const.eval])
returns [`:key true].
[:zh_CN]
在这种求值之中时，[`std::is_constant_evaluated()]（[#meta.const.eval]）将返回
[`:key true]。
[end:note]
[list:end]

[para]
[:en]
A variable is [+potentially-constant] if it is constexpr or it has reference or
non-volatile const-qualified integral or enumeration type.
[:zh_CN]
如果变量是 constexpr 变量，或者它具有引用或非 volatile 的 const 限定的整型或
枚举类型，则它是[+潜在常量]。

[para]
[:en]
A constant-initialized potentially-constant variable [$V] is [+usable in
constant expressions] at a point [$P] if [$V][=']s initializating declaration
[$D] is reachable from [$P] and
[:zh_CN]
以常量初始化的潜在常量变量 [$V]，如果 [$V] 的初始化声明式 [$D] 从某点 [$P] 处
可达，且符合以下情况，则它在 [$P] 点[+可被用在常量表达式之中]。

[list]
[item]
[:en@~] it is constexpr,
[:zh_CN@~] 它为 constexpr，
[item]
[:en@~] it is not initialized to a TU-local value, or
[:zh_CN@~] 它并非以翻译单元局部的值所初始化，或
[item]
[:en@~] [$P] is in the same translation unit as [$D].
[:zh_CN@~] [$P] 与 [$D] 处于相同翻译单元中。
[list:end]

[:en]
An object or reference is [+usable in constant expressions] if it is
[:zh_CN]
以下情况下，对象或引用[+可被用在常量表达式之中]：

[list]
[item]
[:en@~] a variable that is usable in constant expressions, or
[:zh_CN@~] 可被用在常量表达式之中的变量，或
[item]
[:en@~] a template parameter object ([#temp.param]), or
[:zh_CN@~] 模板形参对象（[#temp.param]），或
[item]
[:en@~] a string literal object ([#lex.string]), or
[:zh_CN@~] 字符串字面量对象（[#lex.string]），或
[item]
[:en@~] a temporary object of non-volatile const-qualified literal type whose
lifetime is extended ([#class.temporary]) to that of a variable that is usable
in constant expressions, or
[:zh_CN@~] 非 volatile 且 const 限定的字面量类型的临时对象，并且其生存期已扩展
（[#class.temporary]）到某个可在常量表达式中使用的变量的生存期，或
[item]
[:en@~] a non-mutable subobject or reference member of any of the above.
[:zh_CN@~] 以上任一的非 mutable 子对象或引用成员。
[list:end]

[para]
[:en]
An expression [$E] is a [+:adj core constant[!expression]] unless the evaluation
of [$E], following the rules of the abstract machine ([#intro.execution]), would
evaluate one of the following:
[:zh_CN]
表达式 [$E] 是[+:adj 核心常量[!表达式]]，但根据抽象机器的规则（[#intro.execution]）
对 [$E] 进行求值中，不能包含下列求值：

[list]
[item]
[:en] [`:key this] ([#expr.prim.this]), except
[:zh_CN] [`:key this]（[#expr.prim.this]），但
[list]
[item]
[:en@~] in a constexpr function ([#dcl.constexpr]) that is being evaluated as
part of [$E] or
[:zh_CN@~] 作为 [$E] 的求值的一部分而求值的 constexpr 函数（[#dcl.constexpr]）
中的，或者
[item]
[:en@~] when appearing as the [~postfix-expression] of an implicit or explicit
class member access expression ([#expr.ref]);
[:zh_CN@~] 作为隐式或显式成员访问表达式（[#expr.ref]）的[~后缀表达式]不算作其中；
[list:end]

[item]
[:en] a control flow that passes through a declaration of a block variable
([#basic.scope.block]) with static ([#basic.stc.static]) or thread
([#basic.stc.thread]) storage duration, unless that variable is usable in
constant expressions;
[:zh_CN] 控制流通过具有静态（[#basic.stc.static]）或线程（[#basic.stc.thread]）
存储期的块变量（[#basic.scope.block]）的声明式，除非该变量可在常量表达式中使用；

[begin:example]
[codeblock]
constexpr char test() {
  static const int x = 5;
  static constexpr char c[] = "Hello World";
  return *(c + x);
}
static_assert(' ' == test());
[codeblock:end]
[end:example]

[item]
[:en] an invocation of a non-constexpr function;[#:fn]
[:zh_CN] 进行了非 constexpr 函数的调用[#:fn]；

[note:foot]
[:en] Overload resolution ([#over.match]) is applied as usual
[:zh_CN] 照常进行重载决议（[#over.match]）
[note:end]

[item]
[:en] an invocation of an undefined constexpr function;
[:zh_CN] 进行了未定义的 constexpr 函数的调用；

[item]
[:en] an invocation of an instantiated constexpr function that is not
constexpr-suitable;
[:zh_CN] 调用所实例化的 constexpr 函数但其并不适于 constexpr；

[item]
[:en] an invocation of a virtual function ([#class.virtual]) for an object whose
dynamic type is constexpr-unknown;
[:zh_CN] 为某个动态类型 constexpr 未知的对象调用虚函数（[#class.virtual]）；

[item]
[:en] an expression that would exceed the implementation-defined limits (see
[#implimits]);
[:zh_CN] 可能超出由实现定义的限制额度的表达式（参见 [#implimits]）；

[item]
[:en] an operation that would have undefined or erroneous behavior as specified
in [#intro] through [#cpp], excluding [#dcl.attr.assume] and [#dcl.attr.noreturn];[#:fn]
[:zh_CN] 可能具有在本文档从 [#intro] 到 [#cpp]，除了 [#dcl.attr.assume] 和
[#dcl.attr.noreturn] 中所述的未定义或错误行为的操作[#:fn]；

[note:foot]
[:en] This includes, for example, signed integer overflow ([#expr.pre]), certain
pointer arithmetic ([#expr.add]), division by zero ([#expr.mul]), or certain
shift operations ([#expr.shift])
[:zh_CN] 这包括，（例如）有符号整数的溢出（[#expr.pre]），某些指针算术（[#expr.add]），
被零除（[#expr.mul]），或者某些移位操作（[#expr.shift]）
[note:end]

[item]
[:en] an lvalue-to-rvalue conversion unless it is applied to
[:zh_CN] 左值向右值转换，但排除实施于下列情况的左值

[list]
[item]
[:en] a non-volatile glvalue that refers to an object that is usable in constant
expressions, or
[:zh_CN] 指代某个可被用在常量表达式中的对象的非 volatile 泛左值，或者

[item]
[:en] a non-volatile glvalue of literal type that refers to a non-volatile object
whose lifetime began within the evaluation of [$E];
[:zh_CN] 字面类型的非 volatile 泛左值，指代在 [$E] 的求值中开始其生存期的非
volatile 对象；
[list:end]

[item]
[:en] an lvalue-to-rvalue conversion ([#conv.lval]) that is applied to a glvalue
that refers to a non-active member of a union or a subobject thereof;
[:zh_CN] 对指代某个联合体的非活跃成员或其子对象的泛左值，所实施的左值向右值转换
（[#conv.lval]）；

[item]
[:en] an lvalue-to-rvalue conversion that is applied to an object with an
indeterminate value ([#basic.indet]);
[:zh_CN] 对具有不确定值的对象（[#basic.indet]）实施左值向右值转换；

[item]
[:en] an invocation of an implicitly-defined copy/move constructor or copy/move
assignment operator for a union whose active member (if any) is mutable, unless
the lifetime of the union object began within the evaluation of [$E];
[:zh_CN] 对其活跃成员（如果有）为 mutable 成员的联合体调用隐式定义的复制/移动
构造函数或复制/移动赋值运算符，除非该联合体对象的生存期开始于 [$E] 的求值之中；

[item]
[:en] in a [~lambda-expression], a reference to [`:key this] or to a variable
with automatic storage duration defined outside that [~lambda-expression], where
the reference would be an odr-use ([#term.odr.use], [#expr.prim.lambda]);
[:zh_CN] 在 [~lambda-表达式]中，涉指了 [`:key this] 或者在该 [~lambda-表达式]
之外定义的具有动态存储期的变量，而该涉指可能是一次 ODR 式使用（[#term.odr.use]，
[#expr.prim.lambda]）；

[begin:example]
[codeblock]
void g() {
  const int n = 0;
  [=] {
    constexpr int i = n;        // [:en] OK, [`n] is not odr-used here \
                                [:zh_CN] OK，这里 [`n] 并未被 ODR 式使用
    constexpr int j = *&n;      // [:en] error: [`&n] would be an odr-use of [`n] \
                                [:zh_CN] 错误：[`&n] 可能是对 [`n] 的 ODR 式使用
  };
}
[codeblock:end]
[end:example]

[begin:note]
[:en] If the odr-use occurs in an invocation of a function call operator of a
closure type, it no longer refers to [`:key this] or to an enclosing automatic
variable due to the transformation ([#expr.prim.lambda.capture]) of the
[~id-expression] into an access of the corresponding data member.
[:zh_CN] 如果这次 ODR 式使用发生于某个闭包类型的函数调用运算符的执行中，则它不再
指代 [`:key this] 或者指代某个外围自动变量了，这是由于[~标识表达式]已被变换为其
对应的数据成员的访问（[#expr.prim.lambda.capture]）。

[begin:example]
[codeblock]
auto monad = [](auto v) { return [=] { return v; }; };
auto bind = [](auto m) {
  return [=](auto fvm) { return fvm(m()); };
};

// [:en] OK to capture objects with automatic storage duration created during constant expression evaluation. \
[:zh_CN] 俘获在常量表达式的求值过程中创建的具有自动存储期的对象是没问题的。
static_assert(bind(monad(2))(monad)() == monad(2)());
[codeblock:end]
[end:example]
[end:note]

[item]
[:en] a conversion from a prvalue [`P] of type [=lq]pointer to [=cv] [`:key void][=rq]
to a type [=lq][=cv cv1] pointer to [`T][=rq], where [`T] is not
[=cv cv2] [`:key void], unless [`P] points to an object whose type is similar to [`T];
[:zh_CN] 从类型“[=cv] [`:key void] 的指针”的纯右值 [`P] 向类型
“[`T] 的 [=cv cv1] 指针”的转换，其中 [`T] 并非 [=cv cv2] [`:key void]，但排除
[`P] 指向的对象的类型与 [`T] 相似的情况；

[item]
[:en]
a [`:key reinterpret_cast] ([#expr.reinterpret.cast]);
[:zh_CN]
[`:key reinterpret_cast]（[#expr.reinterpret.cast]）；

[item]
[:en]
a modification of an object ([#expr.ass], [#expr.post.incr], [#expr.pre.incr])
unless it is applied to a non-volatile lvalue of literal type that refers to a
non-volatile object whose lifetime began within the evaluation of [$E];
[:zh_CN]
对对象的改动（[#expr.ass]，[#expr.post.incr]，[#expr.pre.incr]），除非实施于非
volatile 的字面类型的左值，并且它指代某个生存期开始于 [$E] 的求值中的非 volatile
对象；

[item]
[:en]
an invocation of a destructor ([#class.dtor]) or a function call whose
[~postfix-expression] names a pseudo-destructor ([#expr.call]), in either case
for an object whose lifetime did not begin within the evaluation of [$E];
[:zh_CN]
调用析构函数（[#class.dtor]）或者[~后缀表达式]指名伪析构函数（[#expr.call]）的
函数调用，任何情况中均针对并非在 [$E] 的求值中开始其生存期的对象；

[item]
[:en]
a [~new-expression] ([#expr.new]), unless the selected allocation function is
a replaceable global allocation function ([#new.delete.single],
[#new.delete.array]) and the allocated storage is deallocated within the
evaluation of [$E];
[:zh_CN]
[~new-表达式]（[#expr.new]），除非所选中的分配函数为可替换的全局分配函数
（[#new.delete.single]，[#new.delete.array]），并且所分配的存储在 [$E] 的求值
之内被回收；

[item]
[:en]
a [~delete-expression] ([#expr.delete]), unless it deallocates a region of
storage allocated within the evaluation of [$E];
[:zh_CN]
[~delete-表达式]（[#expr.delete]），除非其回收在 [$E] 的求值之中所分配的存储区域；

[item]
[:en]
a call to an instance of [`std::allocator<T>::allocate] ([#allocator.members]),
unless the allocated storage is deallocated within the evaluation of [$E];
[:zh_CN]
对 [`std::allocator<T>::allocate]（[#allocator.members]）的某个实例的调用，除非
所分配的存储在 [$E] 的求值之中被回收；

[item]
[:en]
a call to an instance of [`std::allocator<T>::deallocate] ([#allocator.members]),
unless it deallocates a region of storage allocated within the evaluation of [$E];
[:zh_CN]
对 [`std::allocator<T>::deallocate]（[#allocator.members]）的某个实例的调用，
除非它回收 [$E] 的求值之中所分配的存储区域；

[item]
[:en]
an [~await-expression] ([#expr.await]);
[:zh_CN]
[~等待表达式]（[#expr.await]）；

[item]
[:en]
a [~yield-expression] ([#expr.yield]);
[:zh_CN]
[~产出表达式]（[#expr.yield]）；

[item]
[:en]
a three-way comparison ([#expr.spaceship]), relational ([#expr.rel]),
or equality ([#expr.eq]) operator where the result is unspecified;
[:zh_CN]
未指明结果的三路比较（[#expr.spaceship]）、关系（[#expr.rel]）或相等性
（[#expr.eq]）运算符；

[item]
[:en]
a [~throw-expression] ([#expr.throw]);
[:zh_CN]
[~throw-表达式]（[#expr.throw]）；

[item]
[:en]
a [`:key dynamic_cast] ([#expr.dynamic.cast]) or [`:key typeid] ([#expr.typeid])
expression on a glvalue that refers to an object whose dynamic type is
constexpr-unknown or that would throw an expression;
[:zh_CN]
运用于代表具有 constexpr 未知的动态类型的对象的泛左值上，或者可能抛出异常的
[`:key dynamic_cast]（[#expr.dynamic.cast]）或 [`typeid]（[#expr.typeid]）表达式；

[item]
[:en]
an [~asm-declaration] ([#dcl.asm]);
[:zh_CN]
[~asm-声明式]（[#dcl.asm]）；

[item]
[:en]
an invocation of the [`va_arg] macro ([#cstdarg.syn]);
[:zh_CN]
对 [`va_arg] 宏的调用（[#cstdarg.syn]）；

[item]
[:en]
a non-constant library call ([#defns.nonconst.libcall]); or
[:zh_CN]
非常量程序库调用（[#defns.nonconst.libcall]）；或者

[item]
[:en]
a [`:key goto] statement ([#stmt.goto]).
[:zh_CN]
[`:key goto] 语句（[#stmt.goto]）。

[begin:note]
[:en] A [`:key goto] statement introduced by equivalence ([#stmt.stmt]) is not
in scope.
[:zh_CN] 以等价形式引入（[#stmt.stmt]）的 [`:key goto] 语句并不在作用域中。

[:en] For example, a [`:key while] statement ([#stmt.while]) can be executed
during constant evaluation.
[:zh_CN] 例如，可以在常量求值中执行 [`:key while] 语句（[#stmt.while]）。
[end:note]
[list:end]

[para]
[:en]
It is unspecified whether [$E] is a core constant expression if [$E] satisfies
the constraints of a core constant expression, but evaluation of [$E] would
evaluate
[:zh_CN]
如果 [$E] 满足对核心常量表达式的约束，但对 [$E] 的求值可能会求值以下各项，那么
[$E] 是否是核心常量表达式是未指明的：

[list]
[item]
[:en@~] an operation that has undefined behavior as specified in [#library]
through [#[=lastlibchapter]],
[:zh_CN@~] 某个具有在从 [#library] 到 [#[=lastlibchapter]] 中所述的未定义行为的
操作，
[item]
[:en@~] an invocation of the [`va_start] macro ([#cstdarg.syn]),
[:zh_CN@~] 调用了 [`va_start] 宏（[#cstdarg.syn]），
[item]
[:en@~] a call to a function that was previously declared with the [`noreturn]
attribute ([#dcl.attr.noreturn]) and that call returns to its caller, or
[:zh_CN@~] 对之前以 [`noreturn] 属性（[#dcl.attr.noreturn]）声明的函数的调用，
而该调用返回到其调用方，或者
[item]
[:en@~] a statement with an assumption ([#dcl.attr.assume]) whose converted
[~conditional-expression], if evaluated where the assumption appears,
would not disqualify [$E] from being a core constant expression and
would not evaluate to [`true].
[:zh_CN@~] 带有假设（[#dcl.attr.assume]）的语句，其转换后的[~条件表达式]如果在
假设出现之处求值本不会妨碍 [$E] 作为核心常量表达式且本会求值为 [`true]。

[begin:note]
[:en]
[$E] is not disqualified from being a core constant expression if the
hypothetical evaluation of the converted [~conditional-expression] would
disqualify [$E] from being a core constant expression.
[:zh_CN]
如果虚构的对转换后的[~条件表达式]的求值妨碍 [$E] 作为核心常量表达式，则不妨碍
[$E] 称为核心常量表达式。
[end:note]
[list:end]

[begin:example]
[codeblock]
int x;                              // [:en] not constant \
                                    [:zh_CN] 不是常量
struct A {
  constexpr A(bool b) : m(b?42:x) { }
  int m;
};
constexpr int v = A(true).m;        // [:en] OK, constructor call initializes [`m] with the value [`42] \
                                    [:zh_CN] OK，构造函数的调用以 [`42] 初始化了 [`m]

constexpr int w = A(false).m;       // [:en] error: initializer for [`m] is [`x], which is non-constant \
                                    [:zh_CN] 错误：[`m] 的初始化式为 [`x]，并且不是常量

constexpr int f1(int k) {
  constexpr int x = k;              // [:en] error: [`x] is not initialized by a constant expression \
                                    [:zh_CN] 错误：[`x] 不是以常量表达式进行的初始化，
                                    // [:en@~] because lifetime of [`k] began outside the initializer of [`x] \
                                    [:zh_CN@~] 因为 [`k] 的生存期开始于 [`x] 的初始化式之外
  return x;
}
constexpr int f2(int k) {
  int x = k;                        // [:en] OK, not required to be a constant expression \
                                    [:zh_CN] OK，不需要其为常量表达式
                                    // [:en@~] because [`x] is not [`:key constexpr] \
                                    [:zh_CN@~] 因为 [`x] 不是 [`:key constexpr]
  return x;
}

constexpr int incr(int &n) {
  return ++n;
}
constexpr int g(int k) {
  constexpr int x = incr(k);        // [:en] error: [`incr(k)] is not a core constant expression \
                                    [:zh_CN] 错误：[`incr(k)] 不是核心常量表达式，
                                    // [:en@~] because lifetime of [`k] began outside the expression [`incr(k)] \
                                    [:zh_CN@~] 因为 [`k] 的生存期开始于表达式 [`incr(k)] 之外
  return x;
}
constexpr int h(int k) {
  int x = incr(k);                  // [:en] OK, [`incr(k)] is not required to be a core constant expression \
                                    [:zh_CN] OK，[`incr(k)] 不需要是核心常量表达式
  return x;
}
constexpr int y = h(1);             // [:en] OK, initializes [`y] with the value [`2] \
                                    [:zh_CN] OK，以值 [`2] 初始化 [`y]
                                    // [:en@~] [`h(1)] is a core constant expression because \
                                    [:zh_CN@~] [`h(1)] 是核心常量表达式，因为
                                    // [:en@~] the lifetime of [`k] begins inside [`h(1)] \
                                    [:zh_CN@~] [`k] 的生存期开始于 [`h(1)] 之内
[codeblock:end]
[end:example]

[para]
[:en]
For the purposes of determining whether an expression [$E] is a core constant
expression, the evaluation of the body of a member function of [`std::allocator<T>]
as defined in [#allocator.members], where [`T] is a literal type, is ignored.
[:zh_CN]
在确定某个表达式 [$E] 是否是核心常量表达式时，忽略对 [#allocator.members] 中
所定义的 [`std::allocator<T>]（其中 [`T] 为字面类型）的成员函数的函数体的求值。

[:en]
Similarly, the evaluation of the body of [`std::construct_at] or
[`std::ranges::construct_at] is considered to include only the initialization of
the [`T] object if the first argument (of type [`T*]) points to storage
allocated with [`std::allocator<T>] or to an object whose lifetime began within
the evaluation of [$E].
[:zh_CN]
类似地，[`std::construct_at] 或 [`std::ranges::construct_at] 的函数体的求值，
在其第一个实参（类型为 [`T*]）指向由 [`std::allocator<T>] 所分配的存储或某个
生存期开始于 [$E] 的求值期间的对象时，被当作仅包括该 [`T] 对象的初始化。

[para]
[:en]
For the purposes of determining whether [$E] is a core constant expression,
the evaluation of a call to a trivial copy/move constructor or copy/move
assignment operator of a union is considered to copy/move the active member of
the union, if any.
[:zh_CN]
在确定 [$E] 是否是核心常量表达式时，对联合体调用平凡的复制/移动构造函数或复制/
移动赋值运算符的求值被当做对该联合体的活跃成员进行复制/移动（如果有）。

[begin:note]
[:en] The copy/move of the active member is trivial.
[:zh_CN] 活跃成员的复制/移动是平凡操作。
[end:note]

[para]
[:en]
During the evaluation of an expression [$E] as a core constant expression,
all [~id-expression]s and uses of [`*[`:key this]] that refer to an object or
reference whose lifetime did not begin with the evaluation of [$E] are treated
as referring to a specific instance of that object or reference whose lifetime
and that of all subobjects (including all union members) includes the entire
constant evaluation.
[:zh_CN]
将表达式 [$E] 作为核心常量表达式的求值过程中，所有[~标识表达式]和对
[`*[`:key this]] 的使用，若其所代表的对象或引用的生存期并非开始于 [$E] 的求值，
则均被当做代表该对象或引用的一个特定实例，其生存期和其所有子对象（包括所有联合体
成员）的生存期均包含整个常量求值。

[:en]
For such an object that is not usable in constant expressions, the dynamic type
of the object is [+constexpr-unknown].
[:zh_CN]
不能在常量表达式中使用的这种对象，其动态类型是 [+constexpr 未知]的。

[:en]
For such a reference that is not usable in constant expressions, the reference
is treated as binding to an unspecified object of the referenced type whose
lifetime and that of all subobjects includes the entire constant evaluation and
whose dynamic type is constexpr-unknown.
[:zh_CN]
不能在常量表达式中使用的这种引用，被当作绑定到某个被引用类型的一个特定对象，其
生存期和所有子对象的生存期均包含整个常量求值，且其动态类型是 constexpr 未知的。

[begin:example]
[codeblock]
template <typename T, size_t N>
constexpr size_t array_size(T (&)[N]) {
  return N;
}

void use_array(int const (&gold_medal_mel)[2]) {
  constexpr auto gold = array_size(gold_medal_mel);     // OK
}

constexpr auto olympic_mile() {
  const int ledecky = 1500;
  return []{ return ledecky; };
}
static_assert(olympic_mile()() == 1500);                // OK

struct Swim {
  constexpr int phelps() { return 28; }
  virtual constexpr int lochte() { return 12; }
  int coughlin = 12;
};

constexpr int how_many(Swim& swam) {
  Swim* p = &swam;
  return (p + 1 - 1)->phelps();
}

void splash(Swim& swam) {
  static_assert(swam.phelps() == 28);           // OK
  static_assert((&swam)->phelps() == 28);       // OK

  Swim* pswam = &swam;
  static_assert(pswam->phelps() == 28);         // [:en] error: lvalue-to-rvalue conversion on a pointer \
                                                [:zh_CN] 错误：对不能用与常量表达式的指针
                                                // [:en@~] not usable in constant expressions \
                                                [:zh_CN] 进行左值向右值转换

  static_assert(how_many(swam) == 28);          // OK
  static_assert(Swim().lochte() == 12);         // OK

  static_assert(swam.lochte() == 12);           // [:en] error: invoking virtual function on reference \
                                                [:zh_CN] 错误：在具有 constexpr 未知动态类型的引用上
                                                // [:en@~] with constexpr-unknown dynamic type \
                                                [:zh_CN@~] 调用虚函数

  static_assert(swam.coughlin == 12);           // [:en] error: lvalue-to-rvalue conversion on an object \
                                                [:zh_CN] 错误：对不能用与常量表达式的对象
                                                // [:en@~] not usable in constant expressions \
                                                [:zh_CN] 进行左值向右值转换
}

extern Swim dc;
extern Swim& trident;

constexpr auto& sandeno   = typeid(dc);         // [:en] OK, can only be [`typeid(Swim)] \
                                                [:zh_CN] OK，只能是 [`typeid(Swim)]
constexpr auto& gallagher = typeid(trident);    // [:en] error: constexpr-unknown dynamic type \
                                                [:zh_CN] 错误：constexpr 未知的动态类型
[codeblock:end]
[end:example]

[para]
[:en]
An object [`a] is said to have [+:adj constant[!destruction]] if:
[:zh_CN]
以下情况下，称对象 [`a] 具有[+:adj 常量[!销毁]]：

[list]
[item]
[:en] it is not of class type nor (possibly multidimensional) array thereof, or
[:zh_CN] 它不为类类型或其（可能多维的）数组，或者
[item]
[:en] it is of class type or (possibly multidimensional) array thereof, that
class type has a constexpr destructor, and for a hypothetical expression [$E]
whose only effect is to destroy [`a], [$E] would be a core constant expression
if the lifetime of [`a] and its non-mutable subobjects (but not its mutable
subobjects) were considered to start within [$E].
[:zh_CN] 它为类类型或其（可能多维的）数组，此类类型具有 constexpr 析构函数，并且
对于仅有效果为销毁 [`a] 的虚构的表达式 [$E]，如果 [`a] 及其非 mutable 子对象
（但不包括其 mutable 子对象）的生存期被当做开始于 [$E] 之内，则 [$E] 可为核心
常量表达式。
[list:end]

[para]
[:en]
An [+:adj integral constant[!expression]] is an expression of integral or
unscoped enumeration type, implicitly converted to a prvalue, where the
converted expression is a core constant expression.
[:zh_CN]
[+:adj 整型常量[!表达式]]是整型或无作用域枚举类型的表达式，被隐式转换为纯右值，
其中的转换后的表达式是核心常量表达式。

[begin:note]
[:en]
Such expressions can be used as bit-field lengths ([#class.bit]), as enumerator
initializers if the underlying type is not fixed ([#dcl.enum]), and as
alignments ([#dcl.align]).
[:zh_CN]
此种表达式可用作位字段的长度（[#class.bit]），底层类型并未固定的枚举符的初始化式
（[#dcl.enum]），以及对齐（[#dcl.align]）。
[end:note]

[para]
[:en]
If an expression of literal class type is used in a context where an integral
constant expression is required, then that expression is contextually implicitly
converted ([#conv]) to an integral or unscoped enumeration type and the selected
conversion function shall be [`:key constexpr].
[:zh_CN]
如果字面类类型的表达式用在需要整型常量表达式的语境中，则该表达式被按语境隐式转换
（[#conv]）为某种整型或无作用域枚举类型，且所选择的转换函数应当为
[`:key constexpr]。

[begin:example]
[codeblock]
struct A {
  constexpr A(int i) : val(i) { }
  constexpr operator int() const { return val; }
  constexpr operator long() const { return 42; }
private:
  int val;
};
constexpr A a = alignof(int);
alignas(a) int n;               // [:en] error: ambiguous conversion \
                                [:zh_CN] 错误：有歧义的转换
struct B { int n : a; };        // [:en] error: ambiguous conversion \
                                [:zh_CN] 错误：有歧义的转换
[codeblock:end]
[end:example]

[para]
[:en]
A [+:adj converted constant[!expression]] of type [`T] is an expression,
implicitly converted to type [`T], where the converted expression is a constant
expression and the implicit conversion sequence contains only
[:zh_CN]
类型 [`T] 的[+:adj 经转换的常量[!表达式]]是被隐式转换为类型 [`T] 的表达式，其中
的转换后的表达式是常量表达式，并且隐式转换序列中只包含

[list]
[item]
[:en@~] user-defined conversions,
[:zh_CN@~] 用户定义转换，
[item]
[:en@~] lvalue-to-rvalue conversions ([#conv.lval]),
[:zh_CN@~] 左值向右值转换（[#conv.lval]]），
[item]
[:en@~] array-to-pointer conversions ([#conv.array]),
[:zh_CN@~] 数组向指针转换（[#conv.array]），
[item]
[:en@~] function-to-pointer conversions ([#conv.func]),
[:zh_CN@~] 函数向指针转换（[#conv.func]），
[item]
[:en@~] qualification conversions ([#conv.qual]),
[:zh_CN@~] 限定转换（[#conv.qual]），
[item]
[:en@~] integral promotions ([#conv.prom]),
[:zh_CN@~] 整型提升（[#conv.prom]），
[item]
[:en@~] integral conversions ([#conv.integral]) other than narrowing conversions
([#dcl.init.list]),
[:zh_CN@~] 除了窄化转换（[#dcl.init.list]）之外的整型转换（[#conv.integral]），
[item]
[:en@~] floating-point promotions ([#conv.fpprom]),
[:zh_CN@~] 浮点提升（[#conv.fpprom]），
[item]
[:en@~] floating-point conversions ([#conv.double]) where the source value can
be represented exactly in the destination type,
[:zh_CN@~] 源值可以被目标类型精确表示的浮点转换（[#conv.double]），
[item]
[:en@~] null pointer conversions ([#conv.ptr]) from [`std::nullptr_t], and
[:zh_CN@~] 从 [`std::nullptr_t] 进行的空指针转换（[#conv.ptr]），
[item]
[:en@~] null member pointer conversions ([#conv.mem]) from [`std::nullptr_t],
[:zh_CN@~] 从 [`std::nullptr_t] 进行的空成员指针转换（[#conv.mem]），以及
[item]
[:en@~] function pointer conversions ([conv.fctptr]),
[:zh_CN@~] 函数指针转换（[#conv.fctptr]），
[list:end]

[:en@~]
and where the reference binding (if any) binds directly.
[:zh_CN@~]
并且其中的引用绑定（如果有）是直接绑定。

[begin:note]
[:en]
Such expressions can be used in [`:key new] expressions ([#expr.new]), as case
expressions ([#stmt.switch]), as enumerator initializers if the underlying type
is fixed ([#dcl.enum]), as array bounds ([#dcl.array]), and as non-type template
arguments ([#temp.arg]).
[:zh_CN]
此种表达式可用在 [`:key new] 表达式中（[#expr.new]），用作 case 表达式
（[#stmt.switch]），用作底层类型已固定的枚举符的初始化式（[#dcl.enum]），用作
数组边界（[#dcl.array]），以及用作整型或枚举的非类型模板实参（[#temp.arg]）。
[end:note]

[:en]
[%contextually converted constant expression of type [`bool]
[%conversion[!contextual]]]
[%conversion[!contextual to constant expression of type [`bool]]]
A [+:% contextually converted constant expression of type [`bool]] is an
expression, contextually converted to [`:key bool] ([#conv]), where the
converted expression is a constant expression and the conversion sequence
contains only the conversions above.
[:zh_CN]
[%按语境转换为类型 [`bool] 的常量表达式 [%转换[!按语境～]]]
[%转换[!按语境～为类型 [`bool] 的常量表达式]]
[+:% 按语境转换为类型 [`bool] 的常量表达式]，是按语境转换为 [`:key bool]（[#conv]）
的表达式，所转换的表达式是常量表达式，且其转换序列中仅包含上述转换。

[para]
[:en]
A [+:adj constant[!expression]] is either a glvalue core constant expression
that refers to an entity that is a permitted result of a constant expression
(as defined below), or a prvalue core constant expression whose value satisfies
the following constraints:
[:zh_CN]
[+:adj 常量[!表达式]]是泛左值核心常量表达式，其值所指代的实体是常量表达式所允许
的某种结果（如下文定义），或者是纯右值核心常量表达式，其值满足如下约束条件：

[list]
[item]
[:en] if the value is an object of class type, each non-static data member of
reference type refers to an entity that is a permitted result of a constant
expression,
[:zh_CN] 若其值为类类型的对象，则它的每个引用类型的数据成员所指代的实体都是
常量表达式所允许的结果，

[item]
[:en] if the value is an object of scalar type, it does not have an
indeterminate or erroneous value ([#basic.indet]),
[:zh_CN] 若其值为标量类型的对象，则它不具有不确定或错误值（[#basic.indet]），

[item]
[:en] if the value is of pointer type, it contains the address of an object with
static storage duration, the address past the end of such an object
([#expr.add]), the address of a non-immediate function, or a null pointer value,
[:zh_CN] 若其值为指针类型，则它包含某个具有静态存储期的对象的地址，越过这种对象
末尾的地址（[#expr.add]），某个非直接函数的地址，或空指针值，

[item]
[:en] if the value is of pointer-to-member-function type, it does not designate
an immediate function, and
[:zh_CN] 若其值为成员函数指针类型，则它并不代表某个直接函数，并且

[item]
[:en] if the value is an object of class or array type, each subobject satisfies
these constraints for the value.
[:zh_CN] 若其值为类或数组类型的对象，其每个子对象都应当满足这些对于值的约束条件。
[list:end]

[:en]
An entity is a [+permitted result of a constant expression[%constant expression
[!permitted result of]]] if it is an object with static storage duration that
either is not a temporary object or is a temporary object whose value satisfies
the above constraints, or if it is a non-immediate function.
[:zh_CN]
若某个实体是具有静态存储期的对象，并且要么不是临时对象，要么是临时对象但其值满足
上述约束条件，或者它是个非直接函数，则该实体是[+常量表达式允许的结果
[%常量表达式[!～允许的结果]]]。

[begin:note]
[:en]
A glvalue core constant expression that either refers to or points to an
unspecified object is not a constant expression.
[:zh_CN]
指代或指向未指明对象的泛左值核心常量表达式不是常量表达式。
[end:note]

[begin:example]
[codeblock]
consteval int f() { return 42; }
consteval auto g() { return f; }
consteval int h(int (*p)() = g()) { return p(); }
constexpr int r = h();                          // OK
constexpr auto e = g();                         // [:en] error: a pointer to an immediate function is \
                                                [:zh_CN] 错误：指向直接函数的指针不能
                                                // [:en@~] not a permitted result of a constant expression \
                                                [:zh_CN@~] 作为常量表达式的结果

struct S {
  int x;
  constexpr S() {}
};
int i() {
  constexpr S s;                                // [:en] error: [`s.x] has erroneous value [:zh_CN] 错误：[`s.x] 具有错误值
}
[codeblock:end]
[end:example]

[para:recommended]
[:en]
Implementations should provide consistent results of floating-point evaluations,
irrespective of whether the evaluation is performed during translation or during
program execution.
[:zh_CN]
实现最好为浮点求值提供一致的结果，与求值是否实际发生于翻译过程中还是程序执行过程
中无关。

[begin:note]
[:en]
Since this document imposes no restrictions on the accuracy of floating-point
operations, it is unspecified whether the evaluation of a floating-point
expression during translation yields the same result as the evaluation of the
same expression (or the same operations on the same values) during program
execution.
[:zh_CN]
由于本文档并不对浮点运算的精度施加任何限制，所以在翻译过程中对浮点表达式进行的
求值所产生的结果，与同一个表达式（或者对相同的值进行相同的运算）在程序执行过程中
所产生的结果是否相同，是未指明的。

[begin:example]
[codeblock]
bool f() {
    char array[1 + int(1 + 0.2 - 0.1 - 0.1)];   // [:en] Must be evaluated during translation \
                                                [:zh_CN] 必须在翻译过程中求值
    int size = 1 + int(1 + 0.2 - 0.1 - 0.1);    // [:en] May be evaluated at runtime \
                                                [:zh_CN] 可以在运行时求值
    return sizeof(array) == size;
}
[codeblock:end]

[:en]
It is unspecified whether the value of [`f()] will be [`true] or [`false].
[:zh_CN]
[`f()] 的值是 [`true] 还是 [`false] 是未指明的。
[end:example]
[end:note]

[para]
[:en]
An expression or conversion is in an [+immediate function context] if it is
potentially evaluated and either:
[:zh_CN]
一个表达式或转换，如果它是潜在求值的且满足以下情况，则它处于[+直接函数语境]之中：
[list]
[item]
[:en@~] its innermost enclosing non-block scope is a function parameter scope of
an immediate function,
[:zh_CN@~] 其最内层外围非块作用域是某个直接函数的函数形参作用域，
[item]
[:en@~] it is a subexpression of a manifestly constant-evaluated expression or
conversion, or
[:zh_CN@~] 它是显然常量求值的表达式或转换的子表达式，或者
[item]
[:en@~] its enclosing statement is enclosed ([#stmt.pre]) by the
[~compound-statement] of a consteval if statement ([#stmt.if]).
[:zh_CN@~] 其外围语句被 consteval if 语句（[#stmt.if]）的[~复合语句]所包围
（[#stmt.pre]）。
[list:end]

[:en]
An invocation is an [+immediate invocation] if it is a potentially-evaluated
explicit or implicit invocation of an immediate function and is not in an
immediate function context.
[:zh_CN]
一次调用，如果它是潜在求值的对某个直接函数的显式或隐式调用，且并非处于直接函数
语境之中，则它是一次[+直接调用]。

[:en]
An aggregate initialization is an immediate invocation
if it evaluates a default member initializer
that has a subexpression that is an immediate-escalating expression.
[:zh_CN]
如果聚合初始化求值的某个默认成员初始化式带有子表达式是直接性扩散表达式，则它是
一次直接调用。

[para]
[:en]
[%@defn expression[!immediate-escalating]]
[%@defn conversion[!immediate-escalating]]
[%@defn immediate-escalating[!expression][%expression[!immediate-escalating]]]
[%@defn immediate-escalating[!conversion][%conversion[!immediate-escalating]]]
An expression or conversion is [+immediate-escalating] if it is not initially in
an immediate function context and it is either
[:zh_CN]
[%@defn 表达式[!直接性扩散]]
[%@defn 转换[!直接性扩散]]
[%@defn 直接性扩散[!表达式][%表达式[!直接性扩散]]]
[%@defn 直接性扩散[!转换][%转换[!直接性扩散]]]
如果表达式或转换并非起初处于直接函数语境中，且其为以下之一，则它是[+直接性扩散]
的：
[list]
[item]
[:en] a potentially-evaluated [~id-expression] that denotes an immediate
function that is not a subexpression of an immediate invocation, or
[:zh_CN] 代表某个直接函数的潜在求值的[~标识表达式]，它不是某个直接调用的子表达式，
或者
[item]
[:en] an immediate invocation that is not a constant expression and is not a
subexpression of an immediate invocation.
[:zh_CN] 并非常量表达式且并非直接调用的子表达式的直接调用。
[list:end]

[para]
[:en] [%@defn immediate-escalating[!function][%function[!immediate-escalating]]]
An [+immediate-escalating[%function[!immediate-escalating]]] function is
[:zh_CN] [%@defn 直接性扩散[!函数][%函数[!直接性扩散]]]
[+直接性扩散[%函数[!直接性扩散]]]函数是
[list]
[item]
[:en] the call operator of a lambda that is not declared
with the [`:key consteval] specifier,
[:zh_CN] 并非以 [`:key consteval] 说明符声明的 lambda 表达式的的与运算符，
[item]
[:en] a defaulted special member function that is not declared with the
[`:key consteval] specifier, or
[:zh_CN] 并非以 [`:key consteval] 说明符声明的预置的特殊成员函数，或者
[item]
[:en] a function that results from the instantiation of a templated entity
defined with the [`:key constexpr] specifier.
[:zh_CN] 从对以 [`:key constexpr] 说明符定义的模板化实体进行实例化所得到的函数。
[list:end]

[:en]
An immediate-escalating expression shall appear only in an immediate-escalating
function.
[:zh_CN]
直接性扩散表达式只能出现于直接性扩散函数之中。

[para]
[:en] An [+:adj immediate[!function]] is a function or constructor that is
[:zh_CN] [+:adj 直接[!函数]]是以下函数或构造函数：
[list]
[item]
[:en] declared with the [`:key consteval] specifier, or
[:zh_CN] 以 [`:key consteval] 声明，或者
[item]
[:en] an immediate-escalating function [`[^F]] whose function body contains an
immediate-escalating expression [`[^E]] such that [`[^E]][=']s innermost
enclosing non-block scope is [`[^F]][=']s function parameter scope.
[:zh_CN] 直接性扩散函数 [`[^F]]，其函数体包含某个直接性扩散表达式 [`[^E]]，
使得 [`[^E]] 的最内层外围非块作用域是 [`[^F]] 的函数形参作用域。

[begin:note@tail]
[:en] Default member initializers used to initialize a base or member subobject
([#class.base.init]) are considered to be part of the function body
([#dcl.fct.def.general]).
[:zh_CN] 用于初始化基类和成员子对象的默认成员初始化式（[#class.base.init]）被
当做函数体的一部分（[#dcl.fct.def.general]）。
[end:note]
[list:end]

[begin:example]
[codeblock]
consteval int id(int i) { return i; }
constexpr char id(char c) { return c; }

template<class T>
constexpr int f(T t) {
  return t + id(t);
}

auto a = &f<char>;              // [:en] OK, [`f<char>] is not an immediate function \
                                [:zh_CN] OK，[`f<char>] 不是直接函数
auto b = &f<int>;               // [:en] error: [`f<int>] is an immediate function \
                                [:zh_CN] 初吻：[`f<int>] 是直接函数

static_assert(f(3) == 6);       // OK

template<class T>
constexpr int g(T t) {          // [:en] [`g<int>] is not an immediate function \
                                [:zh_CN] [`g<int>] 不是直接函数
  return t + id(42);            // [:en@~] because [`id(42)] is already a constant \
                                [:zh_CN@~] 因为 [`id(42)] 已经是常量
}

template<class T, class F>
constexpr bool is_not(T t, F f) {
  return not f(t);
}

consteval bool is_even(int i) { return i % 2 == 0; }

static_assert(is_not(5, is_even));      // OK

int x = 0;

template<class T>
constexpr T h(T t = id(x)) {    // [:en] [`h<int>] is not an immediate function \
                                [:zh_CN] [`h<int>] 不是直接函数
                                // [:en] [`id(x)] is not evaluated when parsing the default argument ([#dcl.fct.default], [#temp.inst]) \
                                [:zh_CN] 解析默认实参时并未对 [`id(x)] 求值（[#dcl.fct.default]，[#temp.inst]）
    return t;
}

template<class T>
constexpr T hh() {              // [:en] [`hh<int>] is an immediate function because of the invocation \
                                [:zh_CN] [`hh<int>] 是直接函数，这是源于在 [`h<int>]
  return h<T>();                // [:en@~] of the immediate function [`id] in the default argument of [`h<int>] \
                                [:zh_CN@~] 的默认实参中对直接函数 [`id] 进行的调用
}

int i = hh<int>();              // [:en] error: [`hh<int>()] is an immediate-escalating expression \
                                [:zh_CN] 错误：[`hh<int>()] 是直接性扩散函数 \
                                // [:en@~] outside of an immediate-escalating function \
                                [:zh_CN@~] 外面的直接性扩散表达式

struct A {
  int x;
  int y = id(x);
};

template<class T>
constexpr int k(int) {          // [:en] [`k<int>] is not an immediate function because [`A(42)] is a \
                                [:zh_CN] [`k<int>] 不是直接函数，因为 [`A(42)] 是
  return A(42).y;               // [:en@~] constant expression and thus not immediate-escalating \
                                [:zh_CN@~] 常量表达式因而不是直接性扩散的
}
[codeblock:end]
[end:example]

[para]
[:en]
An expression or conversion is [+manifestly constant-evaluated] if it is:
[:zh_CN]
符合以下情况的表达式或转换是[+显然常量求值的]：

[list]
[item]
[:en@~] a [~constant-expression], or
[:zh_CN@~] [~常量表达式]，或
[item]
[:en@~] the condition of a constexpr if statement ([#stmt.if]), or
[:zh_CN@~] [`constexpr if] 语句的条件（[#stmt.if]），或
[item]
[:en@~] an immediate invocation, or
[:zh_CN@~] 直接调用，或
[item]
[:en@~] the result of substitution into an atomic constraint expression
to determine whether it is satisfied ([#temp.constr.atomic]), or
[:zh_CN@~] 向原子约束表达式中进行代换以确定其是否被满足（[#temp.constr.atomic]）
的结果，或
[item]
[:en@~] the initializer of a variable that is usable in constant expressions or
has constant initialization ([#basic.start.static]).[#:fn]
[:zh_CN@~] 可被用在常量表达式中，或具有常量初始化的变量的初始化式
（[#basic.start.static]）[#:fn]。

[note:foot]
[:en]
Testing this condition can involve a trial evaluation of its initializer as
described above.
[:zh_CN]
这个条件的测试可以涉及对其初始化式进行如上所述的平凡求值。
[note:end]

[begin:example]
[codeblock]
template<bool> struct X {};
X<std::is_constant_evaluated()> x;                      // [:en] type [`X<true>] \
                                                        [:zh_CN] 类型 [`X<true>]
int y;
const int a = std::is_constant_evaluated() ? y : 1;     // [:en] dynamic initialization to 1 \
                                                        [:zh_CN] 动态初始化为 1
double z[a];                                            // [:en] error: [`a] is not usable \
                                                        [:zh_CN] 错误：[`a] 不能被用在
                                                        // [:en@~] in constant expressions \
                                                        [:zh_CN@~] 常量表达式值中
const int b = std::is_constant_evaluated() ? 2 : y;     // [:en] static initialization to 2 \
                                                        [:zh_CN] 静态初始化为 2
int c = y + (std::is_constant_evaluated() ? 2 : y);     // [:en] dynamic initialization to [`y+y] \
                                                        [:zh_CN] 动态初始化为 [`y+y]

constexpr int f() {
  const int n = std::is_constant_evaluated() ? 13 : 17; // [:en] [`n] is 13 \
                                                        [:zh_CN] [`n] 为 13
  int m = std::is_constant_evaluated() ? 13 : 17;       // [:en] [`m] can be 13 or 17 (see below) \
                                                        [:zh_CN] [`m] 可为 13 或 17（见下文）
  char arr[n] = {}; // char[13]
  return m + sizeof(arr);
}
int p = f();                                            // [:en] [`m] is 13; initialized to 26 \
                                                        [:zh_CN] [`m] 为 13；初始化为 26
int q = p + f();                                        // [:en] [`m] is 17 for this call; initialized to 56 \
                                                        [:zh_CN] [`m] 在本次调用中为 17；初始化为 56
[codeblock:end]
[end:example]
[list:end]

[begin:note]
[:en] Except for a [~static_assert-message], a manifestly constant-evaluated
expression is evaluated even in an unevaluated operand
([#term.unevaluated.operand]).
[:zh_CN] 除了 [~static_assert-消息]，显然常量求值表达式即便在免求值操作数中仍被
求值（[#term.unevaluated.operand]）。
[end:note]

[para]
[:en]
[%expression[!potentially constant evaluated]]
An expression or conversion is [+potentially constant evaluated] if it is:
[:zh_CN]
[%表达式[!潜在常量求值]]
如下情况下表达式或转换被[+潜在常量求值]：

[list]
[item]
[:en]
a manifestly constant-evaluated expression,
[:zh_CN]
显然常量求值表达式，

[item]
[:en]
a potentially-evaluated expression ([#basic.def.odr]),
[:zh_CN]
潜在求值表达式（[#basic.def.odr]），

[item]
[:en]
an immediate subexpression of a [~braced-init-list],[#:fn]
[:zh_CN]
[~花括号初始化列表]的直接子表达式[#:fn]，

[note:foot]
[:en]
In some cases, constant evaluation is needed to determine whether a narrowing
conversion is performed ([#dcl.init.list]).
[:zh_CN]
某些情况下，为确定是否会实施窄化转换需要进行常量求值（[#dcl.init.list]）。
[note:end]

[item]
[:en]
an expression of the form [`&] [~cast-expression] that occurs within a templated
entity,[#:fn] or
[:zh_CN]
在模板化的实体中出现的形式为“[`&] [~转型表达式]”的表达式[#:fn]，或者

[note:foot]
[:en]
In some cases, constant evaluation is needed to determine whether such an
expression is value-dependent ([#temp.dep.constexpr]).
[:zh_CN]
某些情况下，为确定这种表达式是否是值待决的需要进行常量求值（[#temp.dep.constexpr]）。
[note:end]

[item]
[:en]
a potentially-evaluated subexpression ([#intro.execution]) of one of the above.
[:zh_CN]
以上各项之一的潜在求值子表达式（[#intro.execution]）。
[list:end]

[:en]
[%function[!needed for constant evaluation]]
[%variable[!needed for constant evaluation]]
A function or variable is [+needed for constant evaluation] if it is:
[:zh_CN]
[%函数[!常量求值所需的]]
[%变量[!常量求值所需的]]
以下情况下函数或变量是[+常量求值所需的]：

[list]
[item]
[:en]
a constexpr function that is named by an expression ([#basic.def.odr]) that is
potentially constant evaluated, or
[:zh_CN]
被潜在常量求值的表达式所指名（[#basic.def.odr]）的 constexpr 函数，或者

[item]
[:en]
a potentially-constant variable named by a potentially constant evaluated
expression.
[:zh_CN]
被潜在常量求值表达式所指名的潜在常量变量。
[list:end]
