[section#expr.const
    [:en] Constant expressions
    [:zh_CN] 常量表达式

[:en]
[%expression[!constant]]
[:zh_CN]
[%表达式[!常量～]]
]

[para]
[:en]
Certain contexts require expressions that satisfy additional requirements as
detailed in this subclause; other contexts have different semantics depending
on whether or not an expression satisfies these requirements.
[:zh_CN]
一些特定的语境中，需要满足本子条款中所详述的额外规定的表达式；其他一些语境中则
根据表达式能否满足这些规定而具有不同的语义。

[:en]
Expressions that satisfy these requirements, assuming that copy elision
([#class.copy.elision]) is performed, are called [%@defn expression[!constant]]
[+constant expressions [%constant expression]].
[:zh_CN]
满足这些规定的表达式，假定其实施了复制消除（[#class.copy.elision]），被称作
[%@defn 表达式[!常量～]][+常量表达式]。

[begin:note]
[:en]
Constant expressions can be evaluated during translation.
[:zh_CN]
常量表达式可以在翻译期间求值。
[end:note]

[syntax]
[rule constant-expression [:zh_CN] 常量表达式 ]
    [| conditional-expression ]
[rule:end]
[syntax:end]

[para]
[:en]
A variable or temporary object [`o] is [+constant-initialized] if
[:zh_CN]
满足以下条件时，变量或临时对象 [`o] 被[+常量初始化]：

[list]
[item]
[:en] either it has an initializer or its default-initialization results in some
initialization being performed, and
[:zh_CN] 要么它带有一个初始化式，要么其默认初始化导致进行某种初始化，并且

[item]
[:en] the full-expression of its initialization is a constant expression when
interpreted as a [~constant-expression], except that if [`o] is an object, that
full-expression may also invoke constexpr constructors for [`o] and its
subobjects even if those objects are of non-literal class types.
[:zh_CN] 其初始化的全表达式当作为[~常量表达式]解释时是常量表达式，不过当 [`o] 是
对象时，该全表达式还可以为 [`o] 及其子对象调用 constexpr 构造函数，即便这些对象
具有非字面类类型也是如此。

[begin:note]
[:en]
Such a class can have a non-trivial destructor.
[:zh_CN]
这样的类可以带有非平凡的析构函数。

[:en]
Within this evaluation, [`std::is_constant_evaluated()] ([#meta.const.eval])
returns [`:key true].
[:zh_CN]
在这种求值之中时，[`std::is_constant_evaluated()]（[#meta.const.eval]）将返回
[`:key true]。
[end:note]
[list:end]

[para]
[:en]
A variable is [+potentially-constant] if it is constexpr or it has reference or
const-qualified integral or enumeration type.
[:zh_CN]
如果变量是 constexpr 变量，或者它具有引用或 [`const] 限定的整型或枚举类型，则它
是[+潜在常量]。

[para]
[:en]
A constant-initialized potentially-constant variable [$V] is [+usable in
constant expressions] at a point [$P] if [$V][=']s initializating declaration
[$D] is reachable from [$P] and
[:zh_CN]
被常量初始化的潜在常量变量 [$V]，如果 [$V] 的初始化声明式 [$D] 从某点 [$P] 处
可达，且符合以下情况，则它在 [$P] 点[+可被用在常量表达式之中]。

[list]
[item]
[:en@~] it is constexpr,
[:zh_CN@~] 它为 constexpr，
[item]
[:en@~] it is not initialized to a TU-local value, or
[:zh_CN@~] 它并非以翻译单元局部的值所初始化，或
[item]
[:en@~] [$P] is in the same translation unit as [$D].
[:zh_CN@~] [$P] 与 [$D] 处于相同翻译单元中。
[list:end]

[:en]
An object or reference is [+usable in constant expressions] if it is
[:zh_CN]
以下情况下，对象或引用[+可被用在常量表达式之中]：

[list]
[item]
[:en@~] a variable that is usable in constant expressions, or
[:zh_CN@~] 可被用在常量表达式之中的变量，或
[item]
[:en@~] a template parameter object ([#temp.param]), or
[:zh_CN@~] 临时形参对象（[#temp.param]），或
[item]
[:en@~] a string literal object ([#lex.string]), or
[:zh_CN@~] 字符串字面量对象（[#lex.string]），或
[item]
[:en@~] a temporary object of non-volatile const-qualified literal type whose
lifetime is extended ([#class.temporary]) to that of a variable that is usable
in constant expressions, or
[:zh_CN@~] 非 volatile 且 const 限定的字面量类型的临时对象，并且其生存期已扩展
（[#class.temporary]）到某个可在常量表达式中使用的变量的生存期，或
[item]
[:en@~] a non-mutable subobject or reference member of any of the above.
[:zh_CN@~] 以上任一的非 mutable 子对象或引用成员。
[list:end]

[para]
[:en]
An expression [$E] is a [+:adj core constant expression[%expression
[!core constant]]] unless the evaluation of [$E], following the rules of the
abstract machine ([#intro.execution]), would evaluate one of the following:
[:zh_CN]
表达式 [$E] 是[+:adj 核心常量表达式[%表达式[!核心常量～]]]，但根据抽象机器的规则
（[#intro.execution]）对 [$E] 进行求值中，不能包含下列求值：

[list]
[item]
[:en]
[`:key this] ([#expr.prim.this]), except in a constexpr function
([#dcl.constexpr]) that is being evaluated as part of [$E];
[:zh_CN]
[`:key this]（[#expr.prim.this]），但作为 [$E] 的求值的一部分而求值的 constexpr
函数（[#dcl.constexpr]）中的不算作其中；

[item]
[:en]
an invocation of a non-constexpr function;[#:fn#]
[:zh_CN]
进行了非 constexpr 函数的调用；[#:fn#]

[note:foot]
[:en]
Overload resolution ([#over.match]) is applied as usual
[:zh_CN]
照常进行重载决议（[#over.match]）
[note:end]

[item]
[:en]
an invocation of an undefined constexpr function;
[:zh_CN]
进行了未定义的 constexpr 函数的调用；

[item]
[:en]
an invocation of an instantiated constexpr function that fails to satisfy the
requirements for a constexpr function;
[:zh_CN]
调用无法满足对 constexpr 函数的要求的 constexpr 函数；

[item]
[:en]
an invocation of a virtual function ([#class.virtual]) for an object unless
[:zh_CN]
为某个对象调用虚函数（[#class.virtual]），除非

[list]
[item]
[:en@~] the object is usable in constant expressions or
[:zh_CN@~] 该对象可被用在常量表达式中，或
[item]
[:en@~] its lifetime began within the evaluation of [$E];
[:zh_CN@~] 其生存期开始于 [$E] 的求值之中；
[list:end]

[item]
[:en]
an expression that would exceed the implementation-defined limits (see
[#implimits]);
[:zh_CN]
可能超出由实现定义的限制额度的表达式（参见 [#implimits]）；

[item]
[:en]
an operation that would have undefined behavior as specified in [#intro] through
[#cpp];[#:fn#]
[:zh_CN]
可能具有在本文档从 [#intro] 到 [#cpp] 中所述的未定义行为的操作；[#:fn#]

[note:foot]
[:en]
This includes, for example, signed integer overflow ([#expr.prop]), certain pointer
arithmetic ([#expr.add]), division by zero ([#expr.mul]), or certain shift
operations ([#expr.shift])
[:zh_CN]
这包括，（例如）有符号整数的溢出（[#expr.prop]），某些指针算术（[#expr.add]），
被零除（[#expr.mul]），或者某些移位操作（[#expr.shift]）
[note:end]

[item]
[:en]
an lvalue-to-rvalue conversion unless it is applied to
[:zh_CN]
左值向右值转换，但排除实施于下列情况的左值

[list]
[item]
[:en]
a non-volatile glvalue that refers to an object that is usable in constant
expressions, or
[:zh_CN]
指代某个可被用在常量表达式中的对象的非-volatile 泛左值，或者

[item]
[:en]
a non-volatile glvalue of literal type that refers to a non-volatile object
whose lifetime began within the evaluation of [$E];
[:zh_CN]
字面类型的非 volatile 泛左值，指代在 [$E] 的求值中开始其生存期的非 volatile 对象；
[list:end]

[item]
[:en]
an lvalue-to-rvalue conversion ([#conv.lval]) that is applied to a glvalue that
refers to a non-active member of a union or a subobject thereof;
[:zh_CN]
对指代某个联合体的非活跃成员或其子对象的泛左值，所实施的左值向右值转换
（[#conv.lval]）；

[item]
[:en]
an lvalue-to-rvalue conversion that is applied to an object with an
indeterminate value ([#basic.indet]);
[:zh_CN]
对具有不确定值的对象（[#basic.indet]）实施左值向右值转换；

[item]
[:en]
an invocation of an implicitly-defined copy/move constructor or copy/move
assignment operator for a union whose active member (if any) is mutable, unless
the lifetime of the union object began within the evaluation of [$E];
[:zh_CN]
对其活跃成员（如果有）为 mutable 成员的联合体调用隐式定义的复制/移动构造函数或
复制/移动赋值运算符，除非该联合体对象的生存期开始于 [$E] 的求值之中；

[item]
[:en]
an [~id-expression] that refers to a variable or data member of reference type
unless the reference has a preceding initialization and either
[:zh_CN]
代表引用类型的变量或数据成员的[~标识表达式]，除非这个引用此前进行了初始化，并且

[list]
[item]
[:en@~]
it is usable in constant expressions or
[:zh_CN@~]
可被用在常量表达式之中，或者

[item]
[:en@~]
its lifetime began within the evaluation of [$E];
[:zh_CN@~]
其生存期开始于 [$E] 的执行中；
[list:end]

[item]
[:en]
in a [~lambda-expression], a reference to [`:key this] or to a variable with
automatic storage duration defined outside that [~lambda-expression], where the
reference would be an odr-use ([#basic.def.odr], [#expr.prim.lambda]);
[:zh_CN]
在 [~lambda-表达式]中，涉指了 [`:key this] 或者在该 [~lambda-表达式]之外定义的
具有动态存储期的变量，而该涉指可能是一次 ODR 式使用（[#basic.def.odr]，
[#expr.prim.lambda]）；

[begin:example]
[codeblock]
void g() {
  const int n = 0;
  [=] {
    constexpr int i = n;        // [:en] OK, [`n] is not odr-used here \
                                   [:zh_CN] OK，这里 [`n] 并未被 ODR 式使用
    constexpr int j = *&n;      // [:en] error: [`&n] would be an odr-use of [`n] \
                                   [:zh_CN] 错误：[`&n] 可能是对 [`n] 的 ODR 式使用
  };
}
[codeblock:end]
[end:example]

[begin:note]
[:en]
If the odr-use occurs in an invocation of a function call operator of a closure
type, it no longer refers to [`:key this] or to an enclosing automatic variable
due to the transformation ([#expr.prim.lambda.capture]) of the [~id-expression]
into an access of the corresponding data member.
[:zh_CN]
如果这次 ODR 式使用发生于某个闭包类型的函数调用运算符的执行中，则它不再指代
[`:key this] 或者指代某个外围自动变量了，这是由于[~标识表达式]已被变换为其对应的
数据成员的访问（[#expr.prim.lambda.capture]）。

[begin:example]
[codeblock]
auto monad = [](auto v) { return [=] { return v; }; };
auto bind = [](auto m) {
  return [=](auto fvm) { return fvm(m()); };
};

// [:en] OK to capture objects with automatic storage duration created during constant expression evaluation. \
   [:zh_CN] 俘获在常量表达式的求值过程中创建的具有自动存储期的对象是没问题的。
static_assert(bind(monad(2))(monad)() == monad(2)());
[codeblock:end]
[end:example]
[end:note]

[item]
[:en]
a conversion from type [=cv] [`[`:key void]*] to a pointer-to-object type;
[:zh_CN]
从类型 [=cv] [`[`:key void]*] 向对象指针类型的转换；

[item]
[:en]
a [`:key reinterpret_cast] ([#expr.reinterpret.cast]);
[:zh_CN]
[`:key reinterpret_cast]（[#expr.reinterpret.cast]）；

[item]
[:en]
a modification of an object ([#expr.ass], [#expr.post.incr], [#expr.pre.incr])
unless it is applied to a non-volatile lvalue of literal type that refers to a
non-volatile object whose lifetime began within the evaluation of [$E];
[:zh_CN]
对对象的改动（[#expr.ass]，[#expr.post.incr]，[#expr.pre.incr]），除非实施于非
volatile 的字面类型的左值，并且它指代某个生存期开始于 [$E] 的求值中的非 volatile
对象；

[item]
[:en]
a [~new-expression] ([#expr.new]), unless the selected allocation function is
a replaceable global allocation function ([#new.delete.single],
[#new.delete.array]) and the allocated storage is deallocated within the
evaluation of [$E];
[:zh_CN]
[~new-表达式]（[#expr.new]），除非所选中的分配函数为可替换的全局分配函数
（[#new.delete.single]，[#new.delete.array]），并且所分配的存储在 [$E] 的求值
之内被回收；

[item]
[:en]
a [~delete-expression] ([#expr.delete]), unless it deallocates a region of
storage allocated within the evaluation of [$E];
[:zh_CN]
[~delete-表达式]（[#expr.delete]），除非其回收在 [$E] 的求值之中所分配的存储区域；

[item]
[:en]
a call to an instance of [`std::allocator<T>::allocate] ([#allocator.members]),
unless the allocated storage is deallocated within the evaluation of [$E];
[:zh_CN]
对 [`std::allocator<T>::allocate]（[#allocator.members]）的某个实例的调用，除非
所分配的存储在 [$E] 的求值之中被回收；

[item]
[:en]
a call to an instance of [`std::allocator<T>::deallocate] ([#allocator.members]),
unless it deallocates a region of storage allocated within the evaluation of [$E];
[:zh_CN]
对 [`std::allocator<T>::deallocate]（[#allocator.members]）的某个实例的调用，
除非它回收 [$E] 的求值之中所分配的存储区域；

[item]
[:en]
an [~await-expression] ([#expr.await]);
[:zh_CN]
[~等待表达式]（[#expr.await]）；

[item]
[:en]
a [~yield-expression] ([#expr.yield]);
[:zh_CN]
[~产出表达式]（[#expr.yield]）；

[item]
[:en]
a three-way comparison ([#expr.spaceship]), relational ([#expr.rel]),
or equality ([#expr.eq]) operator where the result is unspecified;
[:zh_CN]
未指明结果的三路比较（[#expr.spaceship]）、关系（[#expr.rel]）或相等性
（[#expr.eq]）运算符；

[item]
[:en]
a [~throw-expression] ([#expr.throw]);
[:zh_CN]
[~throw-表达式]（[#expr.throw]）；

[item]
[:en]
a [`:key dynamic_cast] ([#expr.dynamic.cast]) or [`:key typeid] ([#expr.typeid])
expression that would throw an expression;
[:zh_CN]
可能抛出异常的 [`:key dynamic_cast]（[#expr.dynamic.cast]）或 [`typeid]
（[#expr.typeid]）表达式；

[item]
[:en]
an [~asm-declaration] ([#dcl.asm]); or
[:zh_CN]
[~asm-声明式]（[#dcl.asm]）；或者

[item]
[:en]
an invocation of the [`va_arg] macro ([#cstdarg.syn]).
[:zh_CN]
对 [`va_arg] 宏的调用（[#cstdarg.syn]）。
[list:end]

[:en]
If [$E] satisfies the constraints of a core constant expression, but evaluation
of [$E] would evaluate an operation that has undefined behavior as specified in
[#library] through [#[=lastlibchapter]], or an invocation of the [`va_start]
macro ([#cstdarg.syn]), it is unspecified whether [$E] is a core constant
expression.
[:zh_CN]
如果 [$E] 满足对核心常量表达式的约束，但对 [$E] 的求值可能会求值某个具有在从
[#library] 到 [#[=lastlibchapter]] 中所述的未定义行为的操作，或者调用了
[`va_start] 宏（[#cstdarg.syn]），那么 [$E] 是否是核心常量表达式是未指明的

[begin:example]
[codeblock]
int x;                              // [:en] not constant \
                                       [:zh_CN] 不是常量
struct A {
  constexpr A(bool b) : m(b?42:x) { }
  int m;
};
constexpr int v = A(true).m;        // [:en] OK: constructor call initializes [`m] with the value [`42] \
                                       [:zh_CN] OK：构造函数的调用以 [`42] 初始化了 [`m]

constexpr int w = A(false).m;       // [:en] error: initializer for [`m] is [`x], which is non-constant \
                                       [:zh_CN] 错误：[`m] 的初始化式为 [`x]，并且不是常量

constexpr int f1(int k) {
  constexpr int x = k;              // [:en] error: [`x] is not initialized by a constant expression \
                                       [:zh_CN] 错误：[`x] 不是以常量表达式进行的初始化，
                                    // [:en@~] because lifetime of [`k] began outside the initializer of [`x] \
                                       [:zh_CN@~] 因为 [`k] 的生存期开始于 [`x] 的初始化式之外
  return x;
}
constexpr int f2(int k) {
  int x = k;                        // [:en] OK: not required to be a constant expression \
                                       [:zh_CN] OK：不需要其为常量表达式
                                    // [:en@~] because [`x] is not [`:key constexpr] \
                                       [:zh_CN@~] 因为 [`x] 不是 [`:key constexpr]
  return x;
}

constexpr int incr(int &n) {
  return ++n;
}
constexpr int g(int k) {
  constexpr int x = incr(k);        // [:en] error: [`incr(k)] is not a core constant expression \
                                       [:zh_CN] 错误：[`incr(k)] 不是核心常量表达式，
                                    // [:en@~] because lifetime of [`k] began outside the expression [`incr(k)] \
                                       [:zh_CN@~] 因为 [`k] 的生存期开始于表达式 [`incr(k)] 之外
  return x;
}
constexpr int h(int k) {
  int x = incr(k);                  // [:en] OK: [`incr(k)] is not required to be a core constant expression \
                                       [:zh_CN] OK：[`incr(k)] 不需要是核心常量表达式
  return x;
}
constexpr int y = h(1);             // [:en] OK: initializes [`y] with the value [`2] \
                                       [:zh_CN] OK：以值 [`2] 初始化 [`y]
                                    // [:en@~] [`h(1)] is a core constant expression because \
                                       [:zh_CN@~] [`h(1)] 是核心常量表达式，因为
                                    // [:en@~] the lifetime of [`k] begins inside [`h(1)] \
                                       [:zh_CN@~] [`k] 的生存期开始于 [`h(1)] 之内
[codeblock:end]
[end:example]

[para]
[:en]
For the purposes of determining whether an expression [$E] is a core constant
expression, the evaluation of a call to a member function of [`std::allocator<T>]
as defined in [#allocator.members], where [`T] is a literal type, does not
disqualify [$E] from being a core constant expression, even if the actual
evaluation of such a call would otherwise fail the requirements for a core
constant expression.
[:zh_CN]
在确定某个表达式 [$E] 是否是核心常量表达式时，对 [#allocator.members] 中所定义的
[`std::allocator<T>]（其中 [`T] 为字面类型）的成员函数的调用的求值，并不会导致
[$E] 无法作为核心常量表达式，即便对这样的调用的实际求值其实不满足对核心常量
表达式的规定也是如此。

[:en]
Similarly, the evaluation of a call to [`std::destroy_at],
[`std::ranges::destroy_at], [`std::construct_at], or [`std::ranges::construct_at]
does not disqualify [$E] from being a core constant expression unless:
[:zh_CN]
类似地，对 [`std::destroy_at]，[`std::ranges::destroy_at]，[`std::construct_at]，
或 [`std::ranges::construct_at] 的调用的求值并不会导致 [$E] 无法作为核心常量
表达式，除非以下情况：

[list]
[item]
[:en] for a call to [`std::construct_at] or [`std::ranges::construct_at], the
first argument, of type [`T*], does not point to storage allocated with
[`std::allocator<T>] or to an object whose lifetime began within the evaluation
of [$E], or the evaluation of the underlying constructor call disqualifies [$E]
from being a core constant expression, or
[:zh_CN] 对于对 [`std::construct_at] 或 [`std::ranges::construct_at] 的调用，其
首个实参（类型为 [`T*]）并不指向由 [`std::allocator<T>] 所分配的存储或某个生存期
开始于 [$E] 的求值期间的对象，或者对底层构造函数的调用的求值导致 [$E] 无法作为
核心常量表达式，或者

[item]
[:en] for a call to [`std::destroy_at] or [`std::ranges::destroy_at], the first
argument, of type [`T*], does not point to storage allocated with
[`std::allocator<T>] or to an object whose lifetime began within the evaluation
of [$E], or the evaluation of the underlying destructor call disqualifies [$E]
from being a core constant expression.
[:zh_CN] 对于对 [`std::destroy_at] 或 [`std::ranges::destroy_at] 的调用，其首个
实参（类型为 [`T*]）并不指向由 [`std::allocator<T>] 所分配的存储或某个生存期
开始于 [$E] 的求值期间的对象，或者对底层析构函数的调用的求值导致 [$E] 无法作为
核心常量表达式。
[list:end]

[para]
[:en]
An object [`a] is said to have [+:adj constant destruction[%destruction
[!constant]]] if:
[:zh_CN]
以下情况下，称对象 [`a] 具有[+:adj 常量销毁[%销毁[!常量～]]]：

[list]
[item]
[:en] it is not of class type nor (possibly multi-dimensional) array thereof, or
[:zh_CN] 它不为类类型或其（可能多维的）数组，或者
[item]
[:en] it is of class type or (possibly multi-dimensional) array thereof, that
class type has a constexpr destructor, and for a hypothetical expression [$E]
whose only effect is to destroy [`a], [$E] would be a core constant expression
if the lifetime of [`a] and its non-mutable subobjects (but not its mutable
subobjects) were considered to start within [$E].
[:zh_CN] 它为类类型或其（可能多维的）数组，此类类型具有 constexpr 析构函数，并且
对于仅有效果为销毁 [`a] 的虚构的表达式 [$E]，如果 [`a] 及其非 mutable 子对象
（但不包括其 mutable 子对象）的生存期被当做开始于 [$E] 之内，则 [$E] 可为核心
常量表达式。
[list:end]

[para]
[:en]
An [+:adj integral constant expression[%expression[!integral constant]]] is an
expression of integral or unscoped enumeration type, implicitly converted to a
prvalue, where the converted expression is a core constant expression.
[:zh_CN]
[+:adj 整型常量表达式[%表达式[!整型常量～]]]是整型或无作用域枚举类型的表达式，被
隐式转换为纯右值，其中的转换后的表达式是核心常量表达式。

[begin:note]
[:en]
Such expressions can be used as bit-field lengths ([#class.bit]), as enumerator
initializers if the underlying type is not fixed ([#dcl.enum]), and as
alignments ([#dcl.align]).
[:zh_CN]
此种表达式可用作位字段的长度（[#class.bit]），底层类型并未固定的枚举符的初始化式
（[#dcl.enum]），以及对齐（[#dcl.align]）。
[end:note]

[para]
[:en]
If an expression of literal class type is used in a context where an integral
constant expression is required, then that expression is contextually implicitly
converted ([#conv]) to an integral or unscoped enumeration type and the selected
conversion function shall be [`:key constexpr].
[:zh_CN]
如果字面类类型的表达式用在需要整型常量表达式的语境中，则该表达式被按语境隐式转换
（[#conv]）为某种整型或无作用域枚举类型，且所选择的转换函数应当为
[`:key constexpr]。

[begin:example]
[codeblock]
struct A {
  constexpr A(int i) : val(i) { }
  constexpr operator int() const { return val; }
  constexpr operator long() const { return 42; }
private:
  int val;
};
constexpr A a = alignof(int);
alignas(a) int n;               // [:en] error: ambiguous conversion \
                                   [:zh_CN] 错误：有歧义的转换
struct B { int n : a; };        // [:en] error: ambiguous conversion \
                                   [:zh_CN] 错误：有歧义的转换
[codeblock:end]
[end:example]

[para]
[:en]
A [+:adj converted constant expression[%expression[!converted constant]]] of
type [`T] is an expression, implicitly converted to type [`T], where the
converted expression is a constant expression and the implicit conversion
sequence contains only
[:zh_CN]
类型 [`T] 的[+:adj 经转换的常量表达式[%表达式[!经转换的常量～]]]是被隐式转换为
类型 [`T] 的表达式，其中的转换后的表达式是常量表达式，并且隐式转换序列中只包含

[list]
[item]
[:en@~] user-defined conversions,
[:zh_CN@~] 用户定义转换，
[item]
[:en@~] lvalue-to-rvalue conversions ([#conv.lval]),
[:zh_CN@~] 左值向右值转换（[#conv.lval]]），
[item]
[:en@~] array-to-pointer conversions ([#conv.array]),
[:zh_CN@~] 数组向指针转换（[#conv.array]），
[item]
[:en@~] function-to-pointer conversions ([#conv.func]),
[:zh_CN@~] 函数向指针转换（[#conv.func]），
[item]
[:en@~] qualification conversions ([#conv.qual]),
[:zh_CN@~] 限定转换（[#conv.qual]），
[item]
[:en@~] integral promotions ([#conv.prom]),
[:zh_CN@~] 整型提升（[#conv.prom]），
[item]
[:en@~] integral conversions ([#conv.integral]) other than narrowing conversions
([#dcl.init.list]),
[:zh_CN@~] 除了窄化转换（[#dcl.init.list]）之外的整型转换（[#conv.integral]），
[item]
[:en@~] null pointer conversions ([#conv.ptr]) from [`std::nullptr_t], and
[:zh_CN@~] 从 [`std::nullptr_t] 进行的空指针转换（[#conv.ptr]），
[item]
[:en@~] null member pointer conversions ([#conv.mem]) from [`std::nullptr_t],
[:zh_CN@~] 从 [`std::nullptr_t] 进行的空成员指针转换（[#conv.mem]），以及
[item]
[:en@~] function pointer conversions ([conv.fctptr]),
[:zh_CN@~] 函数指针转换（[#conv.fctptr]），
[list:end]

[:en@~]
and where the reference binding (if any) binds directly.
[:zh_CN@~]
并且其中的引用绑定（如果有）是直接绑定。

[begin:note]
[:en]
Such expressions can be used in [`:key new] expressions ([#expr.new]), as case
expressions ([#stmt.switch]), as enumerator initializers if the underlying type
is fixed ([#dcl.enum]), as array bounds ([#dcl.array]), and as non-type template
arguments ([#temp.arg]).
[:zh_CN]
此种表达式可用在 [`:key new] 表达式中（[#expr.new]），用作 case 表达式
（[#stmt.switch]），用作底层类型已固定的枚举符的初始化式（[#dcl.enum]），用作
数组边界（[#dcl.array]），以及用作整型或枚举的非类型模板实参（[#temp.arg]）。
[end:note]

[:en]
[%contextually converted constant expression of type [`bool]
[%conversion[!contextual]]]
[%conversion[!contextual to constant expression of type [`bool]]]
A [+:% contextually converted constant expression of type [`bool]] is an
expression, contextually converted to [`:key bool] ([#conv]), where the
converted expression is a constant expression and the conversion sequence
contains only the conversions above.
[:zh_CN]
[%按语境转换为类型 [`bool] 的常量表达式 [%转换[!按语境～]]]
[%转换[!按语境～为类型 [`bool] 的常量表达式]]
[+:% 按语境转换为类型 [`bool] 的常量表达式]，是按语境转换为 [`:key bool]（[#conv]）
的表达式，所转换的表达式是常量表达式，且其转换序列中仅包含上述转换。

[para]
[:en]
A [+:adj constant expression[%expression[!constant]]] is either a glvalue core
constant expression that refers to an entity that is a permitted result of a
constant expression (as defined below), or a prvalue core constant expression
whose value satisfies the following constraints:
[:zh_CN]
[+:adj 常量表达式[%表达式[!常量～]]]是泛左值核心常量表达式，其值所指代的实体是
常量表达式所允许的某种结果（如下文定义），或者是纯右值核心常量表达式，其值满足
如下约束条件：

[list]
[item]
[:en]
if the value is an object of class type, each non-static data member of
reference type refers to an entity that is a permitted result of a constant
expression,
[:zh_CN]
若其值为类类型的对象，则它的每个引用类型的数据成员所指代的实体都是常量表达式所
允许的结果，

[item]
[:en]
if the value is of pointer type, it contains the address of an object with
static storage duration, the address past the end of such an object
([#expr.add]), the address of a non-immediate function, or a null pointer value,
[:zh_CN]
若其值为指针类型，则它包含某个具有静态存储期的对象的地址，越过这种对象末尾的地址
（[#expr.add]），某个非直接函数的地址，或空指针值，

[item]
[:en]
if the value is of pointer-to-member-function type, it does not designate an
immediate function, and
[:zh_CN]
若其值为成员函数指针类型，则它并不代表某个直接函数，并且

[item]
[:en]
if the value is an object of class or array type, each subobject satisfies these
constraints for the value.
[:zh_CN]
若其值为类或数组类型的对象，其每个子对象都应当满足这些对于值的约束条件。
[list:end]

[:en]
An entity is a [+permitted result of a constant expression[%constant expression
[!permitted result of]]] if it is an object with static storage duration that
either is not a temporary object or is a temporary object whose value satisfies
the above constraints, or if it is a non-immediate function.
[:zh_CN]
若某个实体是具有静态存储期的对象，并且要么不是临时对象，要么是临时对象但其值满足
上述约束条件，或者若该是个非直接函数，则该实体是[+常量表达式允许的结果
[%常量表达式[!～允许的结果]]]。

[begin:example]
[codeblock]
consteval int f() { return 42; }
consteval auto g() { return f; }
consteval int h(int (*p)() = g()) { return p(); }
constexpr int r = h();                          // OK
constexpr auto e = g();                         // [:en] error: a pointer to an immediate function is \
                                                   [:zh_CN] 错误：指向直接函数的指针不能
                                                // [:en@~] not a permitted result of a constant expression \
                                                   [:zh_CN@~] 作为常量表达式的结果
[codeblock:end]
[end:example]

[para:recommended]
[:en]
Implementations should provide consistent results of floating-point evaluations,
irrespective of whether the evaluation is performed during translation or during
program execution.
[:zh_CN]
实现最好为浮点求值提供一致的结果，与求值是否实际发生于翻译过程中还是程序执行过程
中无关。
[begin:note]
[:en]
Since this document imposes no restrictions on the accuracy of floating-point
operations, it is unspecified whether the evaluation of a floating-point
expression during translation yields the same result as the evaluation of the
same expression (or the same operations on the same values) during program
execution.
[:zh_CN]
由于本文档并不对浮点运算的精度施加任何限制，所以在翻译过程中对浮点表达式进行的
求值所产生的结果，与同一个表达式（或者对相同的值进行相同的运算）在程序执行过程中
所产生的结果是否相同，是未指明的。

[begin:example]
[codeblock]
bool f() {
    char array[1 + int(1 + 0.2 - 0.1 - 0.1)];   // [:en] Must be evaluated during translation \
                                                   [:zh_CN] 必须在翻译过程中求值
    int size = 1 + int(1 + 0.2 - 0.1 - 0.1);    // [:en] May be evaluated at runtime \
                                                   [:zh_CN] 可以在运行时求值
    return sizeof(array) == size;
}
[codeblock:end]

[:en]
It is unspecified whether the value of [`f()] will be [`true] or [`false].
[:zh_CN]
[`f()] 的值是 [`true] 还是 [`false] 是未指明的。
[end:example]
[end:note]

[para]
[:en]
An expression or conversion is in an [+immediate function context] if it is
potentially evaluated and either:
[:zh_CN]
一个表达式或转换，如果它是潜在求值的且满足以下情况，则它处于[+直接函数语境]之中：
[list]
[item]
[:en@~] its innermost enclosing non-block scope is a function parameter scope of
an immediate function, or
[:zh_CN@~] 其最内层外围非块作用域是某个直接函数的函数形参作用域，或者
[item]
[:en@~] its enclosing statement is enclosed ([#stmt.pre]) by the
[~compound-statement] of a consteval if statement ([#stmt.if]).
[:zh_CN@~] 其外围语句被 consteval if 语句（[#stmt.if]）的[~复合语句]所包围
（[#stmt.pre]）。
[list:end]

[:en]
An expression or conversion is an [+immediate invocation] if it is a
potentially-evaluated explicit or implicit invocation of an immediate function
and is not in an immediate function context.
[:zh_CN]
一个表达式或转换，如果它对某个直接函数的潜在求值的显式或隐式调用，且并非处于直接
函数语境之中，则它是一次[+直接调用]。

[:en]
An immediate invocation shall be a constant expression.
[:zh_CN]
直接调用应当是常量表达式。

[para]
[:en]
An expression or conversion is [+manifestly constant-evaluated] if it is:
[:zh_CN]
符合以下情况的表达式或转换是[+显然常量求值的]：

[list]
[item]
[:en@~] a [~constant-expression], or
[:zh_CN@~] [~常量表达式]，或
[item]
[:en@~] the condition of a constexpr if statement ([#stmt.if]), or
[:zh_CN@~] [`constexpr if] 语句的条件（[#stmt.if]），或
[item]
[:en@~] an immediate invocation, or
[:zh_CN@~] 直接调用，或
[item]
[:en@~] the result of substitution into an atomic constraint expression
to determine whether it is satisfied ([#temp.constr.atomic]), or
[:zh_CN@~] 向原子约束表达式中进行代换以确定其是否被满足（[#temp.constr.atomic]）
的结果，或
[item]
[:en@~] the initializer of a variable that is usable in constant expressions or
has constant initialization ([#basic.start.static]).[#:fn#]
[:zh_CN@~] 可被用在常量表达式中，或具有常量初始化的变量的初始化式
（[#basic.start.static]）。[#:fn#]

[note:foot]
[:en]
Testing this condition can involve a trial evaluation of its initializer as
described above.
[:zh_CN]
这个条件的测试可以涉及对其初始化式进行如上所述的平凡求值。
[note:end]

[begin:example]
[codeblock]
template<bool> struct X {};
X<std::is_constant_evaluated()> x;                      // [:en] type [`X<true>] \
                                                           [:zh_CN] 类型 [`X<true>]
int y;
const int a = std::is_constant_evaluated() ? y : 1;     // [:en] dynamic initialization to 1 \
                                                           [:zh_CN] 动态初始化为 1
double z[a];                                            // [:en] error: [`a] is not usable \
                                                           [:zh_CN] 错误：[`a] 不能被用在
                                                        // [:en@~] in constant expressions \
                                                           [:zh_CN@~] 常量表达式值中
const int b = std::is_constant_evaluated() ? 2 : y;     // [:en] static initialization to 2 \
                                                           [:zh_CN] 静态初始化为 2
int c = y + (std::is_constant_evaluated() ? 2 : y);     // [:en] dynamic initialization to [`y+y] \
                                                           [:zh_CN] 动态初始化为 [`y+y]

constexpr int f() {
  const int n = std::is_constant_evaluated() ? 13 : 17; // [:en] [`n] is 13 \
                                                           [:zh_CN] [`n] 为 13
  int m = std::is_constant_evaluated() ? 13 : 17;       // [:en] [`m] can be 13 or 17 (see below) \
                                                           [:zh_CN] [`m] 可为 13 或 17（见下文）
  char arr[n] = {}; // char[13]
  return m + sizeof(arr);
}
int p = f();                                            // [:en] [`m] is 13; initialized to 26 \
                                                           [:zh_CN] [`m] 为 13；初始化为 26
int q = p + f();                                        // [:en] [`m] is 17 for this call; initialized to 56 \
                                                           [:zh_CN] [`m] 在本次调用中为 17；初始化为 56
[codeblock:end]
[end:example]
[list:end]

[begin:note]
[:en]
A manifestly constant-evaluated expression is evaluated even in an unevaluated
operand.
[:zh_CN]
显然常量求值表达式即便在免求值操作数中仍被求值。
[end:note]

[para]
[:en]
[%expression[!potentially constant evaluated]]
An expression or conversion is [+potentially constant evaluated] if it is:
[:zh_CN]
[%表达式[!潜在常量求值]]
如下情况下表达式或转换被[+潜在常量求值]：

[list]
[item]
[:en]
a manifestly constant-evaluated expression,
[:zh_CN]
显然常量求值表达式，

[item]
[:en]
a potentially-evaluated expression ([#basic.def.odr]),
[:zh_CN]
潜在求值表达式（[#basic.def.odr]），

[item]
[:en]
an immediate subexpression of a [~braced-init-list],[#:fn#]
[:zh_CN]
[~花括号初始化列表]的直接子表达式，[#:fn#]

[note:foot]
[:en]
In some cases, constant evaluation is needed to determine whether a narrowing
conversion is performed ([#dcl.init.list]).
[:zh_CN]
某些情况下，为确定是否会实施窄化转换需要进行常量求值（[#dcl.init.list]）。
[note:end]

[item]
[:en]
an expression of the form [`&] [~cast-expression] that occurs within a templated
entity,[#:fn#] or
[:zh_CN]
在模板化的实体中出现的形式为“[`&] [~强制转换表达式]”的表达式，[#:fn#] 或者

[note:foot]
[:en]
In some cases, constant evaluation is needed to determine whether such an
expression is value-dependent ([#temp.dep.constexpr]).
[:zh_CN]
某些情况下，为确定这种表达式是否是值待决的需要进行常量求值（[#temp.dep.constexpr]）。
[note:end]

[item]
[:en]
a subexpression of one of the above that is not a subexpression of a nested
unevaluated operand.
[:zh_CN]
以上各项之一的子表达式，且不是某个嵌套的免求值操作数的子表达式。
[list:end]

[:en]
[%function[!needed for constant evaluation]]
[%variable[!needed for constant evaluation]]
A function or variable is [+needed for constant evaluation] if it is:
[:zh_CN]
[%函数[!常量求值所需的]]
[%变量[!常量求值所需的]]
以下情况下函数或变量是[+常量求值所需的]：

[list]
[item]
[:en]
a constexpr function that is named by an expression ([#basic.def.odr]) that is
potentially constant evaluated, or
[:zh_CN]
被潜在常量求值的表达式所指名（[#basic.def.odr]）的 constexpr 函数，或者

[item]
[:en]
a variable named by a potentially constant evaluated expression that is either
a constexpr variable or is of non-volatile const-qualified integral type or of
reference type.
[:zh_CN]
被潜在常量求值表达式所指名的变量，它要么是 constexpr 变量，要么具有非 volatile
的 const 限定的整型类型或引用类型。
[list:end]
[end:example]
