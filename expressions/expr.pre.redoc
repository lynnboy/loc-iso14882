[section#expr.pre
    [:en] Preamble
    [:zh_CN] 导言
]

[para]
[enter:note]
[:en]
[#expr] defines the syntax, order of evaluation, and meaning of
expressions.[#:note#fn:$section.1]
[:zh_CN]
[#expr] 定义了表达式的语法、求值顺序及其含义。[#:note#fn:$section.1]

[note:foot#fn:$section.1]
[:en]
The precedence of operators is not directly specified, but it can be derived
from the syntax.
[:zh_CN]
各运算符的优先级并未直接指定，但可以从其语法中推导出来。
[note:end]

[:en]
An expression is a sequence of operators and operands that specifies a
computation.
[:zh_CN]
表达式是一系列用以指定某项计算的运算符和操作数。

[:en]
An expression can result in a value and can cause side effects.
[:zh_CN]
表达式可以产生值也可以造成副作用。
[exit:note]

[para]
[enter:note]
[:en]
[%operator[!overloaded]]
Operators can be overloaded, that is, given meaning when applied to expressions
of class type ([#class]) or enumeration type ([#dcl.enum]).
[:zh_CN]
[%运算符[!重载～]]
可以对运算符进行重载，这是指，指定它在应用于类类型（[#class]）或枚举类型
（[#dcl.enum]）的表达式上时的含义。

[:en]
Uses of overloaded operators are transformed into function calls as described in
[#over.oper].
[:zh_CN]
对重载运算符的使用，将按照 [#over.oper] 所述转换为函数调用。

[:en]
Overloaded operators obey the rules for syntax and evaluation order specified in
[#expr.compound], but the requirements of operand type and value category are
replaced by the rules for function call.
[:zh_CN]
重载运算符遵循在 [#expr.compound] 中指定的语法和求职顺序规则，但关于操作数类型和
值的类别的规定，则替换为针对函数调用的规则。

[:en]
Relations between operators, such as [`++a] meaning [`a+=1], are not guaranteed
for overloaded operators ([#over.oper]).
[:zh_CN]
运算符之间的关系，如 [`++a] 意为 [`a+=1]，不保证在重载运算符（[#over.oper]）上
仍然保持。
[exit:note]

[para]
[:en]
Subclause [#expr.compound] defines the effects of operators when applied to
types for which they have not been overloaded.
[:zh_CN]
子条款 [#expr.compound] 中定义了运算符施加在并未对其进行重载的类型上时的效果。

[:en]
Operator overloading shall not modify the rules for the [+built-in operators
[%operators[!built-in]]]], that is, for operators applied to types for which
they are defined by this Standard.
[:zh_CN]
运算符重载不应当改变[+内建运算符[%运算符[!内建～]]]（就是说，施加于由本标准所
定义的类型上的运算符）的规则。

[:en]
However, these built-in operators participate in overload resolution, and as
part of that process user-defined conversions will be considered where necessary
to convert the operands to types appropriate for the built-in operator.
[:zh_CN]
然而，这些内建运算符参与重载决议，而且作为这个过程中的一部分，在须要把操作数转换
为适用于内建运算符的类型时，还要考察用户定义转换。

[:en]
If a built-in operator is selected, such conversions will be applied to the
operands before the operation is considered further according to the rules in
subclause [#expr.compound]; see [#over.match.oper], [#over.built].
[:zh_CN]
如果选取了内建运算符，则将在按照子条款 [#expr.compound] 的规则进一步考察其操作
之前，对操作数应用这些转换；参见 [#over.match.oper]，[#over.built]。

[para]
[:en]
[%exception[!arithmetic]]
[%exception[!undefined arithmetic]]
[%overflow[!undefined]]
[%zero[!division by undefined]]
[%zero[!remainder undefined]]
If during the evaluation of an expression, the result is not mathematically
defined or not in the range of representable values for its type, the behavior
is undefined.
[:zh_CN]
[%异常[!算术～]]
[%异常[!未定义的算术～]]
[%溢出[!未定义的]]
[%零[!未定义的除以～]]
[%零[!未定义的余数]]
对表达式进行求值时，如果其结果在数学上无定义，或不在其类型的可表示的值的范围内，
则其行为是未定义的。

[enter:note]
[:en]
[%overflow]
Treatment of division by zero, forming a remainder using a zero divisor, and all
floating-point exceptions vary among machines, and is sometimes adjustable by a
library function.
[:zh_CN]
[%溢出]
对于被零除，用零除数获取余数，以及所有的浮点异常的处理在不同机器之间都有所不同，
且有时可以通过库函数来进行调整。
[exit:note]

[para]
[:en]
The values of the floating operands and the results of floating expressions may
be represented in greater precision and range than that required by the type;
the types are not changed thereby.[#:note#fn:$section.2]
[:zh_CN]
浮点操作数的值和浮点表达式的结果，可用比其类型所需更大的精度和范围来表示；但这并
不会改变它的类型。[#:note#fn:$section.2]

[note:foot#fn:$section.2]
[:en]
The cast and assignment operators must still perform their specific conversions
as described in [#expr.cast], [#expr.static.cast] and [#expr.ass].
[:zh_CN]
强制转换和赋值运算符必须仍然实施在 [#expr.cast]，[#expr.static.cast] 和
[#expr.ass] 中说明的它们的特定转换。
[note:end]

