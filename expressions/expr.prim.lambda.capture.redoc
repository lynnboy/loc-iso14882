[section#expr.prim.lambda.capture
    [:en] Captures
    [:zh_CN] 捕获式
]

[syntax]
[rule lambda-capture [:zh_CN] lambda-捕获式 ]
    [| capture-default ]
    [| capture-list ]
    [| capture-default [`,] capture-list ]
[rule:end]

[rule capture-default [:zh_CN] 默认捕获符 ]
    [| [`&] ]
    [| [`=] ]
[rule:end]

[rule capture-list [:zh_CN] 捕获符列表 ]
    [| capture ]
    [| capture-list [`,] capture ]
[rule:end]

[rule capture [:zh_CN] 捕获符 ]
    [| simple-capture [`:opt ...] ]
    [| [`:opt ...] init-capture ]
[rule:end]

[rule simple-capture [:zh_CN] 简单捕获符 ]
    [| identifier ]
    [| [`&] identifier ]
    [| [`this] ]
    [| [`* this] ]
[rule:end]

[rule init-capture [:zh_CN] 带初始化捕获符 ]
    [| identifier initializer ]
    [| [`&] identifier initializer ]
[rule:end]
[syntax:end]

[para]
[:en]
The body of a [~lambda-expression] may refer to variables with automatic storage
duration and the [`*this] object (if any) of enclosing block scopes by capturing
those entities, as described below.
[:zh_CN]
[~lambda-表达式]的函数体可能会通过对外围块作用域中的具有自动存储期的变量和
[`*this] 对象（如果有）进行捕获而涉指这些实体，如下所述。

[para]
[:en]
If a [~lambda-capture] includes a [~capture-default] that is [`&], no identifier
in a [~simple-capture] of that [~lambda-capture] shall be preceded by [`&].
[:zh_CN]
如果 [~lambda-捕获式]中包含的[~默认捕获符]是 [`&]，则在 [~lambda-捕获式]的
[~简单捕获符]之中的标识符前面不应当有 [`&]。

[:en]
If a [~lambda-capture] includes a [~capture-default] that is [`=], each
[~simple-capture] of that [~lambda-capture] shall be of the form ["[`&]
[~identifier]], ["[`this]], or ["[`* this]].
[:zh_CN]
如果 [~lambda-捕获式]中包含的[~默认捕获符]是 [`=]，则 [~lambda-捕获式]中的每个
[~简单捕获符]都应当具有“[`&] [~标识符]”，“[`this]”，或“[`* this]”的形式。

[enter:note]
[:en]
The form [``[&,this`]] is redundant but accepted for compatibility with ISO
[=CppXIV].
[:zh_CN]
[``[&,this`]] 的形式是多余的，但为保持和 ISO [=CppXIV] 的兼容性而接受。
[exit:note]

[:en]
Ignoring appearances in [~initializer]s of [~init-capture]s, an identifier or
[`this] shall not appear more than once in a [~lambda-capture].
[:zh_CN]
除[~带初始化捕获符]中出现的[~标识符]之外，在一个 [~lambda-捕获式] 之中，标识符
或者 [`this] 不能多次出现。

[enter:example]
[codeblock]
struct S2 { void f(int i); };
void S2::f(int i) {
  [&, i]{ };        // OK
  [&, this, i]{ };  // [:en] OK, equivalent to [``[&, i`]]
                    // [|:zh_CN] OK，等价于 [``[&, i`]]
  [&, &i]{ };       // [:en] error: [`i] preceded by [`&] when [`&] is the default
                    // [|:zh_CN] 错误：当 [`&] 为默认时 [`i] 之前带有 [`&]
  [=, *this]{ };    // OK
  [=, this]{ };     // [:en] OK: equivalent to [``[=`]]
                    // [|:zh_CN] OK：等价于 [``[=`]]
  [i, i]{ };        // [:en] error: [`i] repeated
                    // [|:zh_CN] 错误：重复了 [`i]
  [this, *this]{ }; // [:en] error: [`this] appears twice
                    // [|:zh_CN] 错误：[`this] 出现了两次
}
[codeblock:end]
[exit:example]

[para]
[:en]
A [~lambda-expression] is a [+local lambda expression] if its innermost
enclosing scope is a block scope ([#basic.scope.block]), or if it appears within
a default member initializer and its innermost enclosing scope is the
corresponding class scope ([#basic.scope.class]); any other [~lambda-expression]
shall not have a [~capture-default] or [~simple-capture] in its
[~lambda-introducer].
[:zh_CN]
如果 [~lambda-表达式]的最内层外围作用域是块作用域（[#basic.scope.block]），或者
它出现于默认成员初始化式之内且其最内层外围作用域是对应的类作用域
（[#basic.scope.class]），则它是[+局部 lambda 表达式]；任何其他 [~lambda-表达式]
的 [~lambda-引导符]中都不能包含[~默认捕获符]或[~简单捕获符]。

[para]
[:en]
The [~identifier] in a [~simple-capture] is looked up using the usual rules for
unqualified name lookup ([#basic.lookup.unqual]); each such lookup shall find a
local entity.
[:zh_CN]
使用未限定名查找的常规规则对[~简单捕获符]中的[~标识符]进行查找
（[#basic.lookup.unqual]）；每次这种查找都应当找到一个局部实体。

[:en]
The [~simple-capture]s [`this] and [`* this] denote the local entity [`*this].
[:zh_CN]
[~简单捕获符] [`this] 和 [`* this] 代表局部实体 [`*this]。

[:en]
An entity that is designated by a [~simple-capture] is said to be [+explicitly
captured].
[:zh_CN]
由[~简单捕获符]所代表的实体称为被[+显式捕获]。

[para]
[:en]
If an [~identifier] in a [~simple-capture] appears as the [~declarator-id] of a
parameter of the [~lambda-declarator][=']s [~parameter-declaration-clause], the
program is ill-formed.
[:zh_CN]
如果[~简单捕获符]中的某个[~标识符]被用作该[~lambda-声明符]的[~形参声明式子句]的
某个形参的[~声明符标识]，则程序非良构。

[enter:example]
[codeblock]
void f() {
  int x = 0;
  auto g = [x](int x) { return 0; }    // [:en] error: parameter and [~simple-capture] have the same name
                                       // [|:zh_CN] 错误：形参和[~简单捕获符]的名字相同
}
[codeblock:end]
[exit:example]

[para]
[:en]
An [~init-capture] behaves as if it declares and explicitly captures a variable
of the form ["[`auto] [~init-capture] [`;]] whose declarative region is the
[~lambda-expression][=']s [~compound-statement], except that:
[:zh_CN]
[~带初始化捕获符]表现为如同它声明并显式捕获某个形式为“[`auto] [~带初始化捕获符]
[`;]”的变量，其声明区为该[~lambda-表达式]的[~组合语句]，但是：

[list]
[item]
[:en]
if the capture is by copy (see below), the non-static data member declared for
the capture and the variable are treated as two different ways of referring to
the same object, which has the lifetime of the non-static data member, and no
additional copy and destruction is performed, and
[:zh_CN]
若该捕获式为复制捕获（见下文），则为该捕获式声明的非静态数据成员和这个变量被当作
指代相同对象的两个不同方式，具有非静态数据成员的生存期，并且不进行其他复制和销毁
操作，并且

[item]
[:en]
if the capture is by reference, the variable[=']s lifetime ends when the closure
object[=']s lifetime ends.
[:zh_CN]
若该捕获式为引用捕获，则该变量的生存期在闭包对象的生存期结束时结束。
[list:end]

[enter:note]
[:en]
This enables an [~init-capture] like ["[`x = std::move(x)]]; the second ["[`x]]
must bind to a declaration in the surrounding context.
[:zh_CN]
这样就允许[~带初始化捕获符]“[`x = std::move(x)]”；其第二个“[`x]”必须绑定到其外围
语境中的某个声明式。
[exit:note]

[enter:example]
[codeblock]
int x = 4;
auto y = [&r = x, x = x+1]()->int {
            r += 2;
            return x+2;
         }();  // [:en] Updates [`::x] to 6, and initializes [`y] to 7.
               // [|:zh_CN] 更新 [`::x] 为 6，并初始化 [`y] 为 7。

auto z = [a = 42](int a) { return 1; } // [:en] error: parameter and local variable have the same name
                                       // [|:zh_CN] 错误：形参和局部变量的名字相同
[codeblock:end]
[exit:example]

[para]
[:en]
For the purposes of lambda capture, an expression potentially references local
entities as follows:
[:zh_CN]
考虑 lambda 捕获时，表达式按如下方式潜在地指代局部实体：

[list]
[item]
[:en]
An [~id-expression] that names a local entity potentially references that
entity; an [~id-expression] that names one or more non-static class members and
does not form a pointer to member ([#expr.unary.op]) potentially references
[`*this].
[:zh_CN]
指名某个局部实体的[~标识表达式]潜在地引用该实体；指名一个或更多非静态类成员但不
构成成员指针的[~标识表达式]（[#expr.unary.op]）潜在地引用 [`*this]。

[enter:note]
[:en]
This occurs even if overload resolution selects a static member function for the
[~id-expression].
[:zh_CN]
即便重载决议为该[~标识表达式]选择的是静态成员函数也是如此。
[exit:note]

[item]
[:en]
A [`this] expression potentially references [`*this].
[:zh_CN]
表达式 [`this] 潜在地引用 [`*this]。

[item]
[:en]
A [~lambda-expression] potentially references the local entities named by its
[~simple-capture]s.
[:zh_CN]
[~lambda-表达式]潜在地引用其[~简单捕获符]所指名的各局部实体。
[list:end]

[:en]
If an expression potentially references a local entity within a declarative
region in which it is odr-usable, and the expression would be potentially
evaluated if the effect of any enclosing [`typeid] expressions ([#expr.typeid])
were ignored, the entity is said to be [+implicitly captured[%capture
[!implicit]]] by each intervening [~lambda-expression] with an associated
[~capture-default] that does not explicitly capture it.
[:zh_CN]
如果某个表达式在其可 ODR 式使用的声明区中潜在地引用了某个局部实体，且该表达式
在忽略任何外围的 [`typeid] 表达式（[#expr.typeid]）的效果时是潜在求值的，则称
该实体被介入期间的每个带有[~默认捕获符]且并未显式捕获它的 [~lambda-表达式]所
[+隐式捕获[%捕获[!隐式～]]]。

[enter:example]
[codeblock]
void f(int, const int (&)[2] = {});         // #1
void f(const int&, const int (&)[1]);       // #2
void test() {
  const int x = 17;
  auto g = [](auto a) {
    f(x);                       // [:en] OK: calls #1, does not capture [`x]
                                // [|:zh_CN] OK：调用 #1，并未捕获 [`x]
  };

  auto g1 = [=](auto a) {
    f(x);                       // [:en] OK: calls #1, captures [`x]
                                // [|:zh_CN] OK：调用 #1，捕获 [`x]
  };

  auto g2 = [=](auto a) {
    int selector[sizeof(a) == 1 ? 1 : 2]{};
    f(x, selector);             // [:en] OK: captures [`x], might call #1 or #2
                                // [|:zh_CN] OK：捕获了 [`x]，可能调用 #1 或 #2
  };

  auto g3 = [=](auto a) {
    typeid(a + x);              // [:en] captures [`x] regardless of whether [`a + x] is an unevaluated operand
                                // [|:zh_CN] 无论 [`a + x] 是否是免求值操作数，都捕获 [`x]
  };
}
[codeblock:end]

[:en]
Within [`g1], an implementation might optimize away the capture of [`x] as it is
not odr-used.
[:zh_CN]
在 [`g1] 中，实现可能会将对 [`x] 的捕获优化掉，因为它并未被 ODR-式使用。
[exit:example]

[enter:note]
[:en]
The set of captured entities is determined syntactically, and entities might be
implicitly captured even if the expression denoting a local entity is within a
discarded statement ([#stmt.if]).
[:zh_CN]
被捕获实体的集合是依据语法来确定的，而且即便代表某个局部实体的表达式处于弃用语句
（[#stmt.if]）之中，实体也可能会被隐式捕获。

[enter:example]
[codeblock]
template<bool B>
void f(int n) {
  [=](auto a) {
    if constexpr (B && sizeof(a) > 4) {
      (void)n;                  // [:en] captures [`n] regardless of the value of [`B] and [`sizeof(int)]
                                // [|:zh_CN] 无论 [`B] 和 [`sizeof(int)] 的值时什么都捕获 [`n]
    }
  }(0);
}
[codeblock:end]
[exit:example]
[exit:note]

[para]
[:en]
An entity is [+captured] if it is captured explicitly or implicitly.
[:zh_CN]
若某个实体被显式或隐式捕获，则它被[+捕获]。

[:en]
An entity captured by a [~lambda-expression] is odr-used ([#basic.def.odr]) in
the scope containing the [~lambda-expression].
[:zh_CN]
由某个 [~lambda-表达式]所捕获的实体，是在包含该 [~lambda-表达式]的作用域中被
ODR 式使用的（[#basic.def.odr]）。
    
[:en]
If a [~lambda-expression] explicitly captures an entity that is not odr-usable
or captures a structured-binding (explicitly or implicitly), the program is
ill-formed.
[:zh_CN]
如果 [~lambda-表达式]所捕获的实体并非可 ODR-式使用的，或者（显式或隐式）捕获了
结构化绑定，则程序非良构。

[enter:example]
[%Bond[!James Bond]]
[codeblock]
void f1(int i) {
  int const N = 20;
  auto m1 = [=]{
    int const M = 30;
    auto m2 = [i]{
      int x[N][M];              // [:en] OK: [`N] and [`M] are not odr-used
                                // [|:zh_CN] OK：[`N] 和 [`M] 未被 ODR 式使用
      x[0][0] = i;              // [:en] OK: [`i] is explicitly captured by [`m2] and implicitly captured by [`m1]
                                // [|:zh_CN] OK：[`i] 由 [`m2] 显式捕获并由 [`m1] 所隐式捕获
    };
  };
  struct s1 {
    int f;
    void work(int n) {
      int m = n*n;
      int j = 40;
      auto m3 = [this,m] {
        auto m4 = [&,j] {       // [:en] error: [`j] not odr-usable due to intervening lambda [`m3]
                                // [|:zh_CN] 错误：[`j] 由于介入的 lambda [`m3] 而并非可 ODR-式使用的
          int x = n;            // [:en] error: [`n] is odr-used but not odr-usable due to intervening lambda [`m3]
                                // [|:zh_CN] 错误：[`n] 被 ODR-式使用但由于介入的 lambda [`m3] 而并非可 ODR-式使用的
          x += m;               // [:en] OK: [`m] implicitly captured by [`m4] and explicitly captured by [`m3]
                                // [|:zh_CN] OK：[`m] 被 [`m4] 隐式捕获并被 [`m3] 显式捕获
          x += i;               // [:en] error: [`i] is odr-used but not odr-usable
                                // [|:zh_CN] 错误：[`i] 被 ODR-式使用但由于介入的
                                // [:en@~] due to intervening function and class scopes
                                // [|:zh_CN@~] 函数和类作用域而非可 ODR-式使用的
          x += f;               // [:en] OK: [`this] captured implicitly by [`m4] and explicitly by [`m3]
                                // [|:zh_CN] OK：[`this] 被 [`m4] 隐式捕获并被 [`m3] 显式捕获
        };
      };
    }
  };
}

struct s2 {
  double ohseven = .007;
  auto f() {
    return [this] {
      return [*this] {
          return ohseven;       // OK
      }
    }();
  }
  auto g() {
    return [] {
      return [*this] { };       // [:en] error: [`*this] not captured by outer [~lambda-expression]
                                // [|:zh_CN] 错误：[`*this] 并未被外围的 [~lambda-表达式]所捕获
    }();
  }
};
[codeblock:end]
[exit:example]

[para]
[:en]
A [~lambda-expression] appearing in a default argument shall not implicitly or
explicitly capture any entity.
[:zh_CN]
出现于默认实参中的 [~lambda-表达式]，不应隐式或显式捕获任何实体。

[enter:example]
[codeblock]
void f2() {
  int i = 1;
  void g1(int = ([i]{ return i; })());          // [:en] ill-formed
                                                // [|:zh_CN] 非良构
  void g2(int = ([i]{ return 0; })());          // [:en] ill-formed
                                                // [|:zh_CN] 非良构
  void g3(int = ([=]{ return i; })());          // [:en] ill-formed
                                                // [|:zh_CN] 非良构
  void g4(int = ([=]{ return 0; })());          // OK
  void g5(int = ([]{ return sizeof i; })());    // OK
}
[codeblock:end]
[exit:example]

[para]
[:en]
An entity is [+captured by copy [%captured [!by copy]]] if
[:zh_CN]
以下情况下实体被[+复制捕获[%捕获[!复制～]]]：

[list]
[item]
[:en]
it is implicitly captured, the [~capture-default] is [`=], and the captured
entity is not [`*this], or
[:zh_CN]
它被隐式捕获，其[~默认捕获符]是 [`=]，且所捕获的实体不是 [`*this]，或者

[item]
[:en]
it is explicitly captured with a capture that is not of the form [`this],
[`&] [~identifier], or [`&] [~identifier] [~initializer].
[:zh_CN]
它被显式捕获，其捕获式不具有“[`this]”，“[`&] [~标识符]”，或
“[`&] [~标识符] [~初始化式]”的形式。
[list:end]

[:en]
For each entity captured by copy, an unnamed non-static data member is declared
in the closure type.
[:zh_CN]
对于每个复制捕获的实体，在闭包类型中都声明了一个无名的非静态数据成员。

[:en]
The declaration order of these members is unspecified.
[:zh_CN]
这些成员的声明顺序是未指明的。

[:en]
The type of such a data member is the referenced type if the entity is a
reference to an object, an lvalue reference to the referenced function type if
the entity is a reference to function, or the type of the corresponding captured
entity otherwise.
[:zh_CN]
这种数据成员的类型，当实体是对象的引用时为被引用的类型，当实体是函数的引用时为
被引用函数类型的左值引用，否则就是相应被捕获实体的类型。

[:en]
A member of an anonymous union shall not be captured by copy.
[:zh_CN]
匿名联合的成员不能被复制捕获。

[para]
[:en]
Every [~id-expression] within the [~compound-statement] of a
[~lambda-expression] that is an odr-use ([#basic.def.odr]) of an entity captured
by copy is transformed into an access to the corresponding unnamed data member
of the closure type.
[:zh_CN]
[~lambda-表达式]的[~组合语句]中，每个 ODR 式使用（[#basic.def.odr]）被复制捕获的
实体的[~标识表达式]，均被变换为对其闭包类型的对应无名数据成员的访问。

[enter:note]
[:en]
An [~id-expression] that is not an odr-use refers to the original entity, never
to a member of the closure type.
[:zh_CN]
不进行 ODR-式使用的[~标识表达式]，指代原来的实体，而并非指代闭包类型的成员。

[:en]
However, such an [~id-expression] can still cause the implicit capture of the
entity.
[:zh_CN]
不过，这种[~标识表达式]仍会导致对该实体的隐式捕获。
[exit:note]

[:en]
If [`*this] is captured by copy, each expression that odr-uses [`this] is
transformed to instead refer to the corresponding unnamed data member of the
closure type.
[:zh_CN]
当 [`*this] 被复制捕获时，每个 ODR 式使用 [`this] 的表达式，均被变换为而并非指代
其闭包类型的对应无名数据成员。

[enter:example]
[codeblock]
void f(const int*);
void g() {
  const int N = 10;
  [=] {
    int arr[N];     // [:en] OK: not an odr-use, refers to automatic variable
                    // [|:zh_CN] OK：不是 ODR-式使用，指代自动变量
    f(&N);          // [:en] OK: causes [`N] to be captured; [`&N] points to
                    // [|:zh_CN] OK：导致 [`N] 被捕获；[`&N] 指向
                    // [:en@~] the corresponding member of the closure type
                    // [|:zh_CN@~] 闭包类型的对应成员
  };
}
[codeblock:end]
[exit:example]

[para]
[:en]
An entity is [+captured by reference [% captured [!by reference]]] if it is
implicitly or explicitly captured but not captured by copy.
[:zh_CN]
如果某个实体被隐式或显式捕获，但不是被复制捕获，则它被[+引用捕获 [%捕获
[!引用～]]]。

[:en]
It is unspecified whether additional unnamed non-static data members are
declared in the closure type for entities captured by reference.
[:zh_CN]
是否为被引用捕获的实体在闭包类型中声明额外的无名静态数据成员是未指明的。

[:en]
If declared, such non-static data members shall be of literal types.
[:zh_CN]
如果声明了这种非静态数据成员，则其应当具有字面量类型。

[enter:example]
[codeblock]
// [:en] The inner closure type must be a literal type regardless of how reference captures are represented.
// [|:zh_CN] 内部的闭包类型必须为字面量类型，而不管引用捕获是如何被表示的。
static_assert([](int n) { return [&n] { return ++n; }(); }(3) == 4);
[codeblock:end]
[exit:example]

[:en]
A bit-field or a member of an anonymous union shall not be captured by
reference.
[:zh_CN]
不能引用捕获位字段或者匿名联合的成员。

[para]
[:en]
An [~id-expression] within the [~compound-statement] of a [~lambda-expression]
that is an odr-use of a reference captured by reference refers to the entity to
which the captured reference is bound and not to the captured reference.
[:zh_CN]
[~lambda-表达式]的[~组合语句]中，ODR 式使用某个被按引用捕获的引用的[~标识表达式]
，所指代的是被捕获的引用所绑定的实体而不是被捕获的引用自身。

[enter:note]
[:en]
The validity of such captures is determined by the lifetime of the object to
which the reference refers, not by the lifetime of the reference itself.
[:zh_CN]
这种捕获的有效性，是通过该引用所指代的对象的生存期所决定，而不是引用自身的生存期
所决定。
[exit:note]

[enter:example]
[codeblock]
auto h(int &r) {
  return [&] {
    ++r;            // [:en] Valid after [`h] returns if the lifetime of the
                    // [|:zh_CN] [`h] 返回之后，当 [`r] 所绑定的
                    // [:en@~] object to which [`r] is bound has not ended
                    // [|:zh_CN@~] 对象的生存期尚未结束时保持有效
  };
}
[codeblock:end]
[exit:example]

[para]
[:en]
If a [~lambda-expression] [`m2] captures an entity and that entity is captured
by an immediately enclosing [~lambda-expression] [`m1], then [`m2][=']s capture
is transformed as follows:
[:zh_CN]
若 [~lambda-表达式] [`m2] 捕获某个实体，且该实体被其直接外围 [~lambda-表达式]
[`m1] 所捕获，则对 [`m2] 的捕获进行下述变换：

[list]
[item]
[:en@~]
if [`m1] captures the entity by copy, [`m2] captures the corresponding
non-static data member of [`m1][=']s closure type;
[:zh_CN@~]
若 [`m1] 复制捕获该实体，则 [`m2] 捕获 [`m1] 的闭包类型的对应非静态数据成员；

[item]
[:en@~]
if [`m1] captures the entity by reference, [`m2] captures the same entity
captured by [`m1].
[:zh_CN@~]
若 [`m1] 引用捕获该实体，则 [`m2] 捕获 [`m1] 所捕获的相同实体。
[list:end]

[enter:example]
[:en]
The nested lambda expressions and invocations below will output [`123234].
[:zh_CN]
下述的嵌套 lambda 表达式及其调用将会输出 [`123234]。

[codeblock]
int a = 1, b = 1, c = 1;
auto m1 = [a, &b, &c]() mutable {
  auto m2 = [a, b, &c]() mutable {
    std::cout << a << b << c;
    a = 4; b = 4; c = 4;
  };
  a = 3; b = 3; c = 3;
  m2();
};
a = 2; b = 2; c = 2;
m1();
std::cout << a << b << c;
[codeblock:end]
[exit:example]

[para]
[:en]
When the [~lambda-expression] is evaluated, the entities that are captured by
copy are used to direct-initialize each corresponding non-static data member of
the resulting closure object, and the non-static data members corresponding to
the [~init-capture]s are initialized as indicated by the corresponding
[~initializer] (which may be copy- or direct-initialization).
[:zh_CN]
当求值 [~lambda-表达式]时，用其所复制捕获的实体对所产生的闭包对象中的每个对应的
非静态数据成员进行直接初始化，而对应于[~带初始化捕获符]的非静态数据成员由其对应
[~初始化式]所初始化（可能为复制初始化或者直接初始化）。

[:en]
(For array members, the array elements are direct-initialized in increasing
subscript order.)
[:zh_CN]
（对于数组成员，以下标增长顺序对数组成员进行直接初始化。）

[:en]
These initializations are performed in the (unspecified) order in which the
non-static data members are declared.
[:zh_CN]
这些初始化，是以非静态数据成员的（未指明的）声明顺序进行的。

[enter:note]
[:en]
This ensures that the destructions will occur in the reverse order of the
constructions.
[:zh_CN]
这保证了其析构将以其构造的相反顺序发生。
[exit:note]

[para]
[enter:note]
[:en]
If a non-reference entity is implicitly or explicitly captured by reference,
invoking the function call operator of the corresponding [~lambda-expression]
after the lifetime of the entity has ended is likely to result in undefined
behavior.
[:zh_CN]
若某个非引用实体被隐式或显式地引用捕获，则在该实体的生存期结束之后，调用对应的
[~lambda-表达式]的函数调用运算符，将会导致未定义行为。
[exit:note]

[para]
[:en]
A [~simple-capture] followed by an ellipsis is a pack expansion
([#temp.variadic]).
[:zh_CN]
后面跟着省略号的[~简单捕获符]是包组展开式（[#temp.variadic]）。

[:en]
[%[~init-capture] pack]
An [~init-capture] preceded by an ellipsis is a pack expansion that introduces
an [~init-capture] pack ([#temp.variadic]) whose declarative region is the
[~lambda-expression][=']s [~compound-statement].
[:zh_CN]
[%[~带初始化捕获符]包组]
前面跟着省略号的[~带初始化捕获符]是包组展开式并引入一个[~带初始化捕获符]包组
（[#temp.variadic]），其声明区为该 [~lambda-表达式]的[~组合语句]。

[enter:example]
[codeblock]
template<class... Args>
void f(Args... args) {
  auto lm = [&, args...] { return g(args...); };
  lm();

  auto lm2 = [...xs=std::move(args)] { return g(xs...); };
  lm2();
}
[codeblock:end]
[exit:example]
