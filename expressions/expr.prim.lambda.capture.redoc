[section#expr.prim.lambda.capture
    [:en] Captures
    [:zh_CN] 捕获式
]

[syntax]
[rule lambda-capture [:zh_CN] lambda-捕获式 ]
    [| capture-default ]
    [| capture-list ]
    [| capture-default [`,] capture-list ]
[rule:end]

[rule capture-default [:zh_CN] 默认捕获符 ]
    [| [`&] ]
    [| [`=] ]
[rule:end]

[rule capture-list [:zh_CN] 捕获符列表 ]
    [| capture [`:opt ...] ]
    [| capture-list [`,] capture [`:opt ...] ]
[rule:end]

[rule capture [:zh_CN] 捕获符 ]
    [| simple-capture ]
    [| init-capture ]
[rule:end]

[rule simple-capture [:zh_CN] 简单捕获符 ]
    [| identifier ]
    [| [`&] identifier ]
    [| [`this] ]
    [| [`* this] ]
[rule:end]

[rule init-capture [:zh_CN] 带初始化捕获符 ]
    [| identifier initializer ]
    [| [`&] identifier initializer ]
[rule:end]
[syntax:end]

[para]
[:en]
The body of a [~lambda-expression] may refer to variables with automatic storage
duration and the [`*this] object (if any) of enclosing block scopes by capturing
those entities, as described below.
[:zh_CN]
[~lambda-表达式]的函数体可能会通过对外围块作用域中的具有自动存储期的变量和
[`*this] 对象（如果有）进行捕获而涉指这些实体，如下所述。

[para]
[:en]
If a [~lambda-capture] includes a [~capture-default] that is [`&], no identifier
in a [~simple-capture] of that [~lambda-capture] shall be preceded by [`&].
[:zh_CN]
如果 [~lambda-捕获式]中包含的[~默认捕获符]是 [`&]，则在 [~lambda-捕获式]的
[~简单捕获符]之中的标识符前面不应当有 [`&]。

[:en]
If a [~lambda-capture] includes a [~capture-default] that is [`=], each
[~simple-capture] of that [~lambda-capture] shall be of the form ["[`&]
[~identifier]], ["[`this]], or ["[`* this]].
[:zh_CN]
如果 [~lambda-捕获式]中包含的[~默认捕获符]是 [`=]，则 [~lambda-捕获式]中的每个
[~简单捕获符]都应当具有“[`&] [~标识符]”，“[`this]”，或“[`* this]”的形式。

[enter:note]
[:en]
The form [``[&,this`]] is redundant but accepted for compatibility with ISO
[=CppXIV].
[:zh_CN]
[``[&,this`]] 的形式是多余的，但为保持和 ISO [=CppXIV] 的兼容性而接受。
[exit:note]

[:en]
Ignoring appearances in [~initializer]s of [~init-capture]s, an identifier or
[`this] shall not appear more than once in a [~lambda-capture].
[:zh_CN]
除[~带初始化捕获符]中出现的[~标识符]之外，在一个 [~lambda-捕获式] 之中，标识符
或者 [`this] 不能多次出现。

[enter:example]
[codeblock]
struct S2 { void f(int i); };
void S2::f(int i) {
  [&, i]{ };        // OK
  [&, this, i]{ };  // [:en] OK, equivalent to [``[&, i`]]
                    // [|:zh_CN] OK，等价于 [``[&, i`]]
  [&, &i]{ };       // [:en] error: [`i] preceded by [`&] when [`&] is the default
                    // [|:zh_CN] 错误：当 [`&] 为默认时 [`i] 之前带有 [`&]
  [=, *this]{ };    // OK
  [=, this]{ };     // [:en] OK: equivalent to [``[=`]]
                    // [|:zh_CN] OK：等价于 [``[=`]]
  [i, i]{ };        // [:en] error: [`i] repeated
                    // [|:zh_CN] 错误：重复了 [`i]
  [this, *this]{ }; // [:en] error: [`this] appears twice
                    // [|:zh_CN] 错误：[`this] 出现了两次
}
[codeblock:end]
[exit:example]

[para]
[:en]
A [~lambda-expression] whose smallest enclosing scope is a block scope
([#basic.scope.block]) is a [+local lambda expression]; any other
[~lambda-expression] shall not have a [~capture-default] or [~simple-capture] in
its [~lambda-introducer].
[:zh_CN]
最小的外围作用域是块作用域（[#basic.scope.local]）的 [~lambda-表达式]是[+局部
lambda 表达式]；任何其他 [~lambda-表达式]的 [~lambda-引导符]中都不能包含[~默认
捕获符]或[~简单捕获符]。

[:en]
The [+reaching scope] of a local lambda expression is the set of enclosing
scopes up to and including the innermost enclosing function and its parameters.
[:zh_CN]
局部 lambda 表达式的[+可达作用域]，为其外围作用域的集合，直到并包括其最内层外围
函数及其形参。

[enter:note]
[:en]
This reaching scope includes any intervening [~lambda-expression]s.
[:zh_CN]
可达作用域中包括介于其间的任意 [~lambda-表达式]。
[exit:note]

[para]
[:en]
The [~identifier] in a [~simple-capture] is looked up using the usual rules for
unqualified name lookup ([#basic.lookup.unqual]); each such lookup shall find an
entity.
[:zh_CN]
使用未限定名查找的常规规则对[~简单捕获符]中的[~标识符]进行查找
（[#basic.lookup.unqual]）；每次这种查找都应当找到该局部 lambda 表达式的可达作用
域中的某个具有自动存储期的变量。

[:en]
An entity that is designated by a [~simple-capture] is said to be [+explicitly
captured], and shall be [`*this] (when the [~simple-capture] is ["[`this]] or
["[`* this]]) or a variable with automatic storage duration declared in the
reaching scope of the local lambda expression.
[:zh_CN]
由[~简单捕获符]所代表的实体称为被[+显式捕获]，且应当为 [`*this]（当其[~简单捕获
符]为“[`this]”或“[`* this]”时），或者为某个声明于该局部 lambda 表达式的可达
作用域之中的具有自动存储期的变量。

[para]
[:en]
If an [~identifier] in a [~simple-capture] appears as the [~declarator-id] of a
parameter of the [~lambda-declarator][=']s [~parameter-declaration-clause], the
program is ill-formed.
[:zh_CN]
如果[~简单捕获符]中的某个[~标识符]被用作该[~lambda-声明符]的[~形参声明式子句]的
某个形参的[~声明符标识]，则程序非良构。

[enter:example]
[codeblock]
void f() {
  int x = 0;
  auto g = [x](int x) { return 0; }    // [:en] error: parameter and [~simple-capture] have the same name
                                       // [|:zh_CN] 错误：形参和[~简单捕获符]的名字相同
}
[codeblock:end]
[exit:example]

[para]
[:en]
An [~init-capture] behaves as if it declares and explicitly captures a variable
of the form ["[`auto] [~init-capture] [`;]] whose declarative region is the
[~lambda-expression][=']s [~compound-statement], except that:
[:zh_CN]
[~带初始化捕获符]表现为如同它声明并显式捕获某个形式为“[`auto] [~带初始化捕获符]
[`;]”的变量，其声明区为该[~lambda-表达式]的[~组合语句]，但是：

[list]
[item]
[:en]
if the capture is by copy (see below), the non-static data member declared for
the capture and the variable are treated as two different ways of referring to
the same object, which has the lifetime of the non-static data member, and no
additional copy and destruction is performed, and
[:zh_CN]
若该捕获式为复制捕获（见下文），则为该捕获式声明的非静态数据成员和这个变量被当作
指代相同对象的两个不同方式，具有非静态数据成员的生存期，并且不进行其他复制和销毁
操作，并且

[item]
[:en]
if the capture is by reference, the variable[=']s lifetime ends when the closure
object[=']s lifetime ends.
[:zh_CN]
若该捕获式为引用捕获，则该变量的生存期在闭包对象的生存期结束时结束。
[list:end]

[enter:note]
[:en]
This enables an [~init-capture] like ["[`x = std::move(x)]]; the second ["[`x]]
must bind to a declaration in the surrounding context.
[:zh_CN]
这样就允许[~带初始化捕获符]“[`x = std::move(x)]”；其第二个“[`x]”必须绑定到其外围
语境中的某个声明式。
[exit:note]

[enter:example]
[codeblock]
int x = 4;
auto y = [&r = x, x = x+1]()->int {
            r += 2;
            return x+2;
         }();  // [:en] Updates [`::x] to 6, and initializes [`y] to 7.
               // [|:zh_CN] 更新 [`::x] 为 6，并初始化 [`y] 为 7。

auto z = [a = 42](int a) { return 1; } // [:en] error: parameter and local variable have the same name
                                       // [|:zh_CN] 错误：形参和局部变量的名字相同
[codeblock:end]
[exit:example]

[para]
[:en]
A [~lambda-expression] with an associated [~capture-default] that does not
explicitly capture [`*this] or a variable with automatic storage duration (this
excludes any [~id-expression] that has been found to refer to an
[~init-capture][=']s associated non-static data member), is said to
[%implicit capture[!definition of]] [+implicitly capture [%capture[!implicit]]]
the entity (i.e., [`*this] or a variable) if the [~compound-statement]:
[:zh_CN]
当关联了[~默认捕获符]的[~lambda-表达式]，并未明确捕获 [`*this] 或者具有自动存储
期的变量（这不包括任何被发现指代某个[~带初始化捕获符]所关联的非静态数据成员的
[~标识表达式]），且其[~组合语句]符合如下情况时，称其[%隐式捕获[!～的定义]]
[+隐式捕获[%捕获[!隐式～]]]该实体（亦即 [`*this] 或者变量）：

[list]
[item]
[:en@~]
odr-uses ([#basic.def.odr]) the entity (in the case of a variable),
[:zh_CN@~]
ODR 式使用（[#basic.def.odr]）了该实体（当其为变量的情况），

[item]
[:en@~]
odr-uses ([#basic.def.odr]) [`this] (in the case of the object designated by
[`*this]), or
[:zh_CN@~]
ODR 式使用（[#basic.def.odr]）了 [`this]（当其为由 [`*this] 所代表的对象的情况）
，或者

[item]
[:en@~]
names the entity in a potentially-evaluated expression ([#basic.def.odr]) where
the enclosing full-expression depends on a generic lambda parameter declared
within the reaching scope of the [~lambda-expression].
[:zh_CN@~]
在潜在求值表达式（[#basic.def.odr]）中涉及该实体，包含它的全表达式依赖于该
[~lambda-表达式]的可达作用域中所声明的某个泛型 lambda 形参。
[list:end]

[enter:example]
[codeblock]
void f(int, const int (&)[2] = {})    { }   // #1
void f(const int&, const int (&)[1])  { }   // #2
void test() {
  const int x = 17;
  auto g = [](auto a) {
    f(x);                       // [:en] OK: calls #1, does not capture [`x]
                                // [|:zh_CN] OK：调用 #1，并未捕获 [`x]
  };

  auto g2 = [=](auto a) {
    int selector[sizeof(a) == 1 ? 1 : 2]{};
    f(x, selector);             // [:en] OK: is a dependent expression, so captures [`x]
                                // [|:zh_CN] OK：这是待决表达式，并捕获 [`x]
  };
}
[codeblock:end]
[exit:example]

[:en]
All such implicitly captured entities shall be declared within the reaching
scope of the lambda expression.
[:zh_CN]
所有这些隐式捕获的实体应当在该 lambda 表达式的可达作用域中进行了声明。

[enter:note]
[:en]
The implicit capture of an entity by a nested [~lambda-expression] can cause its
implicit capture by the containing [~lambda-expression] (see below).
[:zh_CN]
在嵌套的 [~lambda-表达式]中对某个实体进行隐式捕获，会造成在包含它的 [~lambda-表
达式]中对其隐式捕获（见下文）。

[:en]
Implicit odr-uses of [`this] can result in implicit capture.
[:zh_CN]
对 [`this] 进行隐含的 ODR 式使用会造成隐式捕获。
[exit:note]

[para]
[:en]
An entity is [+captured] if it is captured explicitly or implicitly.
[:zh_CN]
若某个实体被显式或隐式捕获，则它被[+捕获]。

[:en]
An entity captured by a [~lambda-expression] is odr-used ([#basic.def.odr]) in
the scope containing the [~lambda-expression].
[:zh_CN]
由某个 [~lambda-表达式]所捕获的实体，是在包含该 [~lambda-表达式]的作用域中被
ODR 式使用的（[#basic.def.odr]）。
    
[:en]
If [`*this] is captured by a local lambda expression, its nearest enclosing
function shall be a non-static member function.
[:zh_CN]
若某个局部 lambda 表达式捕获了 [`*this]，则其最内层外围函数应当是一个非静态成员
函数。

[:en]
If a [~lambda-expression] or an instantiation of the function call operator
template of a generic lambda odr-uses ([#basic.def.odr]) [`this] or a variable
with automatic storage duration from its reaching scope, that entity shall be
captured by the [~lambda-expression].
[:zh_CN]
若某个 [~lambda-表达式]或某个泛型 lambda 的函数调用运算符模板的实例化中，ODR 式
使用（[#basic.def.odr]）了 [`this]，或其可达作用域中的某个具有自动存储期的变量，
则该实体应当被这个 [~lambda-表达式]所捕获。

[:en]
If a [~lambda-expression] captures an entity and that entity is not defined or
captured in the immediately enclosing lambda expression or function, the program
is ill-formed.
[:zh_CN]
如果 [~lambda-表达式]捕获了某个实体，而该实体并未在其直接外围 lambda 表达式或
函数中定义或捕获，则程序非良构。

[enter:example]
[%Bond[!James Bond]]
[codeblock]
void f1(int i) {
  int const N = 20;
  auto m1 = [=]{
    int const M = 30;
    auto m2 = [i]{
      int x[N][M];              // [:en] OK: [`N] and [`M] are not odr-used
                                // [|:zh_CN] OK：[`N] 和 [`M] 未被 ODR 式使用
      x[0][0] = i;              // [:en] OK: [`i] is explicitly captured by [`m2] and implicitly captured by [`m1]
                                // [|:zh_CN] OK：[`i] 由 [`m2] 显式捕获并由 [`m1] 所隐式捕获
    };
  };
  struct s1 {
    int f;
    void work(int n) {
      int m = n*n;
      int j = 40;
      auto m3 = [this,m] {
        auto m4 = [&,j] {       // [:en] error: [`j] not captured by [`m3]
                                // [|:zh_CN] 错误：[`j] 未被 [`m3] 捕获
          int x = n;            // [:en] error: [`n] implicitly captured by [`m4] but not captured by [`m3]
                                // [|:zh_CN] 错误：[`n] 被 [`m4] 隐式捕获但未被 [`m3] 所捕获
          x += m;               // [:en] OK: [`m] implicitly captured by [`m4] and explicitly captured by [`m3]
                                // [|:zh_CN] OK：[`m] 被 [`m4] 隐式捕获并被 [`m3] 显式捕获
          x += i;               // [:en] error: [`i] is outside of the reaching scope
                                // [|:zh_CN] 错误：[`i] 不在可达作用域中
          x += f;               // [:en] OK: [`this] captured implicitly by [`m4] and explicitly by [`m3]
                                // [|:zh_CN] OK：[`this] 被 [`m4] 隐式捕获并被 [`m3] 显式捕获
        };
      };
    }
  };
}

struct s2 {
  double ohseven = .007;
  auto f() {
    return [this] {
      return [*this] {
          return ohseven;       // OK
      }
    }();
  }
  auto g() {
    return [] {
      return [*this] { };       // [:en] error: [`*this] not captured by outer [~lambda-expression]
                                // [|:zh_CN] 错误：[`*this] 并未被外围的 [~lambda-表达式]所捕获
    }();
  }
};
[codeblock:end]
[exit:example]

[para]
[:en]
A [~lambda-expression] appearing in a default argument shall not implicitly or
explicitly capture any entity.
[:zh_CN]
出现于默认实参中的 [~lambda-表达式]，不应隐式或显式捕获任何实体。

[enter:example]
[codeblock]
void f2() {
  int i = 1;
  void g1(int = ([i]{ return i; })());          // [:en] ill-formed
                                                // [|:zh_CN] 非良构
  void g2(int = ([i]{ return 0; })());          // [:en] ill-formed
                                                // [|:zh_CN] 非良构
  void g3(int = ([=]{ return i; })());          // [:en] ill-formed
                                                // [|:zh_CN] 非良构
  void g4(int = ([=]{ return 0; })());          // OK
  void g5(int = ([]{ return sizeof i; })());    // OK
}
[codeblock:end]
[exit:example]

[para]
[:en]
An entity is [+captured by copy [%captured [!by copy]]] if
[:zh_CN]
以下情况下实体被[+复制捕获[%捕获[!复制～]]]：

[list]
[item]
[:en]
it is implicitly captured, the [~capture-default] is [`=], and the captured
entity is not [`*this], or
[:zh_CN]
它被隐式捕获，其[~默认捕获符]是 [`=]，且所捕获的实体不是 [`*this]，或者

[item]
[:en]
it is explicitly captured with a capture that is not of the form [`this],
[`&] [~identifier], or [`&] [~identifier] [~initializer].
[:zh_CN]
它被显式捕获，其捕获式不具有“[`this]”，“[`&] [~标识符]”，或
“[`&] [~标识符] [~初始化式]”的形式。
[list:end]

[:en]
For each entity captured by copy, an unnamed non-static data member is declared
in the closure type.
[:zh_CN]
对于每个复制捕获的实体，在闭包类型中都声明了一个无名的非静态数据成员。

[:en]
The declaration order of these members is unspecified.
[:zh_CN]
这些成员的声明顺序是未指明的。

[:en]
The type of such a data member is the referenced type if the entity is a
reference to an object, an lvalue reference to the referenced function type if
the entity is a reference to function, or the type of the corresponding captured
entity otherwise.
[:zh_CN]
这种数据成员的类型，当实体是对象的引用时为被引用的类型，当实体是函数的引用时为
被引用函数类型的左值引用，否则就是相应被捕获实体的类型。

[:en]
A member of an anonymous union shall not be captured by copy.
[:zh_CN]
匿名联合的成员不能被复制捕获。

[para]
[:en]
Every [~id-expression] within the [~compound-statement] of a
[~lambda-expression] that is an odr-use ([#basic.def.odr]) of an entity captured
by copy is transformed into an access to the corresponding unnamed data member
of the closure type.
[:zh_CN]
[~lambda-表达式]的[~组合语句]中，每个 ODR 式使用（[#basic.def.odr]）被复制捕获的
实体的[~标识表达式]，均被变换为对其闭包类型的对应无名数据成员的访问。

[enter:note]
[:en]
An [~id-expression] that is not an odr-use refers to the original entity, never
to a member of the closure type.
[:zh_CN]
不进行 ODR-式使用的[~标识表达式]，指代原来的实体，而并非指代闭包类型的成员。

[:en]
Furthermore, such an [~id-expression] does not cause the implicit capture of the
entity.
[:zh_CN]
此外，这种[~标识表达式]并不会导致对该实体的隐式捕获。
[exit:note]

[:en]
If [`*this] is captured by copy, each odr-use of [`this] is transformed into a
pointer to the corresponding unnamed data member of the closure type,
cast ([#expr.cast]) to the type of [`this].
[:zh_CN]
当 [`*this] 被复制捕获时，对 [`this] 的每次 ODR 式使用，均被变换为对其闭包类型的
对应无名数据成员的一个指针，并强制转换（[#expr.cast]）为 [`this] 的类型。

[enter:note]
[:en]
The cast ensures that the transformed expression is a prvalue.
[:zh_CN]
这个强制转换保证所变换的表达式是纯右值。
[exit:note]

[:en]
An [~id-expression] within the [~compound-statement] of a [~lambda-expression]
that is an odr-use of a reference captured by reference refers to the entity to
which the captured reference is bound and not to the captured reference.
[:zh_CN]
[~lambda-表达式]的[~组合语句]中的[~标识表达式]，若其为按引用捕获的引用，则它指代
的是其所捕获的引用所绑定的实体，而不是所捕获的引用。

[enter:note]
[:en]
The validity of such captures is determined by the lifetime of the object to
which the reference refers, not by the lifetime of the reference itself.
[:zh_CN]
这种捕获的有效性取决于该引用所指代的对象的生存期，而不是该引用自身的生存期。
[exit:note]

[enter:example]
[codeblock]
void f(const int*);
void g() {
  const int N = 10;
  [=] {
    int arr[N];     // [:en] OK: not an odr-use, refers to automatic variable
                    // [|:zh_CN] OK：不是 ODR-式使用，指代自动变量
    f(&N);          // [:en] OK: causes [`N] to be captured; [`&N] points to
                    // [|:zh_CN] OK：导致 [`N] 被捕获；[`&N] 指向
                    // [:en@~] the corresponding member of the closure type
                    // [|:zh_CN@~] 闭包类型的对应成员
  };
}
auto h(int &r) {
  return [&] {
    ++r;            // [:en] Valid after [`h] returns if the lifetime of the
                    // [|:zh_CN] [`h] 返回之后，当 [`r] 所绑定的
                    // [:en@~] object to which [`r] is bound has not ended
                    // [|:zh_CN@~] 对象的生存期尚未结束时保持有效
  };
}
[codeblock:end]
[exit:example]

[para]
[:en]
An entity is [+captured by reference [% captured [!by reference]]] if it is
implicitly or explicitly captured but not captured by copy.
[:zh_CN]
如果某个实体被隐式或显式捕获，但不是被复制捕获，则它被[+引用捕获 [%捕获
[!引用～]]]。

[:en]
It is unspecified whether additional unnamed non-static data members are
declared in the closure type for entities captured by reference.
[:zh_CN]
是否为被引用捕获的实体在闭包类型中声明额外的无名静态数据成员是未指明的。

[:en]
If declared, such non-static data members shall be of literal types.
[:zh_CN]
如果声明了这种非静态数据成员，则其应当具有字面量类型。

[enter:example]
[codeblock]
// [:en] The inner closure type must be a literal type regardless of how reference captures are represented.
// [|:zh_CN] 内部的闭包类型必须为字面量类型，而不管引用捕获是如何被表示的。
static_assert([](int n) { return [&n] { return ++n; }(); }(3) == 4);
[codeblock:end]
[exit:example]

[:en]
A bit-field or a member of an anonymous union shall not be captured by
reference.
[:zh_CN]
不能引用捕获位字段或者匿名联合的成员。

[para]
[:en]
If a [~lambda-expression] [`m2] captures an entity and that entity is captured
by an immediately enclosing [~lambda-expression] [`m1], then [`m2][=']s capture
is transformed as follows:
[:zh_CN]
若 [~lambda-表达式] [`m2] 捕获某个实体，且该实体被其直接外围 [~lambda-表达式]
[`m1] 所捕获，则对 [`m2] 的捕获进行下述变换：

[list]
[item]
[:en@~]
if [`m1] captures the entity by copy, [`m2] captures the corresponding
non-static data member of [`m1][=']s closure type;
[:zh_CN@~]
若 [`m1] 复制捕获该实体，则 [`m2] 捕获 [`m1] 的闭包类型的对应非静态数据成员；

[item]
[:en@~]
if [`m1] captures the entity by reference, [`m2] captures the same entity
captured by [`m1].
[:zh_CN@~]
若 [`m1] 引用捕获该实体，则 [`m2] 捕获 [`m1] 所捕获的相同实体。
[list:end]

[enter:example]
[:en]
The nested lambda expressions and invocations below will output [`123234].
[:zh_CN]
下述的嵌套 lambda 表达式及其调用将会输出 [`123234]。

[codeblock]
int a = 1, b = 1, c = 1;
auto m1 = [a, &b, &c]() mutable {
  auto m2 = [a, b, &c]() mutable {
    std::cout << a << b << c;
    a = 4; b = 4; c = 4;
  };
  a = 3; b = 3; c = 3;
  m2();
};
a = 2; b = 2; c = 2;
m1();
std::cout << a << b << c;
[codeblock:end]
[exit:example]

[para]
[:en]
Every occurrence of [`decltype((x))] where [`x] is a possibly parenthesized
[~id-expression] that names an entity of automatic storage duration is treated
as if [`x] were transformed into an access to a corresponding data member of the
closure type that would have been declared if [`x] were an odr-use of the
denoted entity.
[:zh_CN]
若 [`x] 为可能带有括号的[~标识表达式]，并指名某个自动存储期的实体，则每个
[`decltype((x))] 均被当作如同：当 [`x] 为对其所代表的实体的 ODR 式使用时，将
[`x] 变换为对所应声明的闭包类型的对应数据成员的访问。

[enter:example]
[codeblock]
void f3() {
  float x, &r = x;
  [=] {                     // [:en] [`x] and [`r] are not captured (appearance in a [`decltype] operand is not an odr-use)
                            // [|:zh_CN] [`x] 和 [`r] 并未被捕获（出现在 [`decltype] 的操作数中并非 ODR 式使用）
    decltype(x) y1;         // [:en] [`y1] has type [`float]
                            // [|:zh_CN] [`y1] 的类型为 [`float]
    decltype((x)) y2 = y1;  // [:en] [`y2] has type [`float const&] because this lambda is not [`mutable] and [`x] is an lvalue
                            // [|:zh_CN] [`y2] 的类型为 [`float const&]，这是由于该 lambda 不是 [`mutable] 而且 [`x] 是左值
    decltype(r) r1 = y1;    // [:en] [`r1] has type [`float&] (transformation not considered)
                            // [|:zh_CN] [`r1] 的类型为 [`float&]（不须变换）
    decltype((r)) r2 = y2;  // [:en] [`r2] has type [`float const&]
                            // [|:zh_CN] [`r2] 的类型为 [`float const&]
  };
}
[codeblock:end]
[exit:example]

[para]
[:en]
When the [~lambda-expression] is evaluated, the entities that are captured by
copy are used to direct-initialize each corresponding non-static data member of
the resulting closure object, and the non-static data members corresponding to
the [~init-capture]s are initialized as indicated by the corresponding
[~initializer] (which may be copy- or direct-initialization).
[:zh_CN]
当求值 [~lambda-表达式]时，用其所复制捕获的实体对所产生的闭包对象中的每个对应的
非静态数据成员进行直接初始化，而对应于[~带初始化捕获符]的非静态数据成员由其对应
[~初始化式]所初始化（可能为复制初始化或者直接初始化）。

[:en]
(For array members, the array elements are direct-initialized in increasing
subscript order.)
[:zh_CN]
（对于数组成员，以下标增长顺序对数组成员进行直接初始化。）

[:en]
These initializations are performed in the (unspecified) order in which the
non-static data members are declared.
[:zh_CN]
这些初始化，是以非静态数据成员的（未指明的）声明顺序进行的。

[enter:note]
[:en]
This ensures that the destructions will occur in the reverse order of the
constructions.
[:zh_CN]
这保证了其析构将以其构造的相反顺序发生。
[exit:note]

[para]
[enter:note]
[:en]
If a non-reference entity is implicitly or explicitly captured by reference,
invoking the function call operator of the corresponding [~lambda-expression]
after the lifetime of the entity has ended is likely to result in undefined
behavior.
[:zh_CN]
若某个非引用实体被隐式或显式地引用捕获，则在该实体的生存期结束之后，调用对应的
[~lambda-表达式]的函数调用运算符，将会导致未定义行为。
[exit:note]

[para]
[:en]
A [~simple-capture] followed by an ellipsis is a pack expansion
([#temp.variadic]).
[:zh_CN]
后面跟着省略号的[~简单捕获符]是包组展开式（[#temp.variadic]）。

[:en]
An [~init-capture] followed by an ellipsis is ill-formed.
[:zh_CN]
后面跟着省略号的[~带初始化捕获符]非良构。

[enter:example]
[codeblock]
template<class... Args>
void f(Args... args) {
  auto lm = [&, args...] { return g(args...); };
  lm();
}
[codeblock:end]
[exit:example]
