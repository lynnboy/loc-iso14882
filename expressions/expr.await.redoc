[section#expr.await
    [:en] Await
    [:zh_CN] 等待
]

[%  [:en] expression[!await]
    [:zh_CN] 表达式[!等待]]
[%[`co_await]]

[para]
[:en]
The [`co_await] expression is used to suspend evaluation of a coroutine
([#dcl.fct.def.coroutine]) while awaiting completion of the computation
represented by the operand expression.

[syntax]
[rule await-expression [:zh_CN] 等待表达式 ]
    [| [`co_await] cast-expression ]
[rule:end]
[syntax:end]

[para]
[:en]
An [~await-expression] shall appear only in a potentially-evaluated expression
within the [~compound-statement] of a [~function-body] outside of a [~handler]
([#except]).

[:en]
In a [~declaration-statement] or in the [~simple-declaration] (if any) of a
[~for-init-statement], an [~await-expression] shall appear only in an
[~initializer] of that [~declaration-statement] or [~simple-declaration].

[:en]
An [~await-expression] shall not appear in a default argument
([#dcl.fct.default]).

[:en]
An [~await-expression] shall not appear in the initializer of a block-scope
variable with static or thread storage duration.

[:en]
A context within a function where an [~await-expression] can appear is called a
[+suspension context[%]] of the function.

[para]
[:en]
Evaluation of an [~await-expression] involves the following auxiliary types,
expressions, and objects:

[list]
[item]
[:en]
[*p] is an lvalue naming the promise object ([#dcl.fct.def.coroutine]) of the
enclosing coroutine and [`P] is the type of that object.

[item]
[:en]
[*a] is the [~cast-expression] if the [~await-expression] was implicitly
produced by a [~yield-expression] ([#expr.yield]), an initial suspend point,
or a final suspend point ([#dcl.fct.def.coroutine]).

[:en]
Otherwise, the [~unqualified-id] [`await_transform] is looked up within the
scope of [`P] by class member access lookup ([#basic.lookup.classref]), and if
this lookup finds at least one declaration, then [*a] is
[*p][`.await_transform(][~cast-expression][`)]; otherwise, [*a] is the
[~cast-expression].

[item]
[:en]
[*o] is determined by enumerating the applicable [`operator co_await] functions
for an argument [*a] ([#over.match.oper]), and choosing the best one through
overload resolution ([#over.match]).

[:en]
If overload resolution is ambiguous, the program is ill-formed.

[:en]
If no viable functions are found, [*o] is [*a].

[:en]
Otherwise, [*o] is a call to the selected function with the argument [*a].

[:en]
If [*o] would be a prvalue, the temporary materialization conversion
([#conv.rval]) is applied.

[item]
[:en]
[*e] is an lvalue referring to the result of evaluating the (possibly-converted)
[*o].

[item]
[/% FIXME: h needs to be an expression so we can use it as an argument
% to await_suspend. What should its value category be?
% Don't forget to remove "and objects" from the intro sentence when
% this is fixed./]
[:en]
[*h] is an object of type [`std::coroutine_handle<P>] referring to the enclosing
coroutine.

[item]
[:en]
[*await-ready] is the expression [*e][`.await_ready()], contextually converted
to [`bool].

[item]
[:en]
[*await-suspend] is the expression [*e][`.await_suspend(][*h][`)], which shall
be a prvalue of type [`void], [`bool], or [`std::coroutine_handle<Z>] for some
type [`Z].

[item]
[:n]
[*await-resume] is the expression [*e][`.await_resume()].
[list:end]

[para]
[:en]
The [~await-expression] has the same type and value category as the
[*await-resume] expression.

[para]
[:en]
The [~await-expression] evaluates the (possibly-converted) [*o] expression and
the [*await-ready] expression, then:

[list]
[item]
[:en]
If the result of [*await-ready] is [`false], the coroutine is considered
suspended.

[:en]
Then:

[list]
[item]
[:en]
If the type of [*await-suspend] is [`std::coroutine_handle<Z>],
[*await-suspend][`.resume()] is evaluated.

[enter:note]
[:en]
This resumes the coroutine referred to by the result of [*await-suspend].

[:en]
Any number of coroutines may be successively resumed in this fashion, eventually
returning control flow to the current coroutine caller or resumer
([#dcl.fct.def.coroutine]).
[exit:note]

[item]
[:en]
Otherwise, if the type of [*await-suspend] is [`bool], [*await-suspend] is
evaluated, and the coroutine is resumed if the result is [`false].

[item]
[:en]
Otherwise, [*await-suspend] is evaluated.
[list:end]

[:en]
If the evaluation of [*await-suspend] exits via an exception, the exception is
caught, the coroutine is resumed, and the exception is immediately re-thrown
([#except.throw]).

[:en]
Otherwise, control flow returns to the current coroutine caller or resumer
([#dcl.fct.def.coroutine]) without exiting any scopes ([#stmt.jump]).

[item]
[:en]
If the result of [*await-ready] is [`true], or when the coroutine is resumed,
the [*await-resume] expression is evaluated, and its result is the result of the
[~await-expression].
[list:end]

[para]
[enter:example]
[codeblock]
template <typename T>
struct my_future {
  /* ... */
  bool await_ready();
  void await_suspend(std::coroutine_handle<>);
  T await_resume();
};

template <class Rep, class Period>
auto operator co_await(std::chrono::duration<Rep, Period> d) {
  struct awaiter {
    std::chrono::system_clock::duration duration;
    /* ... */
    awaiter(std::chrono::system_clock::duration d) : duration(d) {}
    bool await_ready() const { return duration.count() <= 0; }
    void await_resume() {}
    void await_suspend(std::coroutine_handle<> h) { /* ... */ }
  };
  return awaiter{d};
}

using namespace std::chrono;

my_future<int> h();

my_future<void> g() {
  std::cout << "just about go to sleep...\n";
  co_await 10ms;
  std::cout << "resumed\n";
  co_await h();
}

auto f(int x = co_await h());   // [:en] error: [~await-expression] outside of function suspension context
int a[] = { co_await h() };     // [:en] error: [~await-expression] outside of function suspension context

[codeblock:end]
[exit:example]
