[section#lex.phases
    [:en] Phases of translation
    [:zh_CN] 翻译的阶段
]

[%:begin#translation.phases
    [:en] translation [!phases]
    [:zh_CN] 翻译 [!阶段]
]

[para]
[:en] The precedence among the syntax rules of translation is specified by the
following phases.[#:fn]
[:zh_CN] 下列各阶段指定了所翻译的语法规则之间的先后次序[#:fn]。

[note:foot]
[:en] Implementations behave as if these separate phases occur, although in
practice different phases can be folded together.
[:zh_CN] 实现应当表现为如同这些阶段是分别发生的，但实际上可以将不同的阶段合并进行。
[note:end]

[list:ol@ndot]
[item]
[:en] [%character[!source file]]
An implementation shall support input files that are a sequence of UTF-8 code
units (UTF-8 files).
[:zh_CN] [%字符[!源文件～]]
实现应当支持 UTF-8 代码单元序列构成的输入文件（UTF-8 文件）。

[:en] It may also support an [?impldef supported input files] set of other kinds
of input files, and, if so, the kind of an input file is determined in an
[?impldef determination of kind of input file] manner that includes a means of
designating input files as UTF-8 files, independent of their content.
[:zh_CN] 实现还可以支持其他种类输入文件的[?impldef 支持的输入文件]集合，并且若是如此，
通过某种[?impldef 确定输入文件的种类]方式确定输入文件的种类，这包括将输入文件
指定为 UTF-8 文件而与文件内容无关的方法。

[begin:note]
[:en] In other words, recognizing the [=unicode(feff,byte order mark)] is not sufficient.
[:zh_CN] 换句话说，仅识别 [=unicode(feff,byte order mark)] 是不够的。
[end:note]

[:en] If an input file is determined to be a UTF-8 file, then it shall be a
well-formed UTF-8 code unit sequence and it is decoded to produce a sequence of
Unicode[#:fn] scalar values.
[:zh_CN] 如果输入文件被确定为 UTF-8 文件，则它应当是良构的 UTF-8 代码单元序列，
并对其解码以产生一个 Unicode[#:fn] 标量值的序列。

[note:foot]
[:en] Unicode[=Reg] is a registered trademark of Unicode, Inc.
[:zh_CN] Unicode[=Reg] 是 Unicode 有限公司的注册商标。

[:en] This information is given for the convenience of users of this document
and does not constitute an endorsement by ISO or IEC of this product.
[:zh_CN] 这条信息是为本文档的用户的便利而提供的，并不构成 ISO 或 IEC 对此产品的宣传。
[note:end]

[:en] A sequence of translation character set elements ([#lex.charset]) is then
formed by mapping each Unicode scalar value to the corresponding translation
character set element.
[:zh_CN] 然后通过将每个 Unicode 标量值映射为对应的翻译字符集元素（[#lex.charset]）
的方式构成翻译字符集元素序列。

[:en] In the resulting sequence, each pair of characters in the input sequence
consisting of [=unicode(000d,carriage return)] followed by [=unicode(000a,line feed)],
as well as each [=unicode(000d,carriage return)] not immediately followed by
a [=unicode(000a,line feed)], is replaced by a single new-line character.
[:zh_CN] 在结果序列中，输入序列中由 [=unicode(000d,carriage return)] 跟着
[=unicode(000a,line feed)] 构成的每对字符，和每个后面并未紧跟 [=unicode(000a,line feed)]
的 [=unicode(000d,carriage return)] 字符，均被替换为单个换行字符。

[para:~]
[:en] For any other kind of input file supported by the implementation, characters
are mapped, in an [?impldef mapping input file characters to translation character set]
manner, to a sequence of translation character set elements,
representing end-of-line indicators as new-line characers.
[:zh_CN] 对于实现支持的任何其他种类的输入文件，以一种[?impldef 将输入文件字符映射到
翻译字符集]方式将各字符映射到一个翻译字符集成员的序列中，其中将行尾指示符表示为换行字符。

[item]
[:en] [%line splicing]
If the first translation character is [=unicode(feff,byte order mark)], it is deleted.
[:zh_CN] [%行接合]
如果第一个翻译字符为 [=unicode(feff,byte order mark)]，则将之删除。

[:en] Each sequence of a backslash character (\) immediately followed by zero or
more whitespace characters other than new-line followed by a new-line character
is deleted, splicing physical source lines to form [+logical source lines[%source line[!logical]]].
[:zh_CN] 删除所有反斜杠字符（\）及其后紧跟的零个或更多除换行之外的空白字符再跟着一个
换行字符所构成的序列，将物理的源文本行接合成[+逻辑源文本行[%源文本行[!逻辑]]]。

[:en] Only the last backslash on any physical source line shall be eligible for
being part of such a splice.
[:zh_CN] 在任何物理源文本行中，只有末尾的反斜杠适用于这种接合。

[begin:note]
[:en] Line splicing can form a [~universal-character-name] ([#lex.charset]).
[:zh_CN] 行接合可能产生[~通用字符名]（[#lex.charset]）。
[end:note]

[:en] A source file that is not empty and that (after splicing) does not end in
a new-line character, or that ends in a splice, shall be processed as if an
additional new-line character were appended to the file.
[:zh_CN] 如果非空的源文件（接合完成后）不以换行字符结尾，或以一个接合结尾，则
对其进行处理时应当如同该文件追加了一个额外的换行字符一样。

[item]
[:en] The source file is decomposed into preprocessing tokens ([#lex.pptoken])
and sequences of whitespace characters (including comments).
[:zh_CN] 将源文件分解为预处理记号（[#lex.pptoken]）和空白字符（包括注释）的序列。

[:en] A source file shall not end in a partial preprocessing token or in a
partial comment.[#:fn]
[:zh_CN] 源文件不应该在不完整的预处理记号或不完整的注释中结束[#:fn]。

[note:foot]
[:en] A partial preprocessing token would arise from a source file ending in the
first portion of a multi-character token that requires a terminating sequence of
characters, such as a [~header-name] that is missing the closing [`"] or [`>].
[:zh_CN] 当源文件在某个需要终结字符序列的多字符记号的前一部分处结束时，就会出现不完整的
预处理记号，比如缺失闭合的 [`"] 或 [`>] 的[~头文件名]。

[:en] A partial comment would arise from a source file ending with an unclosed [`/*] comment.
[:zh_CN] 当源文件在没闭合的 [`/*] 注释中结束时，就会出现不完整的注释。
[note:end]

[:en] Each comment ([#lex.comment]) is replaced by one space character.
[:zh_CN] 把每个注释（[#lex.comment]）都替换为一个空格字符。

[:en] New-line characters are retained.
[:zh_CN] 保留换行字符。

[:en] Whether each nonempty sequence of whitespace characters other than
new-line is retained or replaced by one space character is unspecified.
[:zh_CN] 是否将除换行字符以外的空白字符的非空序列保留或将其替换为一个空格字符是未指明的。

[:en] As characters from the source file are consumed to form the next
preprocessing token (i.e., not being consumed as part of a comment or other forms
of whitespace), except when matching a [~c-char-sequence], [~s-char-sequence],
[~r-char-sequence], [~h-char-sequence], or [~q-char-sequence],
[~universal-character-name]s are recognized ([#lex.universal.char]) and replaced
by the designated element of the translation character set.
[:zh_CN] 从源文件中消耗字符以构成下一个预处理记号（亦即，并非在注释或任何其他形式的
空白中消耗的字符），当所匹配的不是 [~c-字符序列]、[~s-字符序列]、[~r-字符序列]、
[~h-字符序列] 或 [~q-字符序列] 时，[~通用字符名]被识别（[#lex.universal.char]）
并替换为翻译字符集中其所代表的元素。

[:en] The process of dividing a source file[=']s characters into preprocessing
tokens is context-dependent.
[:zh_CN] 将源文件的字符分割成预处理记号的过程是上下文相关的。

[begin:example]
[:en] See the handling of [`<] within a [`#include] preprocessing directive ([#lex.header], [#cpp.include]).
[:zh_CN] 参见 [`#include] 预处理指令中对 [`<] 的处理（[#lex.header]，[#cpp.include]）。
[end:example]

[item]
[:en] The source file is analyzed as a [~preprocessing-file] ([#cpp.pre]).
[:zh_CN] 将源文件作为[~预处理文件]进行分析（[#cpp.pre]）。

[:en] Preprocessing directives ([#cpp]) are executed, macro invocations are expanded
([#cpp.replace]), and [`_Pragma] unary operator expressions are executed ([#cpp.pragma.op]).
[:zh_CN] 执行预处理指令（[#cpp]），对宏调用进行展开（[#cpp.replace]），并执行
[`_Pragma] 一元运算符表达式（[#cpp.pragma.op]）。

[:en] A [`#include] preprocessing directive ([#cpp.include]) causes the named
header or source file to be processed from phase 1 through phase 4, recursively.
[:zh_CN] [`#include] 预处理指令（[#cpp.include]）将导致递归地对被指名的头文件或
源文件进行从阶段 1 到阶段 4 的处理。

[:en] All preprocessing directives are then deleted.
[:zh_CN] 随后即删除所有预处理指令。

[item]
[:en] For a sequence of two or more adjacent [~string-literal] preprocessing tokens,
a common [~encoding-prefix] is determined as specified in [#lex.string].
[:zh_CN] 对于相邻的两个或更多[~字符串字面量]预处理记号，根据 [#lex.string] 的规定
以确定一个共同[~编码前缀]。

[:en] Each such [~string-literal] preprocessing token is then considered to have
that common [~encoding-prefix].
[:zh_CN] 随即认为每个这种[~字符串字面量]预处理记号均具有这个共同[~编码前缀]。

[item]
[:en] [%concatenation[!string]]
Adjacent [~string-literal] preprocessing tokens are concatenated ([#lex.string]).
[:zh_CN] [%concatenation[!string]]
拼接相邻的[~字符串字面量]预处理记号（[#lex.string]）。

[item]
[:en] Each preprocessing token is converted into a token ([#lex.token]).
[:zh_CN] 把每个预处理记号转换为一个记号（[#lex.token]）。

[:en] Whitespace characters separating tokens are no longer significant.
[:zh_CN] 用于分隔记号的空白字符不再有意义。

[:en] The resulting tokens constitute a [+translation unit] and syntactically
and semantically analyzed as a [~translation-unit] ([#basic.link]) and translated.
[:zh_CN] 所产生的这些记号构成一个[+翻译单元]，并将之作为[~翻译单元]（[#basic.link]）
进行语法和语义的分析和翻译。

[begin:note]
[:en] The process of analyzing and translating the tokens can occasionally
result in one token being replaced by a sequence of other tokens ([#temp.names]).
[:zh_CN] 分析和翻译的过程可能偶尔会导致某个记号被替换为一系列其他记号（[#temp.names]）。
[end:note]

[:en] It is [?impldef whether the sources for module units and header units on
which the current translation unit has an interface dependency are required to
be available during translation] whether the sources for module units and header
units on which the current translation unit has an interface dependency
([#module.unit], [#module.import]) are required to be available.
[:zh_CN] 当前翻译单元对之存在接口依赖（[#module.unit]，[#module.import]）的模块单元
和头文件单元的源代码是否应当可用是[?impldef 翻译过程中当前翻译单元对之存在
接口依赖的模块单元和头文件单元的源代码是否应当可用]。

[begin:note]
[:en] Source files, translation units and translated translation units need not
necessarily be stored as files, nor need there be any one-to-one correspondence
between these entities and any external representation.
[:zh_CN] 源文件、翻译单元和已翻译过的翻译单元不必存储为文件，也不必在这些实体和其
外部表示之间进行一一对应。

[:en] The description is conceptual only, and does not specify any particular implementation.
[:zh_CN] 这仅是个概念上的描述，而并非对任何特定的实现的说明。
[end:note]

[begin:note]
[:en] Previously translated translation units can be preserved individually or in libraries.
[:zh_CN] 已翻译过的翻译单元可以独立保留，或者保留在程序库中。

[:en] The separate translation units of a program communicate ([#basic.link]) by
(for example) calls to functions whose identifiers have external or module linkage,
manipulation of objects whose identifiers have external or module linkage, or
manipulation of data files.
[:zh_CN] 程序中分离的翻译单元之间，通过（例如）调用标识符具有外部或模块连接的函数，
操作标识符具有外部或模块连接的对象，或操作数据文件来进行通信（[#basic.link]）。
[end:note]

[para:~]
[:en] While the tokens constituting translation units are being analyzed and
translated, required instantiations are performed.
[:zh_CN] 对组成翻译单元的记号进行解析和翻译时，进行必要的实例化。

[begin:note]
[:en] This can include instantiations which have been explicitly requested ([#temp.explicit]).
[:zh_CN] 其中可以包括经由显式要求（[#temp.explicit]）的实例化。
[end:note]

[:en] The contexts from which instantiations may be performed
are determined by their respective points of instantiation ([#temp.point]).
[:zh_CN] 从中进行实例化的语境，是通过它们的相应实例化点（[#temp.point]）确定的。

[begin:note]
[:en] Other requirements in this document can further constrain
the context from which an instantiation can be performed.
[:zh_CN] 本文档的其他规定对可以进行实例化的语境有进一步的约束。

[:en] For example, a constexpr function template specialization
might have a point of instantation at the end of a translation unit,
but its use in certain constant expressions could require
that it be instantiated at an earlier point ([#temp.inst]).
[:zh_CN] 例如，constexpr 函数模板特例可能在翻译单元末尾有一个实例化点，
但在某些常量表达式中使用它则要求它在更早的位置实例化（[#temp.inst]）。
[end:note]

[para:~]
[:en] Each instantiation results in new program constructs.
[:zh_CN] 每次实例化都产生新的程序构造。

[:en] The program is ill-formed if any instantiation fails.
[:zh_CN] 如果任何实例化失败，则程序是非良构的。

[para:~]
[:en] During the analysis and translation of tokens,
certain expressions are evaluated ([#expr.const]).
[:zh_CN] 对记号进行分析和翻译时过程中，某些表达式会被求值（[#expr.const]）。

[:en] Constructs appearing at a program point [$P] are analyzed
in a context where each side effect of evaluating an expression [$E]
as a full-expression is complete if and only if
[:zh_CN] 对出现于程序位置 [$P] 的语言构造的分析，当且仅当以下情况时，
是在将表达式 [$E] 当做全表达式求值的每项副作用所完成的语境中进行的：
 [list]
 [item]
[:en] [$E] is the expression corresponding to a [~consteval-block-declaration] ([#dcl.pre]), and
[:zh_CN] [$E] 是对应于某条 [~consteval-块声明式]（[#dcl.pre]）的表达式，并且
 [item]
[:en] either that [~consteval-block-declaration] or the template definition from
which it is instantiated is reachable from ([#module.reach])
[:zh_CN] 该 [~consteval-块声明式]或者其所实例化的模板的定义式，从以下位置可达：
  [list]
  [item]
[:en@~] [$P], or
[:zh_CN@~] [$P]，或
  [item]
[:en@~] the point immediately following the [~class-specifier] of the outermost
class for which [$P] is in a complete-class context ([#class.mem.general]).
[:zh_CN@~] 紧跟使 [$P] 处于完整类语境的最外层的类的[~类说明符]之后的位置（[#class.mem.general]）。
  [list:end]
 [list:end]

[begin:example]
[codeblock]
class S {
  class Incomplete;

  class Inner {
    void fn() {
      /* [$p_1] */ Incomplete i;    // OK
    }
  }; /* [$p_2] */

  consteval {
    define_aggregate(^^Incomplete, {});
  }
}; /* [$p_3] */
[codeblock:end]

[:en] Constructs at [$p_1] are analyzed in a context where the side effect of
the call to [`define_aggregate] is evaluated because
[:zh_CN] 对 [$p_1] 处的语言构造的分析是在求值对 [`define_aggregate] 调用的副作用
的语境中进行的，因为
 [list]
 [item]
[:en@~] [$E] is the expression corresponding to a consteval block, and
[:zh_CN@~] [$E] 是对应于 consteval 块的表达式，并且
 [item]
[:en@~] [$p_1] is in a complete-class context of [`S] and
the consteval block is reachable from [$p_3].
[:zh_CN@~] [$p_1] 处于 [`S] 的完整类语境中，且此 consteval 块从 [$p_3] 可达。
 [list:end]
[end:example]

[item]
[:en] [%linking]
Translated translation units are combined, and
all external entity references are resolved.
[:zh_CN] [%连接]
合并已翻译的翻译单元，并解决所有对外部实体的引用。

[:en] Library components are linked to satisfy external references to entities
not defined in the current translation.
[:zh_CN] 将程序库组件连接进程序，以满足在当前翻译中未定义的实体的外部引用。

[:en] All such translator output is collected into a program image which
contains information needed for execution in its execution environment.
[:zh_CN] 所有这些翻译器输出都汇集到一个程序映像中，它包含在其执行环境中执行所需要的信息。

[list:end]

[%:end#translation.phases]
