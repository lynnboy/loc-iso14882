[section#move.iterator
    [:en] Class template [`move_iterator]
    [:zh_CN] 类模板 [`move_iteratr]
]

[%@library move_iterator]
[codeblock:synopsis [!:mark SeeBelow UnSpec] ]
namespace std {
  template<class Iterator>
  class move_iterator {
  public:
    using iterator_type     = Iterator;
    using iterator_category = typename iterator_traits<Iterator>::iterator_category;
    using value_type        = typename iterator_traits<Iterator>::value_type;
    using difference_type   = typename iterator_traits<Iterator>::difference_type;
    using pointer           = Iterator;
    using reference         = [=SeeBelow];

    constexpr move_iterator();
    constexpr explicit move_iterator(Iterator i);
    template<class U> constexpr move_iterator(const move_iterator<U>& u);
    template<class U> constexpr move_iterator& operator=(const move_iterator<U>& u);

    constexpr iterator_type base() const;
    constexpr reference operator*() const;
    constexpr pointer operator->() const;

    constexpr move_iterator& operator++();
    constexpr move_iterator operator++(int);
    constexpr move_iterator& operator--();
    constexpr move_iterator operator--(int);

    constexpr move_iterator operator+(difference_type n) const;
    constexpr move_iterator& operator+=(difference_type n);
    constexpr move_iterator operator-(difference_type n) const;
    constexpr move_iterator& operator-=(difference_type n);
    constexpr [=UnSpec] operator[](difference_type n) const;

  private:
    Iterator current;   // [=Expos]
  };

  template<class Iterator1, class Iterator2>
    constexpr bool operator==(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator!=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

  template<class Iterator1, class Iterator2>
    constexpr auto operator-(
      const move_iterator<Iterator1>& x,
      const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());
  template<class Iterator>
    constexpr move_iterator<Iterator> operator+(
      typename move_iterator<Iterator>::difference_type n, const move_iterator<Iterator>& x);
  template<class Iterator>
    constexpr move_iterator<Iterator> make_move_iterator(Iterator i);
}
[codeblock:end]

[para]
[:en] Let [`[*R]] be [`iterator_traits<Iterator>::reference].
[:zh_CN] 令 [`[*R]] 为 [`iterator_traits<Iterator>::reference]。

[:en] If [`is_reference_v<[*R]>] is [`true], the template specialization
[`move_iterator<Iterator>] shall define the nested type named [`reference] as a
synonym for [`remove_reference_t<[*R]>&&], otherwise as a synonym for [`[*R]].
[:zh_CN] 如果 [`is_reference_v<[*R]>] 为 [`true]，则模板特例
[`move_iterator<Iterator>] 应当将名为 [`reference] 的嵌套类型定义为
[`remove_reference_t<[*R]>&&] 的同义词，否则就定义为 [`[*R]] 的同义词。
