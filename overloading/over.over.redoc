[section#over.over
    [:en] Address of an overload set
    [:zh_CN] 重载集合的地址

[:en]
[%overloading[!address of overloaded function]]
[%overloaded function[!address of]]
[:zh_CN]
[%重载[!重载函数的地址]]
[%重载函数[!～的地址]]
]

[para]
[:en] An [~id-expression] whose terminal name refers to an overload set [$S] and
that appears without arguments is resolved to a function, a pointer to function,
or a pointer to member function for a specific function that is chosen from a set
of functions selected from [$S] determined based on the target type required in
the context (if any), as described below.
[:zh_CN] 终端名指代某个重载集合 [$S] 且不带实参的[~标识表达式]，被决议为一个函数、
函数指针或成员函数指针，它是从基于语境中所需要的目标类型（如果有）所确定的 [$S] 中
选择的函数集合中选择的特定函数，如下所述。

[:en] The target can be
[:zh_CN] 其目标可以为

[list]
[item]
[:en@~] an object or reference being initialized ([#dcl.init], [#dcl.init.ref], [#dcl.init.list]),
[:zh_CN@~] 要初始化的对象或引用（[#dcl.init]，[#dcl.init.ref]，[#dcl.init.list]），
[item]
[:en@~] the left side of an assignment ([#expr.ass]),
[:zh_CN@~] 赋值的左边（[#expr.ass]），
[item]
[:en@~] a parameter of a function ([#expr.call]),
[:zh_CN@~] 函数的形参（[#expr.call]），
[item]
[:en@~] a parameter of a user-defined operator ([#over.oper]),
[:zh_CN@~] 用户定义的运算符的形参（[#over.oper]），
[item]
[:en@~] the return value of a function, operator function, or conversion ([#stmt.return]),
[:zh_CN@~] 函数、运算符函数或转换的返回值（[#stmt.return]），
[item]
[:en@~] an explicit type conversion ([#expr.type.conv], [#expr.static.cast],
[#expr.cast]), or
[:zh_CN@~] 显式类型转换（[#expr.type.conv]，[#expr.static.cast]，[#expr.cast]），或者
[item]
[:en@~] a non-type [~template-parameter] ([#temp.arg.nontype]).
[:zh_CN@~] 非类型[~模板形参]（[#temp.arg.nontype]）。
[list:end]

[:en] If the target type contains a placeholder type,
placeholder type deduction is performed ([#dcl.type.auto.deduct]), and
the remainder of this subclause uses the target type so deduced.
[:zh_CN] 如果目标类型包含占位符类型，那么进行占位符类型推断（[#dcl.type.auto.deduct]），
而本子条款余下部分使用如此推断出的目标类型。

[:en] The [~id-expression] can be preceded by the [`&] operator.
[:zh_CN] [~标识表达式]可以带有 [`&] 运算符前缀。

[begin:note]
[:en] Any redundant set of parentheses surrounding the function name is ignored
([#expr.prim.paren]).
[:zh_CN] 任何包围函数名的冗余的括号组均被忽略（[#expr.prim.paren]）。
[end:note]

[para]
[:en] If there is no target, all non-template functions named are selected.
[:zh_CN] 如果没有目标，则选择所有被指名的非模板函数。

[:en] Otherwise, a non-template function with type [`F] is selected for the
function type [`FT] of the target type if [`F] (after possibly applying the
function pointer conversion ([#conv.fctptr])) is identical to [`FT].
[:zh_CN] 否则，对于类型为 [`F] 的非模板函数和目标类型的函数类型 [`FT]，若 [`F]（经过
可能实施的函数指针转换（[#conv.fctptr]）后）与 [`FT] 相同，则为 [`FT] 选择该函数。

[begin:note]
[:en] That is, the class of which the function is a member is ignored when
matching a pointer-to-member-function type.
[:zh_CN] 就是说，对成员函数指针的类型进行匹配时，忽略包含成员函数的类。
[end:note]

[para]
[:en] The specialization, if any, generated by template argument deduction
([#temp.over], [#temp.deduct.funcaddr], [#temp.arg.explicit]) for each function
template named is added to the set of selected functions considered.
[:zh_CN] 由模板实参推断（[#temp.over]，[#temp.deduct.funcaddr]，[#temp.arg.explicit]）
为被指名的每个函数模板所生成的特例（如果有），添加到所要考察的被选择函数集合之中。

[para]
[:en] Non-member functions, static member functions, and explicit object member
functions match targets of function pointer type or reference to function type.
[:zh_CN] 非成员函数，静态成员函数，和显式对象成员函数匹配函数指针类型或函数的引用类型的目标。

[:en] implicit object member functions match targets of pointer-to-member
function type.
[:zh_CN] 隐式对象成员函数匹配成员函数指针类型的目标。

[begin:note]
[:en] If an implicit object member function is chosen, the result can be used
only to form a pointer to member ([#expr.unary.op]).
[:zh_CN] 若选中了某个隐式对象成员函数，则其结果仅可用于构成成员指针（[#expr.unary.op]）。
[end:note]

[para]
[:en] All functions with associated constraints that are not satisfied
([#temp.constr.decl]) are eliminated from the set of selected functions.
[:zh_CN] 从所选择的函数集合中消除所有带有关联约束但未能满足（[#temp.constr.decl]）的函数。

[:en] If more than one function in the set remains, all function template
specializations in the set are eliminated if the set also contains a function
that is not a function template specialization.
[:zh_CN] 若集合中还剩下多于一个函数，则如果集合中还包含并非函数模板特例的函数，就消除
集合中的所有函数模板特例。

[:en] Any given non-template function [`F0] is eliminated if the set contains a
second non-template function that is more partial-ordering-constrained than [`F0]
([#temp.constr.order]).
[:zh_CN] 对于任意给定的非模板函数 [`F0]，如果集合中还包含另一个函数比 [`F0] 更加
受偏序约束（[#temp.constr.order]），则要消除 [`F0]。

[:en] Any given function template specialization [`F1] is eliminated if the set
contains a second function template specialization whose function template is
more specialized than the function template of [`F1] according to the partial
ordering rules of [#temp.func.order].
[:zh_CN] 对于任意给定的函数模板特例 [`F1]，如果该集合包含另一个函数模板特例，根据
[#temp.func.order] 中的偏序规则，其函数模板比 [`F1] 的函数模板更加特殊，则也要消除 [`F1]。

[:en] After such eliminations, if any, there shall remain exactly one selected
function.
[:zh_CN] 在此种消除（如果有）之后，应当正好保留一个被选择的函数。

[para]
[begin:example]
[codeblock]
int f(double);
int f(int);
int (*pfd)(double) = &f;        // [:en] selects [`f(double)] [:zh_CN] 选择了 [`f(double)]
int (*pfi)(int) = &f;           // [:en] selects [`f(int)] [:zh_CN] 选择了 [`f(int)]
int (*pfe)(...) = &f;           // [:en] error: type mismatch [:zh_CN] 错误：类型不匹配
int (&rfi)(int) = f;            // [:en] selects [`f(int)] [:zh_CN] 选择了 [`f(int)]
int (&rfd)(double) = f;         // [:en] selects [`f(double)] [:zh_CN] 选择了 [`f(double)]
void g() {
  (int (*)(int))&f;             // [:en] cast expression as selector [:zh_CN] 转型表达式作为选择器
}
[codeblock:end]

[:en] The initialization of [`pfe] is ill-formed because no [`f()] with type
[`int(...)] has been declared, and not because of any ambiguity.
[:zh_CN] [`pfe] 的初始化是非良构的，因为没有声明类型 [`int(...)] 的 [`f()]，
而不是因为任何歧义。
[end:example]

[begin:example]
[codeblock]
struct X {
  int f(int);
  static int f(long);
};

int (X::*p1)(int)  = &X::f;     // OK
int    (*p2)(int)  = &X::f;     // [:en] error: mismatch [:zh_CN] 错误：不匹配
int    (*p3)(long) = &X::f;     // OK
int (X::*p4)(long) = &X::f;     // [:en] error: mismatch [:zh_CN] 错误：不匹配
int (X::*p5)(int)  = &(X::f);   // [:en] error: wrong syntax for [:zh_CN] 错误：成员指针的
                                // [:en@~] pointer to member [:zh_CN@~] 语法错误
int    (*p6)(long) = &(X::f);   // OK
[codeblock:end]
[end:example]

[begin:example]
[codeblock]
template<bool B> struct X {
  void f(short) requires B;
  void f(long);
  template<typename> void g(short) requires B;
  template<typename> void g(long);
};
void test() {
  &X<true>::f;                  // [:en] error: ambiguous; constraints are not considered \
                                [:zh_CN] 错误：歧义；未考虑约束
  &X<true>::g<int>;             // [:en] error: ambiguous; constraints are not considered \
                                [:zh_CN] 错误：歧义；未考虑约束
}
[codeblock:end]
[end:example]

[para]
[begin:note]
[:en] If [`f] and [`g] are both overload sets, the Cartesian product of
possibilities is considered to resolve [`f(&g)], or the equivalent expression [`f(g)].
[:zh_CN] 若 [`f] 和 [`g] 都是重载集合，则当决议 [`f(&g)] 或其等价表达式 [`f(g)] 时，
考察其可能情况的笛卡尔积。
[end:note]

[para]
[begin:note]
[:en] [%conversion[!overload resolution and pointer]]
Even if [`B] is a public base of [`D], we have
[:zh_CN] [%转换[!重载决议和指针～]]
即使 [`B] 是 [`D] 的公开基类，我们仍有

[codeblock]
D* f();
B* (*p1)() = &f;                // [:en] error [:zh_CN] 错误

void g(D*);
void (*p2)(B*) = &g;            // [:en] error [:zh_CN] 错误
[codeblock:end]
[end:note]
