[section#over.match.class.deduct
    [:en] Class template argument deduction
    [:zh_CN] 类模板实参推断
[%  [:en] deduction[!class template argument]
    [:zh_CN] 推断[!类模板实参～] ]
]

[para]
[:en]
When resolving a placeholder for a deduced class type ([#dcl.type.class.deduct])
where the [~template-name] names a primary class template [`C], a set of
functions and function templates is formed comprising:
[:zh_CN]
当为推断的类类型（[#dcl.type.class.deduct]）的占位符进行决议时，其中的[~模板名]
指名某个主类模板 [`C]，则构成一个函数和函数模板的集合，包含：

[list]
[item]
[:en]
If [`C] is defined, for each constructor of [`C], a function template with the
following properties:
[:zh_CN]
如果 [`C] 有定义，则对于 [`C] 的每个构造函数，有一个具有以下性质的函数模板：

[list]
[item]
[:en]
The template parameters are the template parameters of [`C] followed by the
template parameters (including default template arguments) of the constructor,
if any.
[:zh_CN]
其各个模板形参就是 [`C] 的模板形参，跟着该构造函数的模板实参（包括其默认模板
实参）（如果有）。

[item]
[:en]
The types of the function parameters are those of the constructor.
[:zh_CN]
其各个函数形参的类型与该构造函数相同。

[item]
[:en]
The return type is the class template specialization designated by [`C] and
template arguments corresponding to the template parameters of [`C].
[:zh_CN]
其返回类型即为 [`] 和对应于 [`C] 的各模板形参的模板实参所指定的类模板特例。
[list:end]

[item]
[:en]
If [`C] is not defined or does not declare any constructors, an additional
function template derived as above from a hypothetical constructor [`C()].
[:zh_CN]
如果 [`C] 未定义或并未声明任何构造函数，则从一个虚构的构造函数 [`C()] 以上述方式
产生出一个额外的函数模板。

[item]
[:en]
An additional function template derived as above from a hypothetical constructor
[`C(C)], called the [+copy deduction candidate].
[:zh_CN]
从虚构的构造函数 [`C(C)] 以上述方式产生出一个额外的函数模板，称为[+复制推断候选
函数]。

[item]
[:en]
For each [~deduction-guide], a function or function template with the following
properties:
[:zh_CN]
对于每个[~推断指导]，有一个具有以下性质的函数或函数模板：

[list]
[item]
[:en]
The template parameters, if any, and function parameters are those of the
[~deduction-guide].
[:zh_CN]
其模板形参（如果有）以及函数形参，与该[~推断指导]相同。

[item]
[:en]
The return type is the [~simple-template-id] of the [~deduction-guide].
[:zh_CN]
其返回类型为该[~推断指导]的[~简单模板标识]。
[list:end]
[list:end]

[para]
[:en]
Initialization and overload resolution are performed as described in [#dcl.init]
and [#over.match.ctor], [#over.match.copy], or [#over.match.list]
(as appropriate for the type of initialization performed) for an object of a
hypothetical class type, where the selected functions and function templates are
considered to be the constructors of that class type for the purpose of forming
an overload set, and the initializer is provided by the context in which class
template argument deduction was performed.
[:zh_CN]
对一个虚构类类型的对象根据 [#dcl.init] 以及 [#over.match.ctor]，
[#over.match.copy]，或者 [#over.match.list] 所述实施初始化以及重载决议（根据其所
实施的初始化的种类），其中所选择的函数和函数模板在构成重载集合时被当做是这个类
类型的构造函数，而其初始化式则由实施类模板实参推断的语境来提供。

[:en]
As an exception, the first phase in [#over.match.list] (considering
initializer-list constructors) is omitted if the initializer list consists of
a single expression of type [$cv] [`U], where [`U] is a specialization of [`C]
or a class derived from a specialization of [`C].
[:zh_CN]
一种例外是，如果初始化式列表由一个 [$cv] [`U] 类型的表达式所构成，其中 [`U] 是
[`C] 的特例或者派生于 [`C] 的特例的类，则省略 [#over.match.list] 的第一个阶段
（考察初始化列表构造函数）。

[:en]
Each such notional constructor is considered to be explicit if the function or
function template was generated from a constructor or [~deduction-guide] that
was declared [`explicit].
[:zh_CN]
如果函数或函数模板是根据声明为 [`explicit] 的构造函数或[~推断指导]所生成的，则
这个想象的构造函数亦被认为是显式的。

[:en]
All such notional constructors are considered to be public members of the
hypothetical class type.
[:zh_CN]
所有这些想象中的构造函数都被当做是这个虚构的类类型的公开成员。

[para]
[enter:example]
[codeblock]
template <class T> struct A {
  explicit A(const T&, ...) noexcept;  // #1
  A(T&&, ...);                         // #2
};

int i;
A a1 = { i, i };    // [:en] error: explicit constructor #1 selected in copy-list-initialization during deduction,
                    // [|:zh_CN] 错误：推断过程中在复制列表初始化中选择了显式构造函数 #1
                    // [:en@~] cannot deduce from non-forwarding rvalue reference in #2
                    // [|:zh_CN@~] 无法从 #2 中的非转发右值引用进行推断

A a2{i, i};         // [:en] OK, #1 deduces to [`A<int>] and also initializes
                    // [|:zh_CN] OK，#1 推断为 [`A<int>] 并进行初始化
A a3{0, i};         // [:en] OK, #2 deduces to [`A<int>] and also initializes
                    // [|:zh_CN] OK，#2 推断为 [`A<int>] 并进行初始化
A a4 = {0, i};      // [:en] OK, #2 deduces to [`A<int>] and also initializes
                    // [|:zh_CN] OK，#2 推断为 [`A<int>] 并进行初始化

template <class T> A(const T&, const T&) -> A<T&>;  // #3
template <class T> explicit A(T&&, T&&) -> A<T>;    // #4

A a5 = {0, 1};      // [:en] error: explicit deduction guide #4 selected in copy-list-initialization during deduction
                    // [|:zh_CN] 错误：推断过程中在复制列表初始化中选择了显式构造函数 #4
A a6{0,1};          // [:en] OK, #4 deduces to [`A<int>] and #2 initializes
                    // [|:zh_CN] OK，#4 推断为 [`A<int>] 并由 #2 进行初始化
A a7 = {0, i};      // [:en] error: #3 deduces to [`A<int&>], #1 and #2 declare same constructor
                    // [|:zh_CN] 错误：#3 推断为 [`A<int&>]，#1 和 #2 声明了同一个构造函数
A a8{0,i};          // [:en] error: #3 deduces to [`A<int&>], #1 and #2 declare same constructor
                    // [|:zh_CN] 错误：#3 推断为 [`A<int&>]，#1 和 #2 声明了同一个构造函数

template <class T> struct B {
  template <class U> using TA = T;
  template <class U> B(U, TA<U>);
};

B b{(int*)0, (char*)0};         // [:en] OK, deduces [`B<char*>]
                                // [|:zh_CN] OK，推断为 [`B<char*>]
[codeblock:end]
[exit:example]
