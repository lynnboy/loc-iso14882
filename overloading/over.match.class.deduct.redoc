[section#over.match.class.deduct
    [:en] Class template argument deduction
    [:zh_CN] 类模板实参推断
[%  [:en] deduction[!class template argument]
    [:zh_CN] 推断[!类模板实参～] ]
]

[para]
[:en]
A set of functions and function templates is formed comprising:
[:zh_CN]
构成一个函数和函数模板的集合，包含：

[list]
[item]
[:en]
For each constructor of the primary class template designated by the
[~template-name], if the template is defined, a function template with the
following properties:
[:zh_CN]
对于由[~模板名]所指定的主类模板的每个构造函数，如果这个模板有定义，则有一个具有
以下性质的函数模板：

[list]
[item]
[:en]
The template parameters are the template parameters of the class template
followed by the template parameters (including default template arguments) of
the constructor, if any.
[:zh_CN]
其各个模板形参就是该类模板的模板形参，跟着该构造函数的模板实参（包括其默认模板
实参）（如果有）。

[item]
[:en]
The types of the function parameters are those of the constructor.
[:zh_CN]
其各个函数形参的类型与该构造函数相同。

[item]
[:en]
The return type is the class template specialization designated by the
[~template-name] and template arguments corresponding to the template parameters
obtained from the class template.
[:zh_CN]
其返回类型即为由[~模板名]和对应于来自类模板各模板形参的模板实参所指定的类模板的
特例。
[list:end]

[item]
[:en]
If the primary class template [`C] is not defined or does not declare any
constructors, an additional function template derived as above from a
hypothetical constructor [`C()].
[:zh_CN]
如果主类模板 [`C] 未定义或并未声明任何构造函数，则从一个虚构的构造函数 [`C()]
以上述方式产生出一个额外的函数模板。

[item]
[:en]
An additional function template derived as above from a hypothetical constructor
[`C(C)], called the [+copy deduction candidate].
[:zh_CN]
从虚构的构造函数 [`C(C)] 以上述方式产生出一个额外的函数模板，称为[+复制推断候选
函数]。

[item]
[:en]
For each [~deduction-guide], a function or function template with the following
properties:
[:zh_CN]
对于每个[~推断指导]，有一个具有以下性质的函数或函数模板：

[list]
[item]
[:en]
The template parameters, if any, and function parameters are those of the
[~deduction-guide].
[:zh_CN]
其模板形参（如果有）以及函数形参，与该[~推断指导]相同。

[item]
[:en]
The return type is the [~simple-template-id] of the [~deduction-guide].
[:zh_CN]
其返回类型为该[~推断指导]的[~简单模板标识]。
[list:end]
[list:end]

[para]
[:en]
Initialization and overload resolution are performed as described in [#dcl.init]
and [#over.match.ctor], [#over.match.copy], or [#over.match.list]
(as appropriate for the type of initialization performed) for an object of a
hypothetical class type, where the selected functions and function templates are
considered to be the constructors of that class type for the purpose of forming
an overload set, and the initializer is provided by the context in which class
template argument deduction was performed.
[:zh_CN]
对一个虚构类类型的对象根据 [#dcl.init] 以及 [#over.match.ctor]，
[#over.match.copy]，或者 [#over.match.list] 所述实施初始化以及重载决议（根据其所
实施的初始化的种类），其中所选择的函数和函数模板在构成重载集合时被当做是这个类
类型的构造函数，而其初始化式则由实施类模板实参推断的语境来提供。

[:en]
Each such notional constructor is considered to be explicit if the function or
function template was generated from a constructor or [~deduction-guide] that
was declared [`explicit].
[:zh_CN]
如果函数或函数模板是根据声明为 [`explicit] 的构造函数或[~推断指导]所生成的，则
这个想象的构造函数亦被认为是显式的。

[:en]
All such notional constructors are considered to be public members of the
hypothetical class type.
[:zh_CN]
所有这些想象中的构造函数都被当做是这个虚构的类类型的公开成员。

[para]
[enter:example]
[codeblock]
template <class T> struct A {
  explicit A(const T&, ...) noexcept;  // #1
  A(T&&, ...);                         // #2
};

int i;
A a1 = { i, i };    // [:en] error: explicit constructor #1 selected in copy-list-initialization during deduction,
                    // [|:zh_CN] 错误：推断过程中在复制列表初始化中选择了显式构造函数 #1
                    // [:en@~] cannot deduce from non-forwarding rvalue reference in #2
                    // [|:zh_CN@~] 无法从 #2 中的非转发右值引用进行推断

A a2{i, i};         // [:en] OK, #1 deduces to [`A<int>] and also initializes
                    // [|:zh_CN] OK，#1 推断为 [`A<int>] 并进行初始化
A a3{0, i};         // [:en] OK, #2 deduces to [`A<int>] and also initializes
                    // [|:zh_CN] OK，#2 推断为 [`A<int>] 并进行初始化
A a4 = {0, i};      // [:en] OK, #2 deduces to [`A<int>] and also initializes
                    // [|:zh_CN] OK，#2 推断为 [`A<int>] 并进行初始化

template <class T> A(const T&, const T&) -> A<T&>;  // #3
template <class T> explicit A(T&&, T&&) -> A<T>;    // #4

A a5 = {0, 1};      // [:en] error: explicit deduction guide #4 selected in copy-list-initialization during deduction
                    // [|:zh_CN] 错误：推断过程中在复制列表初始化中选择了显式构造函数 #4
A a6{0,1};          // [:en] OK, #4 deduces to [`A<int>] and #2 initializes
                    // [|:zh_CN] OK，#4 推断为 [`A<int>] 并由 #2 进行初始化
A a7 = {0, i};      // [:en] error: #3 deduces to [`A<int&>], #1 and #2 declare same constructor
                    // [|:zh_CN] 错误：#3 推断为 [`A<int&>]，#1 和 #2 声明了同一个构造函数
A a8{0,i};          // [:en] error: #3 deduces to [`A<int&>], #1 and #2 declare same constructor
                    // [|:zh_CN] 错误：#3 推断为 [`A<int&>]，#1 和 #2 声明了同一个构造函数

template <class T> struct B {
  template <class U> using TA = T;
  template <class U> B(U, TA<U>);
};

B b{(int*)0, (char*)0};         // [:en] OK, deduces [`B<char*>]
                                // [|:zh_CN] OK，推断为 [`B<char*>]
[codeblock:end]
[exit:example]
