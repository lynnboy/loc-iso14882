[section#exec.bulk
    [:en] [`execution::bulk], [`execution::bulk_chunked], and [`execution::bulk_unchunked]
    [:zh_CN] [`execution::bulk]，[`execution::bulk_chunked]，与 [`execution::bulk_unchunked]
]

[para]
[:en] [`bulk], [`bulk_chunked], and [`bulk_unchunked] runs a task repeatedly for
every index in an index space.
[:zh_CN] [`bulk]、[`bulk_chunked] 和 [`bulk_unchunked] 对索引空间中的每个索引重复执行一项任务。

[para]
[:en] The names [`bulk], [`bulk_chunked], and [`bulk_unchunked] denote pipeable
sender adaptor objects.
[:zh_CN] 名字 [`bulk]、[`bulk_chunked] 和 [`bulk_unchunked] 都代表可连管道的发送器适配器对象。

[:en] Let [`[^bulk-algo]] be either [`bulk], [`bulk_chunked], or [`bulk_unchunked].
[:zh_CN] 令 [`[^bulk-algo]] 为 [`bulk]、[`bulk_chunked] 或 [`bulk_unchunked]。

[:en] For subexpressions [`sndr], [`policy], [`shape], and [`f], let [`Policy]
be [`remove_cvref_t<decltype(policy)>], [`Shape] be [`decltype(auto(shape))],
and [`Func] be [`decay_t<decltype((f))>].
[:zh_CN] 对于子表达式 [`sndr]、[`policy]、[`shape] 和 [`f]，令 [`Policy] 为
[`remove_cvref_t<decltype(policy)>]，[`Shape] 为 [`decltype(auto(shape))]，
[`Func] 为 [`decay_t<decltype((f))>]。

[:en] If
[:zh_CN] 如果
[list]
[item]
[:en@~] [`decltype((sndr))] does not satisfy [`:c sender], or
[:zh_CN@~] [`decltype((sndr))] 不满足 [`:c sender]，或者
[item]
[:en@~] [`is_execution_policy_v<Policy>] is [`false], or
[:zh_CN@~] [`is_execution_policy_v<Policy>] 为 [`false]，或者
[item]
[:en@~] [`Shape] does not satisfy [`:c integral], or
[:zh_CN@~] [`Shape] 不满足 [`:c integral]，或者
[item]
[:en@~] [`Func] does not model [`:c copy_constructible],
[:zh_CN@~] [`Func] 不构成 [`:c copy_constructible]，
[list:end]
[:en@~] [`[^bulk-algo](sndr, policy, shape, f)] is ill-formed.
[:zh_CN@~] 那么 [`[^bulk-algo](sndr, policy, shape, f)] 非良构。

[para]
[:en] Otherwise, the expression [`[^bulk-algo](sndr, policy, shape, f)] is
expression-equivalent to:
[:zh_CN] 否则，表达式 [`[^bulk-algo](sndr, policy, shape, f)] 按表达式等价于：
[codeblock]
transform_sender([[redoc("*>")]]get-domain-early(sndr), [[redoc("*>")]]make-sender(
    [[redoc("^>")]]bulk-algo, [[redoc("*>")]]product-type<[[redoc("[=seebelow]")]], Shape, Func>{policy, shape, f}, sndr))
[codeblock:end]
[:en@~] except that [`sndr] is evaluated only once.
[:zh_CN@~] 但 [`sndr] 仅被求值一次。

[:en] The first template argument of [*product-type] is [`Policy]
if [`Policy] models [`:c copy_constructible], and [`const Policy&] otherwise.
[:zh_CN] 如果 [`Policy] 构成 [`:c copy_constructible]，则
[*product-type] 的第一个模板实参为 [`Policy]，否则为 [`const Policy&]。

[para]
[:en] Let [`sndr] and [`env] be subexpressions such that [`Sndr] is [`decltype((sndr))].
[:zh_CN] 令 [`sndr] 和 [`env] 为子表达式，使得 [`Sndr] 为 [`decltype((sndr))]。

[:en] If [`[*:c sender-for]<Sndr, bulk_t>] is [`false], then the expression
[`bulk.transform_sender(sndr, env)] is ill-formed; otherwise, it is equivalent to:
[codeblock]
auto [_, data, child] = sndr;
auto& [policy, shape, f] = data;
auto new_f = [func = std::move(f)](Shape begin, Shape end, auto&&... vs)
    noexcept(noexcept(f(begin, vs...))) {
  while (begin != end) func(begin++, vs...);
}
return bulk_chunked(std::move(child), policy, shape, std::move(new_f));
[codeblock:end]

[begin:note]
[:en] This causes the [`bulk(sndr, policy, shape, f)] sender to be
expressed in terms of [`bulk_chunked(sndr, policy, shape, f)] when
it is connected to a receiver whose execution domain does not customize [`bulk].
[:zh_CN] 这导致，[`bulk(sndr, policy, shape, f)] 发送器仅在连接到不自定义 [`bulk]
的执行域的接收器时，才以 [`bulk_chunked(sndr, policy, shape, f)] 的形式表示。
[end:note]

[para]
[:en] The exposition-only class template [*impls-for] ([#exec.snd.general]) is
specialized for [`bulk_chunked_t] as follows:
[:zh_CN] 仅用于阐释的类模板 [*impls-for]（[#exec.snd.general]）针对
[`bulk_chunked_t] 进行如下特化：
[%@lib [*impls-for]<bulk_chunked_t>]
[codeblock]
namespace std::execution {
  template<>
  struct [[redoc("*>")]]impls-for<bulk_chunked_t> : [[redoc("*>")]]default-impls {
    static constexpr auto [[redoc("*>")]]complete = [[redoc("[=seebelow]")]];

    template<class Sndr, class... Env>
      static consteval void [[redoc("*>")]]check-types();
  };
}
[codeblock:end]

[:en] The member [`[*impls-for]<bulk_chunked_t>::[*complete]]
is initialized with a callable object equivalent to the following lambda:
[:zh_CN] 成员 [`[*impls-for]<bulk_chunked_t>::[*complete]] 以等价于如下 lambda 的
可调用对象初始化：
[codeblock]
[]<class Index, class State, class Rcvr, class Tag, class... Args>
  (Index, State& state, Rcvr& rcvr, Tag, Args&&... args) noexcept
  -> void requires [[redoc("[=seebelow]")]] {
    if constexpr ([[redoc("`:c>")]]same_as<Tag, set_value_t>) {
      auto& [policy, shape, f] = state;
      constexpr bool nothrow = noexcept(f(auto(shape), auto(shape), args...));
      [[redoc("*>")]]TRY-EVAL(rcvr, [&]() noexcept(nothrow) {
        f(static_cast<decltype(auto(shape))>(0), auto(shape), args...);
        Tag()(std::move(rcvr), std::forward<Args>(args)...);
      }());
    } else {
      Tag()(std::move(rcvr), std::forward<Args>(args)...);
    }
  }
[codeblock:end]

[:en] The expression in the [~requires-clause] of the lambda above is [`true]
if and only if [`Tag] denotes a type other than [`set_value_t] or
if the expression [`f(auto(shape), auto(shape), args...)] is well-formed.
[:zh_CN] 以上 lambda 的 [~requires-子句]中的表达式，当且仅当 [`Tag] 代表不是
[`set_value_t] 的类型，或当表达式 [`f(auto(shape), auto(shape), args...)] 良构时，为 [`true]。

[para]
[:en] The exposition-only class template [*impls-for] ([#exec.snd.general]) is
specialized for [`bulk_unchunked_t] as follows:
[:zh_CN] 仅用于阐释的类模板 [*impls-for]（[#exec.snd.general]）针对
[`bulk_unchunked_t] 进行如下特化：
[%@lib [*impls-for]<bulk_unchunked_t>]
[codeblock]
namespace std::execution {
  template<>
  struct [[redoc("*>")]]impls-for<bulk_unchunked_t> : [[redoc("*>")]]default-impls {
    static constexpr auto [[redoc("*>")]]complete = [[redoc("[=seebelow]")]];
  };
}
[codeblock:end]

[:en] The member [`[*impls-for]<bulk_unchunked_t>::[*complete]]
is initialized with a callable object equivalent to the following lambda:
[:zh_CN] 成员 [`[*impls-for]<bulk_unchunked_t>::[*complete]] 以等价于如下 lambda 的
可调用对象初始化：
[codeblock]
[]<class Index, class State, class Rcvr, class Tag, class... Args>
  (Index, State& state, Rcvr& rcvr, Tag, Args&&... args) noexcept
  -> void requires [[redoc("[=seebelow]")]] {
    if constexpr ([[redoc("`:c>")]]same_as<Tag, set_value_t>) {
      auto& [shape, f] = state;
      constexpr bool nothrow = noexcept(f(auto(shape), args...));
      [[redoc("*>")]]TRY-EVAL(rcvr, [&]() noexcept(nothrow) {
        for (decltype(auto(shape)) i = 0; i < shape; ++i) {
          f(auto(i), args...);
        }
        Tag()(std::move(rcvr), std::forward<Args>(args)...);
      }());
    } else {
      Tag()(std::move(rcvr), std::forward<Args>(args)...);
    }
  }
[codeblock:end]

[:en] The expression in the [~requires-clause] of the lambda above is [`true]
if and only if [`Tag] denotes a type other than [`set_value_t] or
if the expression [`f(auto(shape), args...)] is well-formed.
[:zh_CN] 以上 lambda 的 [~requires-子句]中的表达式，当且仅当 [`Tag] 代表不是
[`set_value_t] 的类型，或当表达式 [`f(auto(shape), args...)] 良构时，为 [`true]。

[%@lib [*check-types][![*impls-for]<bulk_t>]]
[codeblock:declaration]
template<class Sndr, class... Env>
  static consteval void @\exposid{check-types}@();
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to:
[:zh_CN] 等价于：
[codeblock]
auto cs = get_completion_signatures<[[redoc("*>")]]child-type<Sndr>, [[redoc("*>")]]FWD-ENV-T(Env)...>();
auto fn = []<class... Ts>(set_value_t(*)(Ts...)) {
  if constexpr (![[redoc("`:c>")]]invocable<remove_cvref_t<[[redoc("*>")]]data-type<Sndr>>, Ts&...>)
    throw [[redoc("^>")]]unspecified-exception();
};
cs.[[redoc("*>")]]for-each([[redoc("*>")]]overload-set(fn, [](auto){}));
[codeblock:end]
[:en@~] where [`[^unspecified-exception]] is a type derived from [`exception].
[:zh_CN@~] 其中 [`[^unspecified-exception]] 是派生于 [`exception] 的类型。
[div:end]

[para]
[:en] Let the subexpression [`out_sndr] denote the result of the invocation
[`[^bulk-algo](sndr, policy, shape, f)] or an object equal to such, and let the
subexpression [`rcvr] denote a receiver such that the expression
[`connect(out_sndr, rcvr)] is well-formed.
[:zh_CN] 令子表达式 [`out_sndr] 代表调用 [`[^bulk-algo](sndr, policy, shape, f)]
的结果或等于它的对象，并令子表达式 [`rcvr] 代表一个接收器，使得表达式
[`connect(out_sndr, rcvr)] 良构。

[:en] The expression [`connect(out_sndr, rcvr)] has undefined behavior unless
it creates an asynchronous operation ([#exec.async.ops]) that, when started:
[:zh_CN] 表达式 [`connect(out_sndr, rcvr)]，若非其创建了异步操作（[#exec.async.ops]），
当其启动时有如下行为，否则具有未定义行为：

[list]
[item]
[:en] If [`sndr] has a successful completion, where [`args] is a pack of lvalue
subexpressions referring to the value completion result datums of [`sndr], or
decayed copies of those values if they model [`:c copy_constructible], then:
[:zh_CN] 如果 [`sndr] 有成功完成，其中 [`args] 是左值子表达式的包组，指代 [`sndr] 的
值完成结果数据，或当它们构成 [`:c copy_constructible] 时为这些值的退化副本，

 [list]
 [item]
[:en] If [`out_sndr] also completes successfully, then:
[:zh_CN] 如果 [`out_sndr] 也成功完成，则：

  [list]
  [item]
[:en] for [`bulk], invokes [`f([$i], args...)] for every [$i] of type [`Shape]
from [`0] to [`shape];
[:zh_CN] 对于 [`bulk]，对从 [`0] 到 [`shape] 的每个 [`Shape] 类型的 [$i]，
调用 [`f([$i], args...)]；

  [item]
[:en] for [`bulk_unchunked], invokes [`f([$i], args...)] for every [$i] of type
[`Shape] from [`0] to [`shape];
[:zh_CN] 对于 [`bulk_unchunked]，对从 [`0] 到 [`shape] 的每个 [`Shape] 类型的 [$i]，
调用 [`f([$i], args...)]；

[para:recommended:~]
[:en] The underlying scheduler should execute each iteration on a distinct execution agent.
[:zh_CN] 底层调度器应在独立的执行代理上执行每次迭代。

  [item]
[:en] for [`bulk_chunked], invokes [`f([$b], [$e], args...)] zero or more times
with pairs of [$b] and [$e] of type [`Shape] in range [=crange([`0],[`shape])],
such that [$b < e] and for every [$i] of type [`Shape] from [`0] to [`shape],
there is exactly one invocation with a pair [$b] and [$e],
such that [$i] is in the range [=range([$b],[$e])].
[:zh_CN] 对于 [`bulk_chunked]，对属于范围 [=crange([`0],[`shape])] 的 [`Shape]
类型的 [$b] 和 [$e] 的对偶调用零或多次 [`f([$b], [$e], args...)]，其中使得 [$b < e]
且对于从 [`0] 到 [`shape] 的每个 [`Shape] 类型的 [$i]，恰好有一次以对偶 [$b] 和 [$e]
进行的调用，[$i] 在范围 [=range([$b],[$e])] 中。
  [list:end]

 [item]
[:en] If [`out_sndr] completes with [`set_error(rcvr, eptr)], then
the asynchronous operation may invoke a subset of
the invocations of [`f] before the error completion handler is called, and
[`eptr] is an [`exception_ptr] containing either:
[:zh_CN] 如果 [`out_sndr] 以 [`set_error(rcvr, eptr)] 完成，则异步操作可能在调用
错误完成处理程序之前调用 [`f] 的子集，并且 [`eptr] 是包含以下内容之一的 [`exception_ptr]：

  [list]
  [item]
[:en@~] an exception thrown by an invocation of [`f], or
[:zh_CN@~] [`f] 的某次调用抛出的异常，或
  [item]
[:en@~] a [`bad_alloc] exception if the implementation fails to allocate required
resources, or
[:zh_CN@~] 如果实现无法分配所需资源，则为 [`bad_alloc] 异常，或
  [item]
[:en@~] an exception derived from [`runtime_error].
[:zh_CN@~] 派生于 [`runtime_error] 的异常。
  [list:end]

 [item]
[:en] If [`out_sndr] completes with [`set_stopped(rcvr)], then the asynchronous
operation may invoke a subset of the invocations of [`f] before the stopped
completion handler.
[:zh_CN] 如果 [`out_sndr] 以 [`set_stopped(rcvr)] 完成，则异步操作可能在调用
停止完成处理程序之前调用 [`f] 的子集。
 [list:end]

[item]
[:en] If [`sndr] does not complete with [`set_value], then
the completion is forwarded to [`recv].
[:zh_CN] 如果 [`sndr] 不以 [`set_value] 完成，则完成被转发到 [`recv]。

[item]
[:en] For [`[^bulk-algo]], the parameter [`policy] describes the manner in which
the execution of the asynchronous operations corresponding to these algorithms
may be parallelized and the manner in which they apply [`f].
[:zh_CN] 对于 [`[^bulk-algo]]，形参 [`policy] 描述了对应于这些算法的异步操作的执行方式
如何并行化，以及它们如何应用 [`f]。

[:en] Permissions and requirements on parallel algorithm element access
functions ([#algorithms.parallel.exec]) apply to [`f].
[:zh_CN] 并行算法元素访问函数的权限和要求（[#algorithms.parallel.exec]）适用于 [`f]。
[list:end]

[para]
[begin:note]
[:en] The asynchronous operation corresponding to
[`[^bulk-algo](sndr, policy, shape, f)] can complete with [`set_stopped]
if cancellation is requested or ignore cancellation requests.
[:zh_CN] 如果请求了取消或忽略取消请求，那么对应于 [`[^bulk-algo](sndr, policy, shape, f)]
的异步操作可以以 [`set_stopped] 完成。
[end:note]
