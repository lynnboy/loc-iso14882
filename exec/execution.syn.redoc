[section#execution.syn
    [:en] Header [`<execution>] synopsis
    [:zh_CN] 头文件 [`<execution>] 纲要
]

[%@hdr@def execution]
[codeblock:synopsis]
namespace std {
  // [:en] [#execpol.type], execution policy type trait \
  [:zh_CN] [#execpol.type]，执行策略类型特征
  template<class T> struct is_execution_policy;                 // [=freestanding]
  template<class T> constexpr bool [[redoc("`:lib>")]]is_execution_policy_v =      // [=freestanding]
      is_execution_policy<T>::value;
}

namespace std::execution {
  // [:en] [#execpol.seq], sequenced execution policy \
  [:zh_CN] [#execpol.seq]，顺序执行策略
  class sequenced_policy;

  // [:en] [#execpol.par], parallel execution policy \
  [:zh_CN] [#execpol.par]，并行执行策略
  class parallel_policy;

  // [:en] [#execpol.parunseq], parallel and unsequenced execution policy \
  [:zh_CN] [#execpol.parunseq]，并行且非顺序执行策略
  class parallel_unsequenced_policy;

  // [:en] [#execpol.unseq], unsequenced execution policy \
  [:zh_CN] [#execpol.unseq]，非顺序执行策略
  class unsequenced_policy;

  // [:en] [#execpol.objects], execution policy objects \
  [:zh_CN] [#execpol.objects]，执行策略对象
  inline constexpr sequenced_policy            seq{ [[redoc("[=unspec]")]] };
  inline constexpr parallel_policy             par{ [[redoc("[=unspec]")]] };
  inline constexpr parallel_unsequenced_policy par_unseq{ [[redoc("[=unspec]")]] };
  inline constexpr unsequenced_policy          unseq{ [[redoc("[=unspec]")]] };
}

namespace std {
  // [:en] [#exec.general], helper concepts \
  [:zh_CN] [#exec.general]，辅助概念
  template<class T>
    concept [[redoc("*:c>")]]movable-value = [[redoc("[=seebelow]")]];                          // [=expos]

  template<class From, class To>
    concept [[redoc("*:c@def>")]]decays-to = [[redoc("`:c>")]]same_as<decay_t<From>, To>;             // [=expos]

  template<class T>
    concept [[redoc("*:c@def>")]]class-type = [[redoc("*:c>")]]decays-to<T, T> && is_class_v<T>;      // [=expos]

  // [:en] [#exec.queryable], queryable objects \
  [:zh_CN] [#exec.queryable]，可查询对象
  template<class T>
    concept [[redoc("*:c>")]]queryable = [[redoc("[=seebelow]")]];                              // [=expos]

  // [:en] [#exec.queries], queries \
  [:zh_CN] [#exec.queries]，查询
  struct [[redoc("`:lib")]]forwarding_query_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]get_allocator_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]get_stop_token_t { [[redoc("[=unspec]")]] };

  inline constexpr forwarding_query_t [[redoc("`:lib")]]forwarding_query{};
  inline constexpr get_allocator_t [[redoc("`:lib")]]get_allocator{};
  inline constexpr get_stop_token_t [[redoc("`:lib")]]get_stop_token{};

  template<class T>
    using stop_token_of_t = remove_cvref_t<decltype(get_stop_token(declval<T>()))>;

  template<class T>
    concept [[redoc("*:c@def>")]]forwarding-query = forwarding_query(T{});           // [=expos]
}

namespace std::execution {
  // [:en] [#exec.queries], queries \
  [:zh_CN] [#exec.queries]，查询
  struct [[redoc("`:lib")]]get_domain_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]get_scheduler_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]get_delegation_scheduler_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]get_forward_progress_guarantee_t { [[redoc("[=unspec]")]] };
  template<class CPO>
    struct [[redoc("`:lib")]]get_completion_scheduler_t { [[redoc("[=unspec]")]] };
  struct get_await_completion_adaptor_t { [[redoc("[=unspec]")]] };

  inline constexpr get_domain_t [[redoc("`:lib")]]get_domain{};
  inline constexpr get_scheduler_t [[redoc("`:lib")]]get_scheduler{};
  inline constexpr get_delegation_scheduler_t [[redoc("`:lib")]]get_delegation_scheduler{};
  enum class forward_progress_guarantee;
  inline constexpr get_forward_progress_guarantee_t [[redoc("`:lib")]]get_forward_progress_guarantee{};
  template<class CPO>
    constexpr get_completion_scheduler_t<CPO> [[redoc("`:lib")]]get_completion_scheduler{};
  inline constexpr get_await_completion_adaptor_t get_await_completion_adaptor{};

  struct [[redoc("`:lib")]]get_env_t { [[redoc("[=unspec]")]] };
  inline constexpr get_env_t [[redoc("`:lib")]]get_env{};

  template<class T>
    using [[redoc("`:lib")]]env_of_t = decltype(get_env(declval<T>()));

  // [:en] [#exec.prop], class template [`prop] \
  [:zh_CN] [#exec.prop]，类模板 [`prop]
  template<class QueryTag, class ValueType>
    struct prop;

  // [:en] [#exec.env], class template [`env] \
  [:zh_CN] [#exec.env]，类模板 [`env]
  template<[[redoc("*:c>")]]queryable... Envs>
    struct env;

  // [:en] [#exec.domain.default], execution domains \
  [:zh_CN] [#exec.domain.default]，执行域
  struct default_domain;

  // [:en] [#exec.sched], schedulers \
  [:zh_CN] [#exec.sched]，调度器
  struct [[redoc("`:lib")]]scheduler_t {};

  template<class Sch>
    concept [[redoc("`:c>")]]scheduler = [[redoc("[=seebelow]")]];

  // [:en] [#exec.recv], receivers \
  [:zh_CN] [#exec.recv]，接收器
  struct [[redoc("`:lib")]]receiver_t {};

  template<class Rcvr>
    concept [[redoc("`:c>")]]receiver = [[redoc("[=seebelow]")]];

  template<class Rcvr, class Completions>
    concept [[redoc("`:c>")]]receiver_of = [[redoc("[=seebelow]")]];

  struct [[redoc("`:lib")]]set_value_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]set_error_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]set_stopped_t { [[redoc("[=unspec]")]] };

  inline constexpr set_value_t [[redoc("`:lib")]]set_value{};
  inline constexpr set_error_t [[redoc("`:lib")]]set_error{};
  inline constexpr set_stopped_t [[redoc("`:lib")]]set_stopped{};

  // [:en] [#exec.opstate], operation states \
  [:zh_CN] [#exec.opstate]，操作状态
  struct [[redoc("`:lib")]]operation_state_t {};

  template<class O>
    concept [[redoc("`:c>")]]operation_state = [[redoc("[=seebelow]")]];

  struct [[redoc("`:lib")]]start_t;
  inline constexpr start_t [[redoc("`:lib")]]start{};

  // [:en] [#exec.snd], senders \
  [:zh_CN] [#exec.snd]，发送器
  struct [[redoc("`:lib")]]sender_t {};

  template<class Sndr>
    concept [[redoc("`:c>")]]sender = [[redoc("[=seebelow]")]];

  template<class Sndr, class... Env>
    concept [[redoc("`:c>")]]sender_in = [[redoc("[=seebelow]")]];

  template<class Sndr>
    concept [[redoc("`:c>")]]dependent_sender = [[redoc("[=seebelow]")]];

  template<class Sndr, class Rcvr>
    concept [[redoc("`:c>")]]sender_to = [[redoc("[=seebelow]")]];

  template<class... Ts>
    struct [[redoc("*>")]]type-list;                                           // [=expos]

  template<class... Ts>
    using [[redoc("*>")]]decayed-tuple = tuple<decay_t<Ts>...>;                // [=expos]

  template<class... Ts>
    using [[redoc("*>")]]variant-or-empty = [[redoc("[=seebelow]")]];                         // [=expos]

  template<class Sndr, class Env = env<>,
           template<class...> class Tuple = [[redoc("*>")]]decayed-tuple,
           template<class...> class Variant = [[redoc("*>")]]variant-or-empty>
      requires [[redoc("`:c>")]]sender_in<Sndr, Env>
    using value_types_of_t = [[redoc("[=seebelow]")]];

  template<class Sndr, class Env = env<>,
           template<class...> class Variant = [[redoc("*>")]]variant-or-empty>
      requires [[redoc("`:c>")]]sender_in<Sndr, Env>
    using error_types_of_t = [[redoc("[=seebelow]")]];

  template<class Sndr, class Env = env<>>
      requires [[redoc("`:c>")]]sender_in<Sndr, Env>
    constexpr bool sends_stopped = [[redoc("[=seebelow]")]];

  template<class Sndr, class... Env>
    using [[redoc("*>")]]single-sender-value-type = [[redoc("[=seebelow]")]];                 // [=expos]

  template<class Sndr, class... Env>
    concept [[redoc("*:c>")]]single-sender = [[redoc("[=seebelow]")]]; // [=expos]

  template<[[redoc("`:c>")]]sender Sndr>
    using tag_of_t = [[redoc("[=seebelow]")]];

  // [:en] [#exec.snd.transform], sender transformations \
  [:zh_CN] [#exec.snd.transform]，发送器变换
  template<class Domain, [[redoc("`:c>")]]sender Sndr, [[redoc("*:c>")]]queryable... Env>
      requires (sizeof...(Env) <= 1)
    constexpr [[redoc("`:c>")]]sender decltype(auto) transform_sender(
      Domain dom, Sndr&& sndr, const Env&... env) noexcept([[redoc("[=seebelow]")]]);

  // [:en] [#exec.snd.transform.env], environment transformations \
  [:zh_CN] [#exec.snd.transform.env]，环境变换
  template<class Domain, [[redoc("`:c>")]]sender Sndr, [[redoc("*:c>")]]queryable Env>
    constexpr [[redoc("*:c>")]]queryable decltype(auto) transform_env(
      Domain dom, Sndr&& sndr, Env&& env) noexcept;

  // [:en] [#exec.snd.apply], sender algorithm application \
  [:zh_CN] [#exec.snd.apply]，应用发送器算法
  template<class Domain, class Tag, [[redoc("`:c>")]]sender Sndr, class... Args>
    constexpr decltype(auto) apply_sender(
      Domain dom, Tag, Sndr&& sndr, Args&&... args) noexcept([[redoc("[=seebelow]")]]);

  // [:en] [#exec.connect], the connect sender algorithm \
  [:zh_CN] [#exec.connect]，发送器算法 `connct`
  struct [[redoc("`:lib")]]connect_t;
  inline constexpr connect_t [[redoc("`:lib")]]connect{};

  template<class Sndr, class Rcvr>
    using [[redoc("`:lib")]]connect_result_t =
      decltype(connect(declval<Sndr>(), declval<Rcvr>()));

  // [:en] [#exec.factories], sender factories \
  [:zh_CN] [#exec.factories]，发送器工厂
  struct [[redoc("`:lib")]]just_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]just_error_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]just_stopped_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]schedule_t { [[redoc("[=unspec]")]] };

  inline constexpr just_t [[redoc("`:lib")]]just{};
  inline constexpr just_error_t [[redoc("`:lib")]]just_error{};
  inline constexpr just_stopped_t [[redoc("`:lib")]]just_stopped{};
  inline constexpr schedule_t [[redoc("`:lib")]]schedule{};
  inline constexpr [[redoc("[=unspec]")]] [[redoc("`:lib")]]read_env{};

  template<[[redoc("`:c>")]]scheduler Sch>
    using [[redoc("`:lib")]]schedule_result_t = decltype(schedule(declval<Sch>()));

  // [:en] [#exec.adapt], sender adaptors \
  [:zh_CN] [#exec.adapt]，发送器适配器
  template<[[redoc("*:c>")]]class-type D>
    struct [[redoc("`:lib")]]sender_adaptor_closure { };

  struct [[redoc("`:lib")]]starts_on_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]continues_on_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]on_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]schedule_from_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]then_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]upon_error_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]upon_stopped_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]let_value_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]let_error_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]let_stopped_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]bulk_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]bulk_chunked_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]bulk_unchunked_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]when_all_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]when_all_with_variant_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]into_variant_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]stopped_as_optional_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]stopped_as_error_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]associate_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]spawn_future_t { [[redoc("[=unspec]")]] };

  inline constexpr [[redoc("[=unspec]")]] [[redoc("`:lib")]]write_env{};
  inline constexpr [[redoc("[=unspec]")]] [[redoc("`:lib")]]unstoppable{};
  inline constexpr starts_on_t [[redoc("`:lib")]]starts_on{};
  inline constexpr continues_on_t [[redoc("`:lib")]]continues_on{};
  inline constexpr on_t [[redoc("`:lib")]]on{};
  inline constexpr schedule_from_t [[redoc("`:lib")]]schedule_from{};
  inline constexpr then_t [[redoc("`:lib")]]then{};
  inline constexpr upon_error_t [[redoc("`:lib")]]upon_error{};
  inline constexpr upon_stopped_t [[redoc("`:lib")]]upon_stopped{};
  inline constexpr let_value_t [[redoc("`:lib")]]let_value{};
  inline constexpr let_error_t [[redoc("`:lib")]]let_error{};
  inline constexpr let_stopped_t [[redoc("`:lib")]]let_stopped{};
  inline constexpr bulk_t [[redoc("`:lib")]]bulk{};
  inline constexpr bulk_chunked_t [[redoc("`:lib")]]bulk_chunked{};
  inline constexpr bulk_unchunked_t [[redoc("`:lib")]]bulk_unchunked{};
  inline constexpr when_all_t [[redoc("`:lib")]]when_all{};
  inline constexpr when_all_with_variant_t [[redoc("`:lib")]]when_all_with_variant{};
  inline constexpr into_variant_t [[redoc("`:lib")]]into_variant{};
  inline constexpr stopped_as_optional_t [[redoc("`:lib")]]stopped_as_optional{};
  inline constexpr stopped_as_error_t [[redoc("`:lib")]]stopped_as_error{};
  inline constexpr associate_t [[redoc("`:lib")]]associate{};
  inline constexpr spawn_future_t [[redoc("`:lib")]]spawn_future{};

  // [:en] [#exec.cmplsig], completion signatures \
  [:zh_CN] [#exec.cmplsig]，完成签名
  template<class Fn>
    concept [[redoc("*:c>")]]completion-signature = [[redoc("[=seebelow]")]];                   // [=expos]

  template<[[redoc("*:c>")]]completion-signature... Fns>
    struct [[redoc("`:lib")]]completion_signatures;

  template<class Sigs>
    concept [[redoc("*:c>")]]valid-completion-signatures = [[redoc("[=seebelow]")]];            // [=expos]

  struct dependent_sender_error : exception {};

  // [#exec.getcomplsigs]
  template<class Sndr, class... Env>
    consteval auto get_completion_signatures() -> [[redoc("*:c>")]]valid-completion-signatures auto;

  template<class Sndr, class... Env>
      requires [[redoc("`:c>")]]sender_in<Sndr, Env...>
    using completion_signatures_of_t = decltype(get_completion_signatures<Sndr, Env...>());

  // [:en] [#exec.run.loop], run_loop \
  [:zh_CN] [#exec.run.loop]，[`run_loop]
  class run_loop;
}

namespace std::this_thread {
  // [:en] [#exec.consumers], consumers \
  [:zh_CN] [#exec.consumers]，消耗方
  struct [[redoc("`:lib")]]sync_wait_t { [[redoc("[=unspec]")]] };
  struct [[redoc("`:lib")]]sync_wait_with_variant_t { [[redoc("[=unspec]")]] };

  inline constexpr sync_wait_t [[redoc("`:lib")]]sync_wait{};
  inline constexpr sync_wait_with_variant_t [[redoc("`:lib")]]sync_wait_with_variant{};
}

namespace std::execution {
  // [:en] [#exec.consumers], consumers \
  [:zh_CN] [#exec.consumers]，消耗方
  struct [[redoc("`:lib")]]spawn_t { [[redoc("[=unspec]")]] };
  inline constexpr spawn_t spawn{};

  // [#exec.as.awaitable]
  struct [[redoc("`:lib")]]as_awaitable_t { [[redoc("[=unspec]")]] };
  inline constexpr as_awaitable_t [[redoc("`:lib")]]as_awaitable{};

  // [#exec.with.awaitable.senders]
  template<[[redoc("*:c>")]]class-type Promise>
    struct with_awaitable_senders;

  // [:en] [#exec.scope.concepts], scope concepts \
  [:zh_CN] [#exec.scope.concepts]，作用域概念
  template<class Token>
    concept [[redoc("`:lib")]]scope_token = [[redoc("[=seebelow]")]];

  // [#exec.scope.simple.counting]
  class simple_counting_scope;

  // [#exec.scope.counting]
  class counting_scope;
}

namespace std::execution {
  // [:en] [#exec.par.scheduler], parallel scheduler \
  [:zh_CN] [#exec.par.scheduler]，并行调度器
  class [[redoc("`:lib")]]parallel_scheduler { [[redoc("[=unspec]")]] };
  parallel_scheduler get_parallel_scheduler();
}

// [:en] [#exec.sysctxrepl], namespace [`system_context_replaceability] \
[:zh_CN] [#exec.sysctxrepl]，命名空间 [`system_context_replaceability]
namespace std::execution::[[redoc("`:lib")]]system_context_replaceability {
  struct receiver_proxy;
  struct bulk_item_receiver_proxy;
  struct parallel_scheduler_backend;

  shared_ptr<parallel_scheduler_backend> query_parallel_scheduler_backend();
}

namespace std::execution {
  // [#exec.affine.on]
  struct [[redoc("`:lib")]]affine_on_t { [[redoc("[=unspec]")]] };
  inline constexpr affine_on_t [[redoc("`:lib")]]affine_on{};

  // [#exec.inline.scheduler]
  class [[redoc("`:lib")]]inline_scheduler;

  // [#exec.task.scheduler]
  class [[redoc("`:lib")]]task_scheduler;

  template<class E>
  struct [[redoc("`:lib")]]with_error {
    using type = remove_cvref_t<E>;
    type error;
  };
  template<class E>
    with_error(E) -> with_error<E>;

  template<[[redoc("`:c>")]]scheduler Sch>
  struct change_coroutine_scheduler {
    using type = remove_cvref_t<Sch>;
    type scheduler;
  };
  template<[[redoc("`:c>")]]scheduler Sch>
    change_coroutine_scheduler(Sch) -> change_coroutine_scheduler<Sch>;

  // [#exec.task]
  template<class T, class Environment>
    class [[redoc("`:lib")]]task;
}
[codeblock:end]

[para]
[:en] The exposition-only type [`[*variant-or-empty]<Ts...>] is defined as follows:
[:zh_CN] 仅用于阐释的类型 [`[*variant-or-empty]<Ts...>] 定义如下：
[list]
[item]
[:en] If [`sizeof...(Ts)] is greater than zero,
[`[*variant-or-empty]<Ts...>] denotes [`variant<Us...>]
where [`Us...] is the pack [`decay_t<Ts>...] with duplicate types removed.
[:zh_CN] 如果 [`sizeof...(Ts)] 大于零，则 [`[*variant-or-empty]<Ts...>] 代表
[`variant<Us...>]，其中 [`Us...] 是移除了重复类型的包组 [`decay_t<Ts>...]。
[item]
[:en] Otherwise, [`[*variant-or-empty]<Ts...>] denotes the exposition-only class type:
[:zh_CN] 否则，[`[*variant-or-empty]<Ts...>] 代表仅用于阐释的类类型：
[codeblock]
namespace std::execution {
  struct [[redoc("*>")]]empty-variant {        // [=expos]
    [[redoc("*>")]]empty-variant() = delete;
  };
}
[codeblock:end]
[list:end]

[para]
[:en] For type [`Sndr] and pack of types [`Env], let [`CS] be [`completion_signatures_of_t<Sndr, Env...>].
[:zh_CN] 对于类型 [`Sndr] 与类型包组 [`Env]，令 [`CS] 为 [`completion_signatures_of_t<Sndr, Env...>]。

[:en] Then [`[*single-sender-value-type]<Sndr, Env...>] is ill-formed if [`CS]
is ill-formed or if [`sizeof...(Env) > 1] is [`true]; otherwise, it is an alias for:
[:zh_CN] 则 [`[*single-sender-value-type]<Sndr, Env...>] 在 [`CS] 非良构或
[`sizeof...(Env) > 1] 为 [`true] 时非良构；否则，它是以下类型的别名：
[list]
[item]
[:en] [`[*gather-signatures]<set_value_t, CS, decay_t, type_identity_t>] if that
type is well-formed,
[:zh_CN] 若 [`[*gather-signatures]<set_value_t, CS, decay_t, type_identity_t>]
良构则为该类型，
[item]
[:en] Otherwise, [`void] if [`[*gather-signatures]<set_value_t, CS, tuple, variant>]
is [`variant<tuple<>>] or [`variant<>],
[:zh_CN] 否则，若 [`[*gather-signatures]<set_value_t, CS, tuple, variant>] 为
[`variant<tuple<>>] 或 [`variant<>]，则为 [`void]，
[item]
[:en] Otherwise, [`[*gather-signatures]<set_value_t, CS, [*decayed-tuple], type_identity_t>]
if that type is well-formed,
[:zh_CN] 否则，若 [`[*gather-signatures]<set_value_t, CS, [*decayed-tuple], type_identity_t>]
良构则为该类型，
[item]
[:en] Otherwise, [`[*single-sender-value-type]<Sndr, Env...>] is ill-formed.
[:zh_CN] 否则，[`[*single-sender-value-type]<Sndr, Env...>] 非良构。
[list:end]

[para]
[:en] The exposition-only concept [*:c single-sender] is defined as follows:
[:zh_CN] 仅用于阐释的概念 [*:c single-sender] 定义如下：

[codeblock]
namespace std::execution {
  template<class Sndr, class... Env>
    concept [[redoc("*:c@def>")]]single-sender = [[redoc("`:c>")]]sender_in<Sndr, Env...> &&
      requires {
        typename [[redoc("*>")]]single-sender-value-type<Sndr, Env...>;
      };
}
[codeblock:end]

[para]
[:en] A type satisfies and models the exposition-only concept
[*:c@def valid-completion-signatures] if
it is a specialization of the [`completion_signatures] class template.
[:zh_CN] 如果一个类型是 [`completion_signatures] 类模板的特例，则它满足并构成
仅用于阐释的概念 [*:c@def valid-completion-signatures]。
