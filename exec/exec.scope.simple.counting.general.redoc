[section#exec.scope.simple.counting.general
    [:en] General
    [:zh_CN] 概述
]

[%@lib execution::simple_counting_scope]
[codeblock:synopsis]
namespace std::execution {
  class simple_counting_scope {
  public:
    // [:en] [#exec.simple.counting.token], token [:zh_CN] [#exec.simple.counting.token]，令牌
    struct token;

    static constexpr size_t max_associations = [[redoc("[?impldef"
              " [:en] value of [`std::execution::simple_counting_scope::max_associations]"
            "[:zh_CN] [`std::execution::simple_counting_scope::max_associations] 的值]")]];

    // [:en] [#exec.simple.counting.ctor], constructor and destructor [:zh_CN] [#exec.simple.counting.ctor]，构造函数与析构函数
    simple_counting_scope() noexcept;
    simple_counting_scope(simple_counting_scope&&) = delete;
    ~simple_counting_scope();

    // [:en] [#exec.simple.counting.mem], members [:zh_CN] [#exec.simple.counting.mem]，成员
    token get_token() noexcept;
    void close() noexcept;
    [[redoc("`:c>")]]sender@ auto join() noexcept;

  private:
    size_t [[redoc("*>")]]count;                                       // [=expos]
    [[redoc("*>")]]scope-state-type [[redoc("*>")]]state;                             // [=expos]

    bool [[redoc("*>")]]try-associate() noexcept;                      // [=expos]
    void [[redoc("*>")]]disassociate() noexcept;                       // [=expos]
    template<class State>
      bool [[redoc("*>")]]start-join-sender(State& state) noexcept;    // [=expos]
  };
}
[codeblock:end]

[para]
[:en] For purposes of determining the existence of a data race,
[`get_token], [`close], [`join], [*try-associate], [*disassociate], and
[*start-join-sender] behave as atomic operations ([#intro.multithread]).
[:zh_CN] 为确定数据竞争是否存在，[`get_token]、[`close]、[`join]、[*try-associate]、
[*disassociate] 和 [*start-join-sender] 表现为如同原子性操作（[#intro.multithread]）。

[:en] These operations on a single object of
type [`simple_counting_scope] appear to occur in a single total order.
[:zh_CN] 单个 [`simple_counting_scope] 类型的对象上的这些操作遵循单一的全序。
