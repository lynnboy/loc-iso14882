[section#stmt.contract.assert
    [:en] Assertion statement
    [:zh_CN] 断言语句
]

[syntax]
[rule assertion-statement [:zh_CN] 断言语句 ]
    [| [`contract_assert] [~:opt attribute-specifier-seq] [`(] conditional-expression [`)] [`:] ]
[rule:end]
[syntax:end]

[para]
[:en] [%contract assertion[!statement][%assertion[!statement]]] [%assertion[!statement]]
An [~assertion-statement] introduces a contract assertion ([#basic.contract]).
[:zh_CN] [%契约断言[!语句][%断言[!语句]]] [%断言[!语句]]
一条[~断言语句]引入一条契约断言（[#basic.contract]）。

[:en] The optional [~attribute-specifier-seq] appertains to the introduced contract assertion.
[:zh_CN] 可选的[~属性说明符序列]属于所引入的契约断言。

[para]
[:en] The predicate ([#basic.contract.general]) of an [~assertion-statement]
is its [~conditional-expression] contextually converted to [`bool].
[:zh_CN] [~断言语句]的谓词（[#basic.contract.general]）为其[~条件表达式]按语境转换为 [`bool]。

[para]
[:en] The evaluation of consecutive [~assertion-statement]s is an evaluation
in sequence ([#basic.contract.eval]) of the contract assertions introduced
by those [~assertion-statement]s.
[:zh_CN] 对连续的[~断言语句]求值，按顺序评估这些[~断言语句]所引入的契约断言（[#basic.contract.eval]）。

[begin:note]
[:en] A sequence of [~assertion-statement]s can thus be repeatedly evaluated as a group.
[:zh_CN] 从而一系列的[~断言语句]可以作为整组进行重复评估。

[begin:example]
[codeblock]
int f(int i)
{
  contract_assert(i == 0);  // #1
  contract_assert(i >= 0);  // #2
  return 0;
}
int g = f(0);   // [:en] can evaluate #1, #2, #1, #2 [:zh_CN] 可以按 #1, #2, #1, #2 求值
[codeblock:end]
[end:example]
[end:note]
