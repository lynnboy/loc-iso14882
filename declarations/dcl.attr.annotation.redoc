[section#dcl.attr.annotation
    [:en] Annotations
    [:zh_CN] 标注
[%  [:en] attribute[!annotations]
    [:zh_CN] 属性[!标注] ]
]

[para]
[:en] An annotation may be applied to any declaration of a type, type alias, variable,
function, namespace, enumerator, [~base-specifier], or non-static data member.
[:zh_CN] 标注可以应用于类型、类型别名、变量、函数、命名空间、枚举符、[~基类说明符]
或非静态数据成员的任何声明式。

[para]
[:en] Let [$E] be the expression [`std::meta::reflect_constant([~constant-expression])].
[:zh_CN] 令 [$E] 为表达式 [`std::meta::reflect_constant([~constant-expression])]。

[:en] [$E] shall be a constant expression;
the result of [$E] is the [+:adj underlying[!constant]] of the annotation.
[:zh_CN] [$E] 应当是常量表达式；[$E] 的结果是该标注的[+:adj 底层[!常量]]。

[para]
[:en] Each [~annotation] produces a unique annotation.
[:zh_CN] 每个[~标注]都会生成一个唯一的标注。

[para]
[:en] Substituting into an [~annotation] is not in the immediate context.
[:zh_CN] [~标注]中的代换不在其直接语境中进行。

[begin:example]
[codeblock]
[[=1]] void f();
[[=2, =3, =2]] void g();
void g [[=4, =2]] ();
[codeblock:end]

[:en] [`f] has one annotation and [`g] has five annotations.
[:zh_CN] [`f] 有一个标注，而 [`g] 有五个标注。

[:en] These can be queried with metafunctions such as [`std::meta::annotations_of] ([#meta.reflection.annotation]).
[:zh_CN] 这些可以通过元函数进行查询，例如 [`std::meta::annotations_of] ([#meta.reflection.annotation])。
[end:example]

[begin:example]
[codeblock]
template<class T>
  [[=T::type()]] void f(T t);

void f(int);

void g() {
  f(0);         // OK
  f('0');       // [:en] error, substituting into the annotation results in an invalid expression \
                [:zh_CN] 错误，代入标注会导致无效表达式
}
[codeblock:end]
[end:example]
