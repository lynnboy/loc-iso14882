[section#dcl.init.ref
    [:en] References
    [:zh_CN] 引用

[%  [:en] initialization[!reference]
    [:zh_CN] 初始化[!引用] ]
]

[para]
[:en]
A variable whose declared type is [=lq]reference to [`T][=rq] ([#dcl.ref])
shall be initialized.
[:zh_CN]
声明为“[`T] 的引用”（[#dcl.ref]）类型的变量应当被初始化。

[begin:example]
[codeblock]
int g(int) noexcept;
void f() {
  int i;
  int& r = i;                   // [:en] [`r] refers to [`i] \
                                   [:zh_CN] [`r] 指代 [`i]
  r = 1;                        // [:en] the value of [`i] becomes [`1] \
                                   [:zh_CN] [`i] 的值变为 [`1]
  int* p = &r;                  // [:en] [`p] points to [`i] \
                                   [:zh_CN] [`p] 指向 [`i]
  int& rr = r;                  // [:en] [`rr] refers to what [`r] refers to, that is, to [`i] \
                                   [:zh_CN] [`rr] 指代 [`r] 所指代的，亦即 [`i]
  int (&rg)(int) = g;           // [:en] [`rg] refers to the function [`g] \
                                   [:zh_CN] [`rg] 指代函数 [`g]
  rg(i);                        // [:en] calls function [`g] \
                                   [:zh_CN] 调用函数 [`g]
  int a[3];
  int (&ra)[3] = a;             // [:en] [`ra] refers to the array [`a] \
                                   [:zh_CN] [`ra] 指代数组 [`a]
  ra[1] = i;                    // [:en] modifies [`a`[1`]] \
                                   [:zh_CN] 改动 [`a`[1`]]
}
[codeblock:end]
[end:example]

[para]
[:en]
A reference cannot be changed to refer to another object after initialization.
[:zh_CN]
引用不能在初始化之后被更改为指代另一个对象。

[begin:note]
[:en]
[%assignment[!reference]]
Assignment to a reference assigns to the object referred to by the reference
([#expr.ass]).
[:zh_CN]
[%赋值[!引用]]
赋值给引用将向该引用所指代的对象进行赋值（[#expr.ass]）。
[end:note]

[:en]
[%argument passing[!reference and]]
[%[`return][!reference and]]
Argument passing ([#expr.call]) and function value return ([#stmt.return]) are
initializations.
[:zh_CN]
[%实参传递[!引用与～]]
[%[`return][!引用与～]]
实参传递（[#expr.call]）和函数值返回（[#stmt.return]）都是初始化。

[para]
[:en]
The initializer can be omitted for a reference only in a parameter declaration
([#dcl.fct]), in the declaration of a function return type, in the declaration
of a class member within its class definition ([#class.mem]), and where the
[%declaration[![`extern] reference]] [`extern] specifier is explicitly used.
[:zh_CN]
引用的初始化式，只有在形参声明式中（[#dcl.fct]），函数返回类型的声明中，在类定义
式之内的类成员声明式中（[#class.mem]），以及显式使用 [%声明式[![`extern] 引用]]
[`extern] 说明符时才可以被省略。

[begin:example]
[codeblock]
int& r1;                        // [:en] error: initializer missing \
                                   [:zh_CN] 错误：缺失初始化式
extern int& r2;                 // OK
[codeblock:end]
[end:example]

[para]
[:en]
Given types [=lq][=cv cv1] [`T1][=rq] and [=lq][=cv cv2] [`T2][=rq],
[=lq][=cv cv1] [`T1][=rq] is [+reference-related] to [=lq][=cv cv2] [`T2][=rq]
if [`T1] is similar ([#conv.qual]) to [`T2], or [`T1] is a base class of [`T2].
[:zh_CN]
给定类型“[=cv cv1] [`T1]”和“[=cv cv2] [`T2]”，若 [`T1] 与 [`T2] 相似
（[#conv.qual]），或 [`T1] 是 [`T2] 的基类，则“[=cv cv1] [`T1]”就与
“[=cv cv2] [`T2]”[+引用相关]。

[:en]
[=lq][=cv cv1] [`T1][=rq] is [+reference-compatible] with [=lq][=cv cv2] [`T2][=rq]
if a prvalue of type [=lq]pointer to [=cv cv2] [`T2][=rq] can be converted to
the type [=lq]pointer to [=cv cv1] [`T1][=rq] via a standard conversion sequence
([#conv]).
[:zh_CN]
如果可以通过标准转换序列（[#conv]）将类型“[=cv cv2] [`T2] 的指针”的纯右值转换为
类型“[=cv cv1] [`T1]”，则称“[=cv cv1] [`T1]”与“[=cv cv2] [`T2]”[+引用兼容]：

[:en]
In all cases where the reference-compatible relationship
of two types is used to establish the validity of a reference binding and
the standard conversion sequence would be ill-formed,
a program that necessitates such a binding is ill-formed.
[:zh_CN]
在用两个类型的引用兼容关系来验证引用绑定的有效性，而标准转换序列非良构的任何情况
下，必须进行此种绑定的程序是非良构的。

[para]
[:en]
[%binding[!reference]]
A reference to type [=lq][=cv cv1] [`T1][=rq] is initialized by an expression of
type [=lq][=cv cv2] [`T2][=rq] as follows:
[:zh_CN]
[%绑定[!引用]]
引用类型“[=cv cv1] [`T1]”由类型“[=cv cv2] [`T2]”的表达式按如下进行初始化：

[list]
[item]
[:en]
If the reference is an lvalue reference and the initializer expression
[:zh_CN]
若该引用是左值引用，且其初始化表达式

[list]
[item]
[:en@~]
is an lvalue (but is not a bit-field), and [=lq][=cv cv1] [`T1][=rq] is
reference-compatible with [=lq][=cv cv2] [`T2][=rq], or
[:zh_CN@~]
是左值（但不是位字段），且“[=cv cv1] [`T1]”与“[=cv cv2] [`T2]”引用兼容，或

[item]
[:en@~]
has a class type (i.e., [`T2] is a class type), where [`T1] is not
reference-related to [`T2], and can be converted to an lvalue of type
[=lq][=cv cv3] [`T3][=rq], where [=lq][=cv cv1] [`T1][=rq] is
reference-compatible with [=lq][=cv cv3] [`T3][=rq][#:note#fn:$1]
[:zh_CN@~]
具有类类型（就是说，[`T2] 为类类型）（其中 [`T1] 并非与 [`T2] 引用相关），且可被
隐式转换为类型“[=cv cv3] [`T3]”的左值，其中“[=cv cv1] [`T1]”与“[=cv cv3] [`T3]”
引用兼容[#:note#fn:$1]

[note:foot#fn:$1]
[:en]
This requires a conversion function ([#class.conv.fct]) returning a reference
type.
[:zh_CN]
这要求一个返回引用类型的转换函数（[#class.conv.fct]）。
[note:end]

[:en@~]
(this conversion is selected by enumerating the applicable conversion functions
([#over.match.ref]) and choosing the best one through overload resolution
([#over.match])),
[:zh_CN@~]
（此种转换是通过列举可用的转换函数（[#over.match.ref]）并通过重载决议
（[#over.match]）选择其中最佳的一个而选取的），
[list:end]

[:en@~]
then the reference is bound to the initializer expression lvalue in the first
case and to the lvalue result of the conversion in the second case (or, in
either case, to the appropriate base class subobject of the object).
[:zh_CN@~]
则在第一种情况中，该引用被绑定到初始化式表达式左值上，而在第二种情况中被绑定到
转换结果左值上（或者任何情况中被绑定到对象的适当的基类子对象上）。

[begin:note]
[:en]
The usual lvalue-to-rvalue ([#conv.lval]), array-to-pointer ([#conv.array]), and
function-to-pointer ([#conv.func]) standard conversions are not needed, and
therefore are suppressed, when such direct bindings to lvalues are done.
[:zh_CN]
不需要进行常规的左值向右值（[#conv.lval]）、数组向指针（[#conv.array]）和函数向
指针（[#conv.func]）标准转换，因而它们在进行此种直接到左值的绑定中是被抑制的。
[end:note]

[para:~]
[begin:example]
[codeblock]
double d = 2.0;
double& rd = d;                 // [:en] [`rd] refers to [`d] \
                                   [:zh_CN] [`rd] 指代 [`d]
const double& rcd = d;          // [:en] [`rcd] refers to [`d] \
                                   [:zh_CN] [`rcd] 指代 [`d]

struct A { };
struct B : A { operator int&(); } b;
A& ra = b;                      // [:en] [`ra] refers to [`A] subobject in [`b] \
                                   [:zh_CN] [`ra] 指代 [`b] 中的 [`A] 子对象
const A& rca = b;               // [:en] [`rca] refers to [`A] subobject in [`b] \
                                   [:zh_CN] [`rca] 指代 [`b] 中的 [`A] 子对象
int& ir = B();                  // [:en] [`ir] refers to the result of [`B::operator int&] \
                                   [:zh_CN] [`ir] 指代 [`B::operator int&] 的结果
[codeblock:end]
[end:example]

[item]
[:en]
Otherwise, if the reference is an lvalue reference to a type that is not
const-qualified or is volatile-qualified, the program is ill-formed.
[:zh_CN]
否则，如果该引用是左值引用且所指代的类型并未被 const 限定或者是被 volatile 限定
的，则程序非良构。

[begin:example]
[codeblock]
double& rd2 = 2.0;              // [:en] error: not an lvalue and reference not [`const] \
                                   [:zh_CN] 错误：不是左值，且引用不为 [`const]
int  i = 2;
double& rd3 = i;                // [:en] error: type mismatch and reference not [`const] \
                                   [:zh_CN] 错误：类型不匹配，且引用不为 [`const]
[codeblock:end]
[end:example]

[item]
[:en]
Otherwise, if the initializer expression
[:zh_CN]
否则，若其初始化式表达式

[list]
[item]
[:en@~]
is an rvalue (but not a bit-field) or function lvalue and [=lq][=cv cv1] [`T1][=rq]
is reference-compatible with [=lq][=cv cv2] [`T2][=rq], or
[:zh_CN@~]
是右值（但并非位字段）或函数左值，且“[=cv cv1] [`T1]”与“[=cv cv2] [`T2]”引用兼容，
或者

[item]
[:en@~]
has a class type (i.e., [`T2] is a class type), where [`T1] is not
reference-related to [`T2], and can be converted to an rvalue or function lvalue
of type [=lq][=cv cv3] [`T3][=rq], where [=lq][=cv cv1] [`T1][=rq] is
reference-compatible with [=lq][=cv cv3] [`T3][=rq] (see [#over.match.ref]),
[:zh_CN@~]
具有类类型（就是说，[`T2] 为类类型）（其中 [`T1] 并非与 [`T2] 引用相关），且可被
隐式转换为类型“[=cv cv3] [`T3]”的右值或函数左值，其中“[=cv cv1] [`T1]”与
“[=cv cv3] [`T3]”引用兼容（参见 [#over.match.ref]），
[list:end]

[:en@~]
then the value of the initializer expression in the first case and the result of
the conversion in the second case is called the converted initializer.
[:zh_CN@~]
第一种情况中的初始化式表达式的值，以及第二种情况中的转换结果被称为经转换的
初始化式。

[:en]
If the converted initializer is a prvalue, its type [`T4] is adjusted to type
[=lq][=cv cv1] [`T4][=rq] ([#conv.qual]) and the temporary materialization
conversion ([#conv.rval]) is applied.
[:zh_CN]
如果经转换的初始化式是纯右值，则其类型 [`T4] 被调整为类型“[=cv cv1] [`T4]”
（[#conv.qual]），并实施临时对象实质化转换（[#conv.rval]）。

[:en]
In any case, the reference is bound to the resulting glvalue (or to an
appropriate base class subobject).
[:zh_CN]
无论哪种情况，该引用都被绑定到所产生的泛左值上（或者绑定到适当的基类子对象上）。

[para:~]
[begin:example]
[codeblock]
struct A { };
struct B : A { } b;
extern B f();
const A& rca2 = f();                // [:en] bound to the [`A] subobject of the [`B] rvalue. \
                                       [:zh_CN] 绑定到 [`B] 右值的 [`A] 子对象上。
A&& rra = f();                      // [:en] same as above \
                                       [:zh_CN] 同上
struct X {
  operator B();
  operator int&();
} x;
const A& r = x;                     // [:en] bound to the [`A] subobject of the result of the conversion \
                                       [:zh_CN] 绑定到转换结果的 [`A] 子对象上
int i2 = 42;
int&& rri = static_cast<int&&>(i2); // [:en] bound directly to [`i2] \
                                       [:zh_CN] 直接绑定到 [`i2]
B&& rrb = x;                        // [:en] bound directly to the result of [`operator B] \
                                       [:zh_CN] 直接绑定到 [`operator B] 的结果上
[codeblock:end]
[end:example]

[item]
[:en]
Otherwise:
[:zh_CN]
否则：

[list]
[item]
[:en]
If [`T1] or [`T2] is a class type and [`T1] is not reference-related to [`T2],
user-defined conversions are considered using the rules for copy-initialization
of an object of type [=lq][=cv cv1] [`T1][=rq] by user-defined conversion
([#dcl.init], [#over.match.copy], [#over.match.conv]); the program is ill-formed
if the corresponding non-reference copy-initialization would be ill-formed.
[:zh_CN]
当 [`T1] 和 [`T2] 为类类型，且 [`T1] 并非与 [`T2] 引用相关时，考察用户定义转换并
遵循对“[=cv cv1] [`T1]”类型的对象使用用户定义转换进行复制初始化的规则
（[#dcl.init]，[#over.match.copy]，[#over.match.conv]）；如果其对应的非引用的
复制初始化非良构，则程序非良构。

[:en]
The result of the call to the conversion function, as described for the
non-reference copy-initialization, is then used to direct-initialize the
reference.
[:zh_CN]
调用转换函数的结果（根据非引用复制初始化的描述），随即被用于直接初始化该引用。

[:en]
For this direct-initialization, user-defined conversions are not considered.
[:zh_CN]
这个直接初始化中不考虑用户定义转换。

[item]
[:en]
Otherwise, the initializer expression is implicitly converted to a prvalue
of type [=lq][=cv cv1] [`T1][=rq].
[:zh_CN]
否则，初始化式表达式被隐式转换为类型“[=cv cv1] [`T1]”的纯右值。

[:en]
The temporary materialization conversion is applied and the reference is bound
to the result.
[:zh_CN]
实施临时对象实质化转换，并将引用绑定到其结果上。
[list:end]

[:en]
If [`T1] is reference-related to [`T2]:
[:zh_CN]
若 [`T1] 与 [`T2] 引用相关：

[list]
[item]
[:en@~]
[=cv cv1] shall be the same cv-qualification as, or greater cv-qualification
than, [=cv cv2]; and
[:zh_CN@~]
则 [=cv cv1] 应当具有与 [=cv cv2] 相同的 cv 限定，或更强的 cv 限定，并且

[item]
[:en@~]
if the reference is an rvalue reference, the initializer expression shall not be
an lvalue.
[:zh_CN@~]
若该引用是右值引用，则初始化式表达式不能是左值。
[list:end]

[begin:example]
[codeblock]
struct Banana { };
struct Enigma { operator const Banana(); };
struct Alaska { operator Banana&(); };
void enigmatic() {
  typedef const Banana ConstBanana;
  Banana &&banana1 = ConstBanana(); // [:en] error \
                                       [:zh_CN] 错误
  Banana &&banana2 = Enigma();      // [:en] error \
                                       [:zh_CN] 错误
  Banana &&banana3 = Alaska();      // [:en] error \
                                       [:zh_CN] 错误
}

const double& rcd2 = 2;             // [:en] [`rcd2] refers to temporary with value [`2.0] \
                                       [:zh_CN] [`rcd2] 指代值为 [`2.0] 的临时对象
double&& rrd = 2;                   // [:en] [`rrd] refers to temporary with value [`2.0] \
                                       [:zh_CN] [`rrd] 指代值为 [`2.0] 的临时对象
const volatile int cvi = 1;
const int& r2 = cvi;                // [:en] error: cv-qualifiers dropped \
                                       [:zh_CN] 错误：cv 限定符被丢弃
struct A { operator volatile int&(); } a;
const int& r3 = a;                  // [:en] error: cv-qualifiers dropped \
                                       [:zh_CN] 错误：cv 限定符被从
                                    // [:en@~] from result of conversion function \
                                       [:zh_CN@~] 转换函数的结果丢弃
double d2 = 1.0;
double&& rrd2 = d2;                 // [:en] error: initializer is lvalue of related type \
                                       [:zh_CN] 错误：初始化式为相关类型的左值
struct X { operator int&(); };
int&& rri2 = X();                   // [:en] error: result of conversion function is lvalue of related type \
                                       [:zh_CN] 错误：转换函数的结果为相关类型的左值
int i3 = 2;
double&& rrd3 = i3;                 // [:en] [`rrd3] refers to temporary with value [`2.0] \
                                       [:zh_CN] [`rrd3] 指代值为 [`2.0] 的临时对象
[codeblock:end]
[end:example]

[list:end]

[:en]
In all cases except the last (i.e., implicitly converting the initializer
expression to the referenced type), the reference is said to [+bind directly] to
the initializer expression.
[:zh_CN]
除了最后一种（即将初始化式表达式隐式转换为被引用类型）之外的所有情况中，称该引用
被[+直接绑定]到初始化式表达式上。

[para]
[begin:note]
[:en]
[#class.temporary] describes the lifetime of temporaries bound to references.
[:zh_CN]
[#class.temporary] 说明绑定到引用上的临时对象的生存期。
[end:note]
