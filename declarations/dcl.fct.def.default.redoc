[section#dcl.fct.def.default
    [:en] Explicitly-defaulted functions
    [:zh_CN] 显式预置的函数
]

[para]
[:en]
A function definition whose [~function-body] is of the form [`= default ;]
is called an [+explicitly-defaulted[%definition[!function
[!explicitly-defaulted]]]] definition.
[:zh_CN]
若函数定义式的[~函数体]的形式为 [`= default ;]，则被称为[+显式预置的
[%定义式[!函数[!显式预置的～]]]]定义式。

[:en]
A function that is explicitly defaulted shall
[:zh_CN]
显式预置的函数应当

[list]
[item]
[:en@~] be a special member function or a comparison operator
([#expr.spaceship], [#expr.rel], [#expr.eq]), and
[:zh_CN@~] 是特殊成员函数，或比较运算符（[#expr.spaceship]，[#expr.rel]，
[#expr.eq]），以及

[item]
[:en@~] not have default arguments.
[:zh_CN@~] 没有默认实参。
[list:end]

[para]
[:en]
The type [`T][$_1] of an explicitly defaulted function [`F] is allowed to differ
from the type [`T][$_2] it would have had if it were implicitly declared, as
follows:
[:zh_CN]
允许显式预置的函数 [`F] 的类型 [`T][$_1] 与当它被隐式声明式的类型 [`T][$_2] 有
如下区别：

[list]
[item]
[:en] [`T][$_1] and [`T][$_2] may have differing [~ref-qualifier]s;
[:zh_CN] [`T][$_1] 和 [`T][$_2] 可以有不同的[~引用限定符]；
[item]
[:en] [`T][$_1] and [`T][$_2] may have differing exception specifications; and
[:zh_CN] [`T][$_1] 和 [`T][$_2] 可以有不同的异常说明；并且
[item]
[:en] if [`T][$_2] has a parameter of type [`const C&], the corresponding
parameter of [`T][$_1] may be of type [`C&].
[:zh_CN] 若 [`T][$_2] 具有某个 [`const C&] 类型的形参，则 [`T][$_1] 的对应形参
可以具有类型 [`C&]。
[list:end]

[:en]
If [`T][$_1] differs from [`T][$_2] in any other way, then:
[:zh_CN]
如果 [`T][$_1] 和 [`T][$_2] 在任何其他方面不同，则：

[list]
[item]
[:en] if [`F] is an assignment operator, and the return type of [`T][$_1]
differs from the return type of [`T][$_2] or [`T][$_1][=']s parameter type is
not a reference, the program is ill-formed;
[:zh_CN] 如果 [`F] 是赋值运算符，且 [`T][$_1] 的返回类型与 [`T][$_2] 的返回类型
不同，或者 [`T][$_1] 的形参类型并非引用，则程序非良构；
[item]
[:en] otherwise, if [`F] is explicitly defaulted on its first declaration, it is
defined as deleted;
[:zh_CN] 否则，如果 [`F] 在其首个声明式中被显式预置，则它被定义为弃置的；
[item]
[:en] otherwise, the program is ill-formed.
[:zh_CN] 否则，程序非良构。
[list:end]

[para]
[:en]
An explicitly-defaulted function that is not defined as deleted may be declared
[`constexpr] or [`consteval] only if it would have been implicitly declared as
[`constexpr].
[:zh_CN]
仅当函数被隐式声明时应当为 [`constexpr] 或 [`consteval] 时，并未被声明为弃置的
显式预置函数才能被声明为 [`constexpr]。

[:en]
If a function is explicitly defaulted on its first declaration, it is implicitly
considered to be [`constexpr] if the implicit declaration would be.
[:zh_CN]
如果某个函数的首个声明式即为显式预置的，则当它的隐式声明式本应为 [`constexpr]
时，它被隐含地当作是 [`constexpr] 的。

[para]
[enter:example]
[codeblock]
struct S {
  constexpr S() = default;              // [:en] ill-formed: implicit [`S()] is not [`constexpr]
                                        // [|:zh_CN] 非良构：隐式的 [`S()] 并非 [`constexpr]
  S(int a = 0) = default;               // [:en] ill-formed: default argument
                                        // [|:zh_CN] 非良构：默认实参
  void operator=(const S&) = default;   // [:en] ill-formed: non-matching return type
                                        // [|:zh_CN] 非良构：返回类型不匹配
  ~S() throw(int) = default;            // [:en] OK, despite mismatched exception specification
                                        // [|:zh_CN] OK，尽管其异常说明不匹配
private:
  int i;
  S(S&);                                // [:en] OK: private copy constructor
                                        // [|:zh_CN] OK：私有的复制构造函数
};
S::S(S&) = default;                     // [:en] OK: defines copy constructor
                                        // [|:zh_CN] OK：定义复制构造函数

struct T {
  T();
  T(T &&) noexcept(false);
};
struct U {
  T t;
  U();
  U(U &&) noexcept = default;
};
U u1;
U u2 = static_cast<U&&>(u1);            // [:en] OK, calls [`std::terminate] if [`T::T(T&&)] throws
                                        // [|:zh_CN] OK，当 [`T::T(T&&)] 抛出异常时调用 [`std::terminate]
[codeblock:end]
[exit:example]

[para]
[:en]
Explicitly-defaulted functions and implicitly-declared functions are
collectively called [+defaulted] functions, and the implementation shall provide
implicit definitions for them ([#class.ctor] [#class.dtor], [#class.copy.ctor],
[#class.copy.assign]), which might mean defining them as deleted.
[:zh_CN]
显式预置的函数和隐式声明的函数统称为[+预置]函数，且实现应当为它们提供隐式定义
（[#class.ctor]，[#class.dtor]，[#class.copy.ctor]，[#class.copy.assing]），这
也可能意味着将它们定义为弃置的。

[:en]
A function is [+user-provided] if it is user-declared and not explicitly
defaulted or deleted on its first declaration.
[:zh_CN]
若函数是由用户声明的，并且其首个声明式并未显式地预置或弃置，则它是[+用户提供的]。

[:en]
A user-provided explicitly-defaulted function (i.e., explicitly defaulted after
its first declaration) is defined at the point where it is explicitly defaulted;
if such a function is implicitly defined as deleted, the program is ill-formed.
[:zh_CN]
用户提供的显式预置函数（就是说，在其首个声明式之后才被显式预置的函数），是在其被
显式预置之处定义的；若该函数被隐式定义为弃置的，则程序非良构。

[enter:note]
[:en]
Declaring a function as defaulted after its first declaration can provide
efficient execution and concise definition while enabling a stable binary
interface to an evolving code base.
[:zh_CN]
在函数的首个声明式之后将其声明为预置的，使得可以提供高效的执行和清晰的定义，同时
能够为演化中的代码基提供一个稳定的二进制接口。
[exit:note]

[para]
[enter:example]
[codeblock]
struct trivial {
  trivial() = default;
  trivial(const trivial&) = default;
  trivial(trivial&&) = default;
  trivial& operator=(const trivial&) = default;
  trivial& operator=(trivial&&) = default;
  ~trivial() = default;
};

struct nontrivial1 {
  nontrivial1();
};
nontrivial1::nontrivial1() = default;   // [:en] not first declaration
                                        // [|:zh_CN] 不是其首个声明式
[codeblock:end]
[exit:example]
