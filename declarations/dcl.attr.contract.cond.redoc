[section#dcl.attr.contract.cond
    [:en] Contract conditions
    [:zh_CN] 契约条件
]

[para]
[:en]
A [+contract condition] is a precondition or a postcondition.
[:zh_CN]
[+契约条件]是前条件或后条件。

[:en]
The first declaration of a function shall specify all contract conditions
(if any) of the function.
[:zh_CN]
某个函数的首个声明式中应当指定该函数的所有契约条件（如果有）。

[:en]
Subsequent declarations shall either specify no contract conditions or the same
list of contract conditions; no diagnostic is required if corresponding
conditions will always evaluate to the same value.
[:zh_CN]
后续的声明式应当要么不指定契约条件，要么指定相同的契约条件列表；如果对应的条件
总是求值为相同值则无需诊断。

[:en]
The list of contract conditions of a function shall be the same
if the declarations of that function appear in different translation units;
no diagnostic required.
[:zh_CN]
如果在不同翻译单元中出现了某个函数的声明式，则该函数的契约条件的列表应当相同；
无须诊断。

[:en]
If a friend declaration is the first declaration of the function in a
translation unit and has a contract condition, the declaration shall be a
definition and shall be the only declaration of the function in the translation
unit.
[:zh_CN]
如果某个友元声明式时函数在某个翻译单元中的首个声明式并且它带有一个契约条件，则
该声明式应当是定义式，并且应当是该翻译单元中该函数的唯一声明式。

[para]
[:en]
Two lists of contract conditions are the same if they consist of the same
contract conditions in the same order.
[:zh_CN]
如果两个契约条件列表有相同的契约条件以相同顺序构成，则它们相同。

[:en]
Two contract conditions are the same if their contract levels are the same and
their predicates are the same.
[:zh_CN]
如果两个契约条件的契约级别相同，且其谓词相同，则它们相同。

[:en]
Two predicates contained in [~contract-attribute-specifier]s are the same
if they would satisfy the one-definition rule ([#basic.def.odr]) were they to
appear in function definitions, except for renaming of parameters, return value
identifiers (if any), and template parameters.
[:zh_CN]
[~契约特性说明符]中包含的两个谓词，如果它们出现于函数定义式中时，除了形参、
返回值的标识符（如果有）以及模板形参的重新命名之外，可以满足唯一定义原则
（[#basic.def.odr]），则它们相同。

[para]
[enter:note]
[:en]
A function pointer cannot include contract conditions.
[:zh_CN]
函数指针不能包含契约条件。

[enter:example]
[codeblock]
typedef int (*fpt)() [[ensures r: r != 0]];     // [:en] error: contract condition not on a function declaration
                                                // [|:zh_CN] 错误：契约条件并非在函数声明式中

int g(int x) 
  [[expects: x >= 0]] 
  [[ensures r: r > x]]
{
  return x+1;
}

int (*pf)(int) = g;                             // OK
int x = pf(5);                                  // [:en] contract conditions of [`g] are checked
                                                // [|:zh_CN] 检查 [`g] 的契约条件
[codeblock:end]
[exit:example]
[exit:note]

[para]
[:en]
The predicate of a contract condition has the same semantic restrictions as if
it appeared as the first [~expression-statement] in the body of the function it
applies to.
[:zh_CN]
契约条件的谓词具有如同当它作为其所应用的函数的函数体中的第一个[~表达式语句]时
相同的语义限制。

[para]
[:en]
A precondition is checked by evaluating its predicate immediately before
starting evaluation of the function body.
[:zh_CN]
对前条件的检查是通过在函数体的求值之前立即对其谓词求值而进行的。

[enter:note]
[:en]
The function body includes the [~function-try-block] ([#except]) and the
[~ctor-initializer] ([#class.base.init]).
[:zh_CN]
函数体包括[~函数-try-块]（[#except]）和[~构造函数初始化式]（[#class.base.init]）
。
[exit:note]

[:en]
A postcondition is checked by evaluating its predicate immediately before
returning control to the caller of the function.
[:zh_CN]
对后条件的检查是通过在将控制返回给函数的调用方之前立即对其谓词求值而进行的。

[enter:note]
[:en]
The lifetime of local variables and temporaries has ended.
[:zh_CN]
局部变量和临时对象的生存期已经结束。

[:en]
Exiting via an exception or via [`longjmp] ([#csetjmp.syn]) is not considered
returning control to the caller of the function.
[:zh_CN]
通过异常或 [`longjmp]（[#csetjmp.syn]）造成的退出并不被当做是将控制返回给函数的
调用方。
[exit:note]

[para]
[:en]
If a function has multiple preconditions, their evaluation (if any) will be
performed in the order they appear lexically.
[:zh_CN]
当函数有多个前条件时，它们的求值（如果有）将以其词法出现次序进行。

[:en]
If a function has multiple postconditions, their evaluation (if any) will be
performed in the order they appear lexically.
[:zh_CN]
当函数有多个后条件时，它们的求值（如果有）将以其词法出现次序进行。

[enter:example]
[codeblock]
void f(int * p)
  [[expects: p != nullptr]]                     // #1
  [[ensures: *p == 1]]                          // #3
  [[expects: *p == 0]]                          // #2
{
  *p = 1;
}
[codeblock:end]
[exit:example]

[para]
[:en]
If a postcondition odr-uses ([#basic.def.odr]) a parameter in its predicate and
the function body makes direct or indirect modifications of the value of that
parameter, the behavior is undefined.
[:zh_CN]
如果后条件在其谓词中 ODR-式使用（[#basic.def.odr]）了某个形参，而函数体中直接或
间接改动了这个形参的值，则其行为未定义。

[enter:example]
[codeblock]
int f(int x)
  [[ensures r: r == x]]
{
  return ++x;                   // [:en] undefined behavior
                                // [|:zh_CN] 未定义行为
}

int g(int * p)
  [[ensures r: p != nullptr]]
{
  *p = 42;                      // [:en] OK, p is not modified
                                // [|:zh_CN] OK，并未改动 [`p]
}

int h(int x)
  [[ensures r: r == x]]
{
  potentially_modify(x);        // [:en] undefined behavior if [`x] is modified
                                // [|:zh_CN] 如果 [`x] 被改动则为未定义行为
  return x;
}
[codeblock:end]
[exit:example]
