[section#dcl.attr.contract
    [:en] Contract attributes
    [:zh_CN] 契约特性标注

[%:begin#attribute.contracts
    [:en] attribute[!contracts]
    [:zh_CN] 特性标注[!契约] ]
]

[para]
[:en]
Contract attributes are used to specify preconditions, postconditions, and
assertions for functions.
[:zh_CN]
契约特性标注用于为函数指定前条件、后条件和断言。

[syntax]
[rule contract-attribute-specifier [:zh_CN] 契约特性说明符 ]
    [| [``[] [``[] [`expects] [~:opt contract-level] [`:] conditional-expression [``]] [``]] ]
    [| [``[] [``[] [`ensures] [~:opt contract-level] [~:opt identifier] [`:] conditional-expression [``]] [``]] ]
    [| [``[] [``[] [`assert] [~:opt contract-level] [`:] conditional-expression [``]] [``]] ]
[rule:end]

[rule contract-level [:zh_CN] 契约级别 ]
    [| [`default] ]
    [| [`audit] ]
    [| [`axiom] ]
[rule:end]
[syntax:end]

[:en]
An ambiguity between a [~contract-level] and an [~identifier] is resolved in
favor of [~contract-level].
[:zh_CN]
[~契约级别]和[~标识符]之间的歧义按照[~契约级别]优先来解决。

[para]
[:en]
A [~contract-attribute-specifier] using [`expects] is a [+precondition].
[:zh_CN]
使用 [`expects] 的[~契约特性说明符]是一个[+前条件]。

[:en]
It expresses a function[=']s expectation on its arguments and/or the state of
other objects using a predicate that is intended to hold upon entry into the
function.
[:zh_CN]
它表达的是函数对其实参以及其他对象的状态的预期，所使用的是预计在函数的入口采用的
谓词。

[para]
[:en]
A [~contract-attribute-specifier] using [`ensures] is a [+postcondition].
[:zh_CN]
使用 [`ensures] 的[~契约特性说明符]是一个[+后条件]。

[:en]
It expresses a condition that a function should ensure for the return value
and/or the state of objects using a predicate that is intended to hold upon exit
from the function.
[:zh_CN]
它表达的是函数对其返回值以及其他对象的状态应当保证达成的条件，所使用的是预计在从
函数退出时采用的谓词。

[:en]
A postcondition may introduce an identifier to represent the glvalue result or
the prvalue result object of the function.
[:zh_CN]
后条件可以引入一个标识符以表示函数的泛左值结果或者纯右值结果对象。

[enter:example]
[codeblock]
int f(char * c)
  [[ensures res: res > 0 && c != nullptr]];

int g(double * p)
  [[ensures audit res: res != 0 && p != nullptr && *p <= 0.0]];
[codeblock:end]
[exit:example]

[para]
[:en]
A [~contract-attribute-specifier] using [`assert] is an [+assertion].
[:zh_CN]
使用 [`assert] 的[~契约特性说明符]是一个[+断言]。

[:en]
It expresses a condition that is intended to be satisfied where it appears in a
function body.
[:zh_CN]
它表达的是预计在函数体中其所出现的位置应当得以满足的条件。

[para]
[:en]
Preconditions, postconditions, and assertions are collectively called
[+contracts[!contract]].
[:zh_CN]
前条件、后条件和断言统称为[+契约]。

[:en]
The [~conditional-expression] in a contract is contextually converted to [`bool]
([#conv]); the converted expression is called the [+predicate[%contract
[!predicate]]] of the contract.
[:zh_CN]
契约中的[~条件表达式]被按语境转换为 [`bool]（[#conv]）；转换后的表达式称为该契约
的[+谓词[%契约[!谓词]]]。

[enter:note]
[:en]
The predicate of a contract is potentially evaluated ([#basic.def.odr]).
[:zh_CN]
契约的谓词是潜在求值的（[#basic.def.odr]）。
[exit:note]

[para]
[:en]
A [+contract condition] is a precondition or a postcondition.
[:zh_CN]
[+契约条件]是前条件或后条件。

[:en]
A contract condition may be applied to the function type of a function
declaration.
[:zh_CN]
可以将契约条件实施与函数声明式的函数类型上。

[:en]
The first declaration of a function shall specify all contract conditions
(if any) of the function.
[:zh_CN]
某个函数的首个声明式中应当指定该函数的所有契约条件（如果有）。

[:en]
Subsequent declarations shall either specify no contract conditions or the same
list of contract conditions; no diagnostic is required if corresponding
conditions will always evaluate to the same value.
[:zh_CN]
后续的声明式应当要么不指定契约条件，要么指定相同的契约条件列表；如果对应的条件
总是求值为相同值则无需诊断。

[:en]
The list of contract conditions of a function shall be the same
if the declarations of that function appear in different translation units;
no diagnostic required.
[:zh_CN]
如果在不同翻译单元中出现了某个函数的声明式，则该函数的契约条件的列表应当相同；
无须诊断。

[:en]
If a friend declaration is the first declaration of the function in a
translation unit and has a contract condition, the declaration shall be a
definition and shall be the only declaration of the function in the translation
unit.
[:zh_CN]
如果某个友元声明式时函数在某个翻译单元中的首个声明式并且它带有一个契约条件，则
该声明式应当是定义式，并且应当是该翻译单元中该函数的唯一声明式。

[para]
[:en]
Two lists of contract conditions are the same if they consist of the same
contract conditions in the same order.
[:zh_CN]
如果两个契约条件列表有相同的契约条件以相同顺序构成，则它们相同。

[:en]
Two contract conditions are the same if their contract levels are the same and
their predicates are the same.
[:zh_CN]
如果两个契约条件的契约级别相同，且其谓词相同，则它们相同。

[:en]
Two predicates contained in [~contract-attribute-specifier]s are the same
if they would satisfy the one-definition rule ([#basic.def.odr]) were they to
appear in function definitions, except for renaming of parameters, return value
identifiers (if any), and template parameters.
[:zh_CN]
[~契约特性说明符]中包含的两个谓词，如果它们出现于函数定义式中时，除了形参、
返回值的标识符（如果有）以及模板形参的重新命名之外，可以满足唯一定义原则
（[#basic.def.odr]），则它们相同。

[para]
[enter:note]
[:en]
A function pointer cannot include contract conditions.
[:zh_CN]
函数指针不能包含契约条件。

[enter:example]
[codeblock]
typedef int (*fpt)() [[ensures r: r != 0]];     // [:en] error: contract condition not on a function declaration
                                                // [|:zh_CN] 错误：契约条件并非在函数声明式中

int g(int x) 
  [[expects: x >= 0]] 
  [[ensures r: r > x]]
{
  return x+1;
}

int (*pf)(int) = g;                             // OK
int x = pf(5);                                  // [:en] contract conditions of [`g] are checked
                                                // [|:zh_CN] 检查 [`g] 的契约条件
[codeblock:end]
[exit:example]
[exit:note]

[para]
[:en]
The predicate of a contract condition has the same semantic restrictions as if
it appeared as the first [~expression-statement] in the body of the function it
applies to.
[:zh_CN]
契约条件的谓词具有如同当它作为其所应用的函数的函数体中的第一个[~表达式语句]时
相同的语义限制。

[:en]
Additional access restrictions apply to names appearing in a contract condition
of a member function of class [`C]:
[:zh_CN]
类 [`C] 的成员函数的契约条件中所出现的名字，还适用以下额外的访问限制：

[list]
[item]
[:en] Friendship is not considered ([#class.friend]).
[:zh_CN] 不考虑友元关系（[#class.friend]）。

[item]
[:en] For a contract condition of a public member function, no member of [`C] or
of an enclosing class of [`C] is accessible unless it is a public member of
[`C], or a member of a base class accessible as a public member of [`C]
([#class.access.base]).
[:zh_CN] 对于公开成员函数的契约条件，[`C] 或 [`C] 的外围类的成员，除非作为 [`C]
的公开成员或可以作为 [`C] 的公开成员进行访问的基类成员（[#class.access.base]），
否则都不能访问。

[item]
[:en] For a contract condition of a protected member function, no member of [`C]
or of an enclosing class of [`C] is accessible unless it is a public or
protected member of [`C], or a member of a base class accessible as a public or
protected member of [`C].
[:zh_CN] 对于受保护成员函数的契约条件，[`C] 或 [`C] 的外围类的成员，除非作为
[`C] 的公开或受保护成员，或者可以作为 [`C] 的公开或受保护成员进行访问的基类成员，
否则都不能访问。
[list:end]

[:en]
For names appearing in a contract condition of a non-member function, friendship
is not considered.
[:zh_CN]
对于非成员函数的契约条件中出现的名字，不考虑友元关系。

[enter:example]
[codeblock]
class X {
public:
  int v() const;
  void f() [[expects: x > 0]];                  // [:en] error: [`x] is private
                                                // [|:zh_CN] 错误：[`x] 为私有
  void g() [[expects: v() > 0]];                // OK
  friend void r(int z) [[expects: z > 0]];      // OK
  friend void s(int z) [[expects: z > x]];      // [:en] error: [`x] is private
                                                // [|:zh_CN] 错误：[`x] 为私有
protected:
  int w();
  void h() [[expects: x > 0]];                  // [:en] error: [`x] is private
                                                // [|:zh_CN] 错误：[`x] 为私有
  void i() [[ensures: y > 0]];                  // OK
  void j() [[ensures: w() > 0]];                // OK
  int y;
private:
  void k() [[expects: x > 0]];                  // OK
  int x;
};

class Y : public X {
public:
  void a() [[expects: v() > 0]];                // OK
  void b() [[ensures: w() > 0]];                // [:en] error: [`w] is protected
                                                // [|:zh_CN] 错误：[`w] 为受保护
protected:
  void c() [[expects: w() > 0]];                // OK
};
[codeblock:end]
[exit:example]

[para]
[:en]
A precondition is checked by evaluating its predicate immediately before
starting evaluation of the function body.
[:zh_CN]
对前条件的检查是通过在函数体的求值之前立即对其谓词求值而进行的。

[enter:note]
[:en]
The function body includes the [~function-try-block] ([#except]) and the
[~ctor-initializer] ([#class.base.init]).
[:zh_CN]
函数体包括[~函数-try-块]（[#except]）和[~构造函数初始化式]（[#class.base.init]）
。
[exit:note]

[:en]
A postcondition is checked by evaluating its predicate immediately before
returning control to the caller of the function.
[:zh_CN]
对后条件的检查是通过在将控制返回给函数的调用方之前立即对其谓词求值而进行的。

[enter:note]
[:en]
The lifetime of local variables and temporaries has ended.
[:zh_CN]
局部变量和临时对象的生存期已经结束。

[:en]
Exiting via an exception or via [`longjmp] ([#csetjmp.syn]) is not considered
returning control to the caller of the function.
[:zh_CN]
通过异常或 [`longjmp]（[#csetjmp.syn]）造成的退出并不被当做是将控制返回给函数的
调用方。
[exit:note]

[para]
[:en]
If a function has multiple preconditions, their evaluation (if any) will be
performed in the order they appear lexically.
[:zh_CN]
当函数有多个前条件时，它们的求值（如果有）将以其词法出现次序进行。

[:en]
If a function has multiple postconditions, their evaluation (if any) will be
performed in the order they appear lexically.
[:zh_CN]
当函数有多个后条件时，它们的求值（如果有）将以其词法出现次序进行。

[enter:example]
[codeblock]
void f(int * p)
  [[expects: p != nullptr]]                     // #1
  [[ensures: *p == 1]]                          // #3
  [[expects: *p == 0]]                          // #2
{
  *p = 1;
}
[codeblock:end]
[exit:example]

[para]
[:en]
An assertion may be applied to a null statement ([#stmt.expr]).
[:zh_CN]
断言可以应用到空语句上（[#stmt.expr]）。

[:en]
An assertion is checked by evaluating its predicate as part of the evaluation of
the null statement it applies to.
[:zh_CN]
对断言的检查，是作为其所应用的空语句的求值的一部分而对其谓词求值来进行的。

[para]
[:en]
The only side effects of a predicate that are allowed in a
[~contract-attribute-specifier] are modifications of non-volatile objects
whose lifetime began and ended within the evaluation of the predicate.
[:zh_CN]
[~契约特性说明符]中所允许的唯一谓词的副作用，是对生存期的开始和结束都处于该谓词
的求值之内的非 volatile 对象的改动。

[:en]
An evaluation of a predicate that exits via an exception invokes
[`std::terminate()] ([#except.terminate]).
[:zh_CN]
当谓词的求值以异常而退出时调用 [`std::terminate()]（[#except.terminate]）。

[:en]
The behavior of any other side effect is undefined.
[:zh_CN]
任何其他副作用的行为都是未定义的。

[enter:example]
[codeblock]
void push(int x, queue & q)
  [[expects: !q.full()]]
  [[ensures: !q.empty()]]
{
  /* ... */
  [[assert: q.is_valid()]];
  /* ... */
}

int min = -42;
constexpr int max = 42;

constexpr int g(int x)
  [[expects: min <= x]]                         // [:en] error
                                                // [|:zh_CN] 错误
  [[expects: x < max]]                          // OK
{
  /* ... */
  [[assert: 2*x < max]];
  [[assert: ++min > 0]];                        // [:en] undefined behavior
                                                // [|:zh_CN] 未定义行为
  /* ... */
}
[codeblock:end]
[exit:example]

[para]
[:en]
If a postcondition odr-uses ([#basic.def.odr]) a parameter value in its
predicate and the function body makes direct or indirect modifications of that
value, the behavior is undefined.
[:zh_CN]
如果后条件在其谓词中 ODR-式使用（[#basic.def.odr]）了某个形参的值，而函数体中
直接或间接改动了这个值，则其行为未定义。

[enter:example]
[codeblock]
int f(int x)
  [[ensures r: r == x]]
{
  return ++x;                   // [:en] undefined behavior
                                // [|:zh_CN] 未定义行为
}

int g(int * p)
  [[ensures r: p != nullptr]]
{
  *p = 42;                      // [:en] OK, p is not modified
                                // [|:zh_CN] OK，并未改动 [`p]
}

int h(int x)
  [[ensures r: r == x]]
{
  potentially_modify(x);        // [:en] undefined behavior if [`x] is modified
                                // [|:zh_CN] 如果 [`x] 被改动则为未定义行为
  return x;
}
[codeblock:end]
[exit:example]

[para]
[:en]
If the [~contract-level] of a [~contract-attribute-specifier] is absent, it is
assumed to be [`default].
[:zh_CN]
如果[~契约特性说明符]中没有[~契约级别]，则假定为 [`default]。

[enter:note]
[:en]
A [`default] [~contract-level] is expected to be used for those contracts where
the cost of run-time checking is assumed to be small (or at least not expensive)
compared to the cost of executing the function.
[:zh_CN]
[~契约级别] [`default] 预期被用于那些假定其运行时检查的成本与函数执行的成本相比
较小（或至少不高昂）的契约。

[:en]
An [`audit] [~contract-level] is expected to be used for those contracts where
the cost of run-time checking is assumed to be large (or at least significant)
compared to the cost of executing the function.
[:zh_CN]
[~契约级别] [`audit] 预期被用于那些假定其运行时检查的成本与函数执行的成本相比
较大（或至少显著）的契约。

[:en]
An [`axiom] [~contract-level] is expected to be used for those contracts that
are formal comments and are not evaluated at run-time.
[:zh_CN]
[~契约级别] [`axiom] 预期被用于那些作为形式化的代码注释而并不在运行时求值的契约。
[exit:note]

[para]
[:en]
Multiple contract conditions may be applied to a function type with the same or
different [~contract-level]s.
[:zh_CN]
可以对一个函数类型以相同或不同的[~契约级别]应用多个契约条件。

[enter:example]
[codeblock]
int z;

bool is_prime(int k);

void f(int x)
  [[expects: x > 0]]
  [[expects audit: is_prime(x)]]
  [[ensures: z > 10]]
{
  /* ... */
}
[codeblock:end]
[exit:example]

[para]
[:en]
A translation may be performed with one of the following [+build levels[%build
level]]: [$off], [$default], or [$audit].
[:zh_CN]
一次翻译可以根据以下[+构建级别]之一来进行：[$off]、[$default] 或 [$audit]。

[:en]
A translation with build level set to [$off] performs no checking for any
contracts.
[:zh_CN]
将构建级别设为 [$off] 的翻译中不为任何契约实施检查。

[:en]
A translation with build level set to [$default] performs checking for
[`default] contracts.
[:zh_CN]
将构建级别设为 [$default] 的翻译中为 [`default] 契约实施检查。

[:en]
A translation with build level set to [$audit] performs checking for [`default]
and [`audit] contracts.
[:zh_CN]
将构建级别设为 [$audit] 的翻译中为 [`default] 和 [`audit] 契约实施检查。

[:en]
If no build level is explicitly selected, the build level is [$default].
[:zh_CN]
如果没有明确选择构建级别，则构建级别为 [$default]。

[:en]
The mechanism for selecting the build level is [%@impldef mechanism for
selecting the build level] implementation-defined.
[:zh_CN]
选择构建级别的机制是[%@impldef 选择构建级别的机制]由实现定义的。

[:en]
The translation of a program consisting of translation units where the build
level is not the same in all translation units is conditionally-supported.
[:zh_CN]
由多个翻译单元组成的程序，构建级别并非在全部翻译单元中都相同的情况，对它的翻译是
有条件支持的。

[:en]
There should be no programmatic way of setting, modifying, or querying
the build level of a translation unit.
[:zh_CN]
不应当为设值、修改或查询翻译单元的构建级别提供可编程的方式。

[para]
[:en]
During constant expression evaluation ([#expr.const]), only predicates of
checked contracts are evaluted.
[:zh_CN]
在常量表达式求值（[#expr.const]）过程中，仅对受检查的契约的谓词进行求值。

[:en]
In other contexts, it is unspecified whether the predicate for a contract that
is not checked under the current build level is evaluated; if the predicate of
such a contract would evaluate to [`false], the behavior is undefined.
[:zh_CN]
在其他语境中，在当前构建级别下并非受检查的契约的谓词是否被求值是未指明的；而如果
这种契约的谓词被求值为 [`false]，则其行为是未定义的。

[para]
[:en]
The [+violation handler] of a program is a function of type ["[`:opt noexcept]
function of (lvalue reference to [`const std::contract_violation]) returning
[`void]], and is specified in an [%@impldef specification of violation handler]
implementation-defined manner.
[:zh_CN]
程序中的[+违例处理器]，是类型为“返回 [`void] 的
（[`const std::contract_violation] 的左值引用）的 [`:opt noexcept] 函数”的函数，
并且是以[%@impldef 对违例处理器的指定]由实现定义的方式所指定的。

[:en]
The violation handler is invoked when the predicate of a checked contract
evaluates to [`false] (called a [+contract violation]).
[:zh_CN]
违例处理器将在某个被检查契约的谓词求值为 [`false]（称为一次[+契约违例]）时调用。

[:en]
There should be no programmatic way of setting or modifying the violation
handler.
[:zh_CN]
不应当为设值或修改违例处理器提供可编程的方式。

[:en]
It is [%@impldef argument for violation handler] implementation-defined how the
violation handler is established for a program and how the
[`std::contract_violation] argument value is set, except as specified below.
[:zh_CN]
除了下文所述外，如何为程序设立违例处理器，以及如何设置其
[`std::contract_violation] 实参，是[%@impldef 违例处理器的实参]由实现定义的。

[:en]
If a precondition is violated, the source location of the violation is
[%@impldef source location of precondition violation] implementation-defined.
[:zh_CN]
当某个前条件被违反时，该违例的源代码位置是[%@impldef 前条件违例的源代码位置]
由实现定义的。

[enter:note]
[:en]
Implementations are encouraged but not required to report the caller site.
[:zh_CN]
鼓励但并不要求各实现报告调用方位置。
[exit:note]

[:en]
If a postcondition is violated, the source location of the violation is
the source location of the function definition.
[:zh_CN]
当某个后条件被违反时，该违例的源代码位置是函数定义式的源代码位置。

[:en]
If an assertion is violated, the source location of the violation is
the source location of the statement to which the assertion is applied.
[:zh_CN]
当某个断言被违反时，该违例的源代码位置是该断言所应用的语句的源代码位置。

[para]
[:en]
If a user-provided violation handler exits by throwing an exception and a
contract is violated on a call to a function with a non-throwing exception
specification, then the behavior is as if the exception escaped the function
body.
[:zh_CN]
如果用户提供的违例处理器以抛出异常而退出，而对某个带有无抛出异常说明的函数的调用
上违反了某个契约，则其行为如同这个异常从其函数体中脱离出来。

[enter:note]
[:en]
The function [`std::terminate()] is invoked ([#except.terminate]).
[:zh_CN]
调用函数 [`std::terminate()]（[#except.terminate]）。
[exit:note]

[enter:example]
[codeblock]
void f(int x) noexcept [[expects: x > 0]];

void g() {
  f(0);                                         // [:en] [`std::terminate()] if violation handler throws
                                                // [|:zh_CN] 当违例处理器抛出异常时调用 [`std::terminate()]
  /* ... */
}
[codeblock:end]
[exit:example]

[para]
[:en]
A translation may be performed with one of the following [+violation
continuation modes[%violation continuation mode]]: [$off] or [$on].
[:zh_CN]
[:zh_CN]
一次翻译可以根据以下[+违例继续模式]之一来进行：[$off] 或 [$on]。

[:en]
A translation with violation continuation mode set to [$off] terminates
execution by invoking [`std::terminate()] ([#except.terminate]) after completing
the execution of the violation handler.
[:zh_CN]
将违例继续模式设为 [$off] 的翻译中，当完成违例处理器的执行之后通过调用
[`std::terminate()]（[#except.terminate]）来终止执行。

[:en]
A translation with a violation continuation mode set to [$on] continues
execution after completing the execution of the violation handler.
将违例继续模式设为 [$on] 的翻译中，当完成违例处理器的执行之后继续其执行。

[:en]
If no continuation mode is explicitly selected, the default continuation mode is
[$off].
[:zh_CN]
如果没有明确选择违例继续模式，则默认的继续模式为 [$off]。

[enter:note]
[:en]
A continuation mode set to [$on] provides the opportunity to install a logging
handler to instrument a pre-existing code base and fix errors before enforcing
checks.
[:zh_CN]
将继续模式设置为 [$on]，提供了安装记录日志的处理器，以便对现存的代码库进行测量并
在强制实施检查之前修正各种错误的机会。
[exit:note]

[enter:example]
[codeblock]
void f(int x) [[expects: x > 0]];

void g() {
  f(0);         // [:en] [`std::terminate()] after handler if continuation mode is off;
                // [|:zh_CN] 当继续模式为 off 时，调用处理器后将调用 [`std::terminate()]；
                // [:en@~] proceeds after handler if continuation mode is on
                // [|:zh_CN@~] 当继续模式为 on 时，调用处理器之后继续执行
  /* ... */
}
[codeblock:end]
[exit:example]

[%:end#attribute.contracts]
