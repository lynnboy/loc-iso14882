[section#associative.reqmts.general
    [:en] General
    [:zh_CN] 概述
]

[para]
[:en] Associative containers provide fast retrieval of data based on keys.
[:zh_CN] 关联容器提供基于键快速检索数据的能力。

[:en] The library provides four basic kinds of associative containers: [`set],
[`multiset], [`map] and [`multimap].
[:zh_CN] 程序库提供了四种基本关联容器：[`set]，[`multiset]，[`map]，和
[`multimap]。

[para]
[:en] Each associative container is parameterized on [`Key] and an ordering
relation [`Compare] that induces a strict weak ordering ([#alg.sorting]) on
elements of [`Key].
[:zh_CN] 每种关联容器均以 [`Key] 和在 [`Key] 的元素上归纳一种严格弱序
（[#alg.sorting]）的排序关系 [`Compare] 所参数化。

[:en] In addition, [`map] and [`multimap] associate an arbitrary
[+:% mapped type] [`T] with the [`Key].
[:zh_CN] 此外，[`map] 和 [`multimap] 还为 [`Key] 关联任意一种[+:% 映射类型] [`T]。

[:en] The object of type [`Compare] is called the [+:% comparison object] of a
container.
[:zh_CN] [`Compare] 类型的对象被称为容器的[+:% 比较对象]。

[para]
[:en] The phrase [=lq]equivalence of keys[=rq] means the equivalence relation
imposed by the comparison object.
[:zh_CN] 术语“键的等价”的含义是比较对象所蕴含的等价关系。

[:en]
That is, two keys [`k1] and [`k2] are considered to be equivalent if for the
comparison object [`comp], [`comp(k1, k2) == false && comp(k2, k1) == false].
[:zh_CN]
就是说，两个键 [`k1] 和 [`k2]，当对于比较对象 [`comp] 有
[`comp(k1, k2) == false && comp(k2, k1) == false] 时认为它们等价。

[begin:note]
[:en] This is not necessarily the same as the result of [`k1 == k2].
[:zh_CN] 这不一定与 [`k1 == k2] 的结果相同。
[end:note]

[:en] For any two keys [`k1] and [`k2] in the same container, calling
[`comp(k1, k2)] shall always return the same value.
[:zh_CN] 对于同一个容器中的任意两个键 [`k1] 和 [`k2]，调用 [`comp(k1, k2)] 应当
总是返回相同的值。

[para]
[:en] An associative container supports [+:% unique keys] if it may contain at
most one element for each key.
[:zh_CN] 如果关联容器为每个键最多可以包含一个元素，则它支持[+:% 唯一键]。

[:en] Otherwise, it supports [+:% equivalent keys].
[:zh_CN] 否则，它支持[+:% 等价键]。

[:en] The [`set] and [`map] classes support unique keys; the [`multiset] and
[`multimap] classes support equivalent keys.
[:zh_CN] [`set] 和 [`map] 类支持唯一键；[`multiset] 和 [`multimap] 类支持等价键。

[:en] For [`multiset] and [`multimap], [`insert], [`emplace], and [`erase]
preserve the relative ordering of equivalent elements.
[:zh_CN] 对于 [`multiset] 和 [`multimap]，其 [`insert]、[`emplace] 和 [`erase]
保持等价元素之间的相对顺序。

[para]
[:en] For [`set] and [`multiset] the value type is the same as the key type.
[:zh_CN] 对于 [`set] 和 [`multiset]，其值类型与键类型相同。

[:en] For [`map] and [`multimap] it is equal to [`pair<const Key, T>].
[:zh_CN] 对于 [`map] 和 [`multimap]，值类型等于 [`pair<const Key, T>]。

[para]
[:en] [`iterator] of an associative container is of the bidirectional iterator
category.
[:zh_CN] 关联容器的 [`iterator] 属于双向迭代器类别。

[:en] For associative containers where the value type is the same as the key
type, both [`iterator] and [`const_iterator] are constant iterators.
[:zh_CN] 对于值类型与键类型相同的关联容器，[`iterator] 和 [`const_iterator] 都是
常量迭代器。

[:en] It is unspecified whether or not [`iterator] and [`const_iterator] are the
same type.
[:zh_CN] [`iterator] 和 [`const_iterator] 是否是相同类型是未指明的。

[begin:note]
[:en] [`iterator] and [`const_iterator] have identical semantics in this case,
and [`iterator] is convertible to [`const_iterator].
[:zh_CN] 这种情况下 [`iterator] 和 [`const_iterator] 具有相同的语义，而且
[`iterator] 可以转换为 [`const_iterator]。

[:en] Users can avoid violating the one definition rule by always using
[`const_iterator] in their function parameter lists.
[:zh_CN] 用户可以通过在其函数形参列表中总是使用 [`const_iterator] 来避免对唯一
定义原则的违反。
[end:note]

[para]
[:en] In this subclause,
[:zh_CN] 本子条款中，
[list]
[item]
[:en] [`X] denotes an associative container class,
[:zh_CN] [`X] 代表一种关联容器类，
[item]
[:en] [`a] denotes a value of type [`X],
[:zh_CN] [`a] 代表 [`X] 类型的值，
[item]
[:en] [`a2] denotes a value of a type with nodes compatible with type [`X]
([#:tab#container.node.compat]),
[:zh_CN] [`a2] 代表与类型 [`X] 具有兼容节点的类型（[#:tab#container.node.compat]）
的值，
[item]
[:en] [`b] denotes a possibly [`:key const] value of type [`X],
[:zh_CN] [`b] 代表 [`X] 类型的可能为 [`:key const] 的值，
[item]
[:en] [`u] denotes the name of a variable being declared,
[:zh_CN] [`u] 代表所声明的变量的名字，
[item]
[:en] [`a_uniq] denotes a value of type [`X] when [`X] supports unique keys,
[:zh_CN] [`a_uniq] 代表当 [`X] 支持唯一键时 [`X] 类型的值，
[item]
[:en] [`a_eq] denotes a value of type [`X] when [`X] supports multiple keys,
[:zh_CN] [`a_eq] 代表当 [`X] 支持等价键时 [`X] 类型的值，
[item]
[:en] [`a_tran] denotes a possibly [`:key const] value of type [`X] when the
[~qualified-id] [`X::key_compare::is_transparent] is valid and denotes a type
([#temp.deduct]),
[:zh_CN] [`a_tran] 代表当[~限定标识] [`X::key_compare::is_transparent] 有效且
代表某个类型（[#temp.deduct]）时 [`X] 类型的可能为 [`:key const] 的值，
[item]
[:en] [`i] and [`j] neet the [^:oc InputIterator] requirements and refer to
elements implicitly convertible to [`value_type],
[:zh_CN] [`i] 和 [`j] 满足 [^:oc InputIterator] 的规定并且指代可以隐式转换为
[`value_type] 的元素，
[item]
[:en] [=range(i,j)] denotes a valid range,
[:zh_CN] [=range(i,j)] 代表有效的范围，
[item]
[:en] [`rg] denotes a value of a type [`R] that models
[`[*:c container-compatible-range]<value_type>],
[:zh_CN] [`rg] 代表构成了 [`[*:c container-compatible-range]<value_type>] 的
类型 [`R]，
[item]
[:en] [`p] denotes a valid constant iterator to [`a],
[:zh_CN] [`p] 代表 [`a] 的有效常量迭代器，
[item]
[:en] [`q] denotes a valid dereferenceable constant iterator to [`a],
[:zh_CN] [`q] 代表 [`a] 的有效可解引用常量迭代器，
[item]
[:en] [`r] denotes a valid dereferenceable iterator to [`a],
[:zh_CN] [`r] 代表 [`a] 的有效可解引用迭代器，
[item]
[:en] [``[q1, q2)] denotes a valid range of constant iterators in [`a],
[:zh_CN] [``[q1, q2)] 代表 [`a] 中常量迭代器的有效范围，
[item]
[:en] [`il] designates an object of type [`initializer_list<value_type>],
[:zh_CN] [`il] 代表 [`initializer_list<value_type>] 类型的对象，
[item]
[:en] [`t] denotes a value of type [`X::value_type],
[:zh_CN] [`t] 代表 [`X::value_type] 类型的对象，
[item]
[:en] [`k] denotes a value of type [`X::key_type], and
[:zh_CN] [`k] 代表 [`X::key_type] 类型的对象，而
[item]
[:en] [`c] denotes a possibly [`:key const] value of type [`X::key_compare];
[:zh_CN] [`c] 代表 [`X::key_compare] 类型的可能为 [`:key const] 的对象；
[item]
[:en] [`kl] is a value such that [`a] is partitioned ([#alg.sorting]) with
respect to [`c(x, kl)], with [`x] the key value of [`e] and [`e] in [`a];
[:zh_CN] [`kl] 是使得 [`a] 根据 [`c(x, kl)] 进行分区（[#alg.sorting]）的值，其中
[`x] 为 [`e] 的键值而 [`e] 处于 [`a] 中；
[item]
[:en] [`ku] is a value such that [`a] is partitioned with respect to [`!c(ku, x)],
with [`x] the key value of [`e] and [`e] in [`a];
[:zh_CN] [`ku] 是使得 [`a] 根据 [`!c(ku, x)] 进行分区的值，其中 [`x] 为 [`e] 的
键值而 [`e] 处于 [`a] 中；
[item]
[:en] [`ke] is a value such that [`a] is partitioned with respect to [`c(x, ke)]
and [`!c(ke, x)], with [`c(x, ke)] implying [`!c(ke, x)] and with [`x] the key
value of [`e] and [`e] in [`a];
[:zh_CN] [`ke] 是使得 [`a] 根据 [`c(x, ke)] 和 [`!c(ke, x)] 进行分区的值，其中
[`c(x, ke)] 蕴含 [`!c(ke, x)]，且 [`x] 为 [`e] 的键值而 [`e] 处于 [`a] 中；
[item]
[:en] [`kx] is a value such that
[:zh_CN] [`kx] 是使以下各项成立的值：
[list]
[item]
[:en] [`a] is partitioned with respect to [`c(x, kx)] and [`!c(kx, x)],
with [`c(x, kx)] implying [`!c(kx, x)] and with [`x] the key value of [`e] and
[`e] in [`a], and
[:zh_CN] [`a] 根据 [`c(r, rx)] 和 [`!c(kx, r)] 进行分区，其中 [`c(r, kx)] 蕴含
[`!c(kx, r)]，且 [`x] 为 [`e] 的键值而 [`e] 处于 [`a] 中，并且
[item]
[:en] [`kx] is not convertible to either [`iterator] or [`const_iterator]; and
[:zh_CN] [`kx] 不能转换为 [`iterator] 或 [`const_iterator]；以及
[list:end]
[item]
[:en] [`A] denotes the storage allocator used by [`X], if any, or
[`allocator<X::value_type>] otherwise,
[:zh_CN] [`A] 代表由 [`X] 所使用的存储分配器（如果有），否则为
[`allocator<X::value_type>]，
[item]
[:en] [`m] denotes an allocator of a type convertible to [`A], and [`nh] denotes
a non-const rvalue of type [`X::node_type].
[:zh_CN] [`m] 代表其类型可以转换为 [`A] 的分配器，而 [`nh] 代表 [`X::node_type]
类型的非 const 右值。
[list:end]

[para]
[:en] A type [`X] meets the [+:adj associative[!container]] requirements if [`X]
meets all the requirements of an allocator-aware container
([#container.requirements.general]) and the following types, statements, and
expressions are well-formed and have the specified semantics, except that for
[`map] and [`multimap], the requirements placed on [`value_type] in
[#container.alloc.reqmts] apply instead to [`key_type] and [`mapped_type].
[:zh_CN] 如果类型 [`X] 满足分配器感知容器的所要规定
（[#container.requirements.general]），并且下列各类型、语句和表达式均良构且具有
规定的语义，则 [`X] 满足[+:adj 关联[!容器]]的规定，但对于 [`map] 和 [`multimap]，
[#container.alloc.reqmts] 中针对 [`value_type] 的规定改为针对 [`key_type] 和
[`mapped_type]。

[begin:note]
[:en] For example, in some cases [`key_type] and [`mapped_type] are required to
be [^:oc CopyAssignable] even though the associated [`value_type],
[`pair<const key_type, mapped_type>], is not [^:oc CopyAssignable].
[:zh_CN] 例如，某些情况下，规定 [`key_type] 和 [`mapped_type] 为
[^:oc CopyAssignable]，但 [`value_type]（即 [`pair<const key_type, mapped_type>]）
则不要求为 [^:oc CopyAssignable]。
[end:note]

[<
@applyTo(['?indexordmem'])
def indexordmem(_1):
    return f'''[%@lib@raw [`{_1}][![:en]ordered associative containers[:zh_CN]有序关联容器]]
    [%@lib@raw [`set][![`{_1}]]]
    [%@lib@raw [`map][![`{_1}]]]
    [%@lib@raw [`multiset][![`{_1}]]]
    [%@lib@raw [`multimap][![`{_1}]]]'''
>]

[?indexordmem key_type]
[codeblock:declaration]
typename X::key_type
[codeblock:end]

[div:description]
[para:result]
[:en] [`Key].
[:zh_CN] [`Key]。
[div:end]

[?indexordmem mapped_type]
[codeblock:declaration]
typename X::mapped_type
[codeblock:end]

[div:description]
[para:result]
[:en] [`T].
[:zh_CN] [`T]。

[para:remarks]
[:en] For [`map] and [`multimap] only.
[:zh_CN] 仅对于 [`map] 和 [`multimap]。
[div:end]

[?indexordmem value_type]
[codeblock:declaration]
typename X::value_type
[codeblock:end]

[div:description]
[para:result]
[:en] [`Key] for [`set] and [`multiset] only; [`pair<const Key, T>] for [`map]
and [`multimap] only.
[:zh_CN] 仅对于 [`set] 和 [`multiset] 为 [`Key]；仅对于 [`map] 和 [`multimap] 为
[`pair<const Key, T>]。

[para:expects]
[:en] [`X::value_type] is [^:oc Erasable] from [`X].
[:zh_CN] [`X::value_type] 为从 [`X] 中 [^:oc Erasable]。
[div:end]

[?indexordmem key_compare]
[codeblock:declaration]
typename X::key_compare
[codeblock:end]

[div:description]
[para:result]
[:en] [`Compare].
[:zh_CN] [`Compare]。

[para:expects]
[:en] [`key_compare] is [^:oc CopyConstructible].
[:zh_CN] [`key_compare] 为 [^:oc CopyConstructible]。
[div:end]

[?indexordmem value_compare]
[codeblock:declaration]
typename X::value_compare
[codeblock:end]

[div:description]
[para:result]
[:en] A binary predicate type.
[:zh_CN] 一种二元谓词类型。

[:en] It is the same as [`key_compare] for [`set] and [`multiset]; is an
ordering relation on pairs induced by the first component (i.e., [`Key]) for
[`map] and [`multimap].
[:zh_CN] 对于 [`set] 和 [`multiset]，其与 [`key_compare] 相同；对于 [`map] 和
[`multimap]，则是以对偶的第一部分（亦即 [`Key]）归纳的一种对偶之间的排序关系。
[div:end]

[?indexordmem node_type]
[codeblock:declaration]
typename X::node_type
[codeblock:end]

[div:description]
[para:result]
[:en] A specialization of a [*node-handle] class template ([#container.node]),
such that the public nested types are the same types as the corresponding types
in [`X].
[:zh_CN] 类模板 [*node-handle] 的特例（[#container.node]），其各个公开嵌套类型与
[`X] 中的对应类型为相同的类型。
[div:end]

[%@lib@ctor set]
[%@lib@ctor map]
[%@lib@ctor multiset]
[%@lib@ctor multimap]
[codeblock:declaration]
X(c)
[codeblock:end]

[div:description]
[para:effects]
[:en] Constructs an empty container.
[:zh_CN] 构造一个空容器。

[:en] Uses a copy of [`c] as a comparison object.
[:zh_CN] 使用 [`c] 的副本作为比较对象。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[%@lib@ctor set]
[%@lib@ctor map]
[%@lib@ctor multiset]
[%@lib@ctor multimap]
[codeblock:declaration]
X u = X();
X u;
[codeblock:end]

[div:description]
[para:expects]
[:en] [`key_compare] meets the [^:oc DefaultConstructible] requirements.
[:zh_CN] [`key_compare] 满足 [^:oc DefaultConstructible] 的规定。

[para:effects]
[:en] Constructs an empty container.
[:zh_CN] 构造一个空容器。

[:en] Uses [`Compare()] as a comparison object.
[:zh_CN] 使用 [`Compare()] 作为比较对象。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[%@lib@ctor set]
[%@lib@ctor map]
[%@lib@ctor multiset]
[%@lib@ctor multimap]
[codeblock:declaration]
X(i, j, c)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`*i].
[:zh_CN] [`value_type] 为以 [`*i] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container and inserts elements from the range
[=range(i,j)] into it; uses [`c] as a comparison object.
[:zh_CN] 构造一个空容器，并将范围 [=range(i,j)] 中的元素插入其中；使用 [`c] 作为
比较对象。

[para:complexity]
[:en] [$N \log N] in general, where [$N] has the value [`distance(i, j)];
linear if [=range(i,j)] is sorted with [`value_comp()].
[:zh_CN] 一般为 [$N \log N]，其中 [$N] 的值为 [`distance(i, j)]；
当 [=range(i,j)] 以 [`value_comp()] 进行了排序时为线性。
[div:end]

[%@lib@ctor set]
[%@lib@ctor map]
[%@lib@ctor multiset]
[%@lib@ctor multimap]
[codeblock:declaration]
X(i, j)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`key_compare] meets the [^:oc DefaultConstructible] requirements.
[:zh_CN] [`key_compare] 满足 [^:oc DefaultConstructible] 的规定。

[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`*i].
[:zh_CN] [`value_type] 为以 [`*i] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container and inserts elements from the range
[=range(i,j)] into it; uses [`Compare()] as a comparison object.
[:zh_CN] 构造一个空容器，并将范围 [=range(i,j)] 中的元素插入其中；使用
[`Compare()] 作为比较对象。

[para:complexity]
[:en] [$N \log N] in general, where [$N] has the value [`distance(i, j)];
linear if [=range(i,j)] is sorted with [`value_comp()].
[:zh_CN] 一般为 [$N \log N]，其中 [$N] 的值为 [`distance(i, j)]；
当 [=range(i,j)] 以 [`value_comp()] 进行了排序时为线性。
[div:end]

[%@lib@ctor set]
[%@lib@ctor map]
[%@lib@ctor multiset]
[%@lib@ctor multimap]
[codeblock:declaration]
X(from_range, rg, c)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from
[`*range::begin(rg)].
[:zh_CN] [`value_type] 为以 [`*range::begin(rg)] 向 [`X] 中
[^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container and inserts each elements [`rg] into it.
[:zh_CN] 构造一个空容器，并将 [`rg] 中的各元素插入其中；

[:en] Uses [`c] as a comparison object.
[:zh_CN] 使用 [`c] 作为比较对象。

[para:complexity]
[:en] [$N \log N] in general, where [$N] has the value [`ranges::distance(rg)];
linear if [`rg] is sorted with [`value_comp()].
[:zh_CN] 一般为 [$N \log N]，其中 [$N] 的值为 [`ranges::distance(rg)]；
当 [`rg] 以 [`value_comp()] 进行了排序时为线性。
[div:end]

[%@lib@ctor set]
[%@lib@ctor map]
[%@lib@ctor multiset]
[%@lib@ctor multimap]
[codeblock:declaration]
X(from_range, rg)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`key_compare] meets the [^:oc DefaultConstructible] requirements.
[:zh_CN] [`key_compare] 满足 [^:oc DefaultConstructible] 的规定。

[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from
[`*range::begin(rg)].
[:zh_CN] [`value_type] 为以 [`*range::begin(rg)] 向 [`X] 中
[^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container and inserts each elements [`rg] into it.
[:zh_CN] 构造一个空容器，并将 [`rg] 中的各元素插入其中；

[:en] Uses [`Compare()] as a comparison object.
[:zh_CN] 使用 [`Compare()] 作为比较对象。

[para:complexity]
[:en] Same as [`X(from_range, rg, c)].
[:zh_CN] 与 [`X(from_range, rg, c)] 相同。
[div:end]

[%@lib@ctor set]
[%@lib@ctor map]
[%@lib@ctor multiset]
[%@lib@ctor multimap]
[codeblock:declaration]
X(il, c)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`X(il.begin(), il.end(), c)].
[:zh_CN] 等价于 [`X(il.begin(), il.end(), c)]；
[div:end]

[%@lib@ctor set]
[%@lib@ctor map]
[%@lib@ctor multiset]
[%@lib@ctor multimap]
[codeblock:declaration]
X(il)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`X(il.begin(), il.end())].
[:zh_CN] 等价于 [`X(il.begin(), il.end())]。
[div:end]

[codeblock:declaration]
a = il
[codeblock:end]

[div:description]
[para:result] [`X&]

[para:expects]
[:en] [`value_type] is [^:oc CopyInsertable] into [`X] and [^:oc CopyAssignable].
[:zh_CN] [`value_type] 为向 [`X] 中 [^:oc CopyInsertable]，并且为
[^:oc CopyAssignable]。

[para:effects]
[:en] Assigns the range [=range(il.begin(),il.end())] into [`a].
[:zh_CN] 将范围 [=range(il.begin(),il.end())] 赋值到[`a] 中。

[:en] All existing elements of [`a] are either assigned to or destroyed.
[:zh_CN] [`a] 的所有现存元素要么被赋值要么被销毁。

[para:complexity]
[:en] [$N \log N] in general, where [$N] has the value [`il.size() + a.size()];
linear if [=range(il.begin(),il.end())] is sorted with [`value_comp()].
[:zh_CN] 一般为 [$N \log N]，其中 [$N] 的值为 [`il.size() + a.size()]；
当 [=range(il.begin(),il.end())] 以 [`value_comp()] 进行了排序时为线性。
[div:end]

[?indexordmem key_comp]
[codeblock:declaration]
b.key_comp()
[codeblock:end]

[div:description]
[para:result]
[`X::key_compare]

[para:returns]
[:en] The comparison object out of which [`b] was constructed.
[:zh_CN] 用于构造 [`b] 的比较对象。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexordmem value_comp]
[codeblock:declaration]
b.value_comp()
[codeblock:end]

[div:description]
[para:result]
[`X::value_compare]

[para:returns]
[:en] An object of [`value_compare] constructed out of the comparison object.
[:zh_CN] 从比较对象构造的 [`value_compare] 对象。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexordmem emplace]
[codeblock:declaration]
a_uniq.emplace(args)
[codeblock:end]

[div:description]
[para:result]
[`pair<iterator, bool>]

[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`args].
[:zh_CN] [`value_type] 为以 [`args] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Inserts a [`value_type] object [`t] constructed with
[`std::forward<Args>(args)...] if and only if there is no element in the
container with key equivalent to the key of [`t].
[:zh_CN] 当且仅当容器中不存在其键等价于 [`t] 的键的元素时，插入以
[`std::forward<Args>(args)...] 构造的 [`value_type] 对象 [`t]。

[para:returns]
[:en] The [`bool] component of the returned pair is [`true] if and only if
the insertion takes place, and the iterator component of the pair points to
the element with key equivalent to the key of [`t].
[:zh_CN] 当且仅当发生了插入时，所返回的对偶的 [`bool] 成分为 [`true]；对偶的
迭代器成分指向其键等价于 [`t] 的键的元素。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem emplace]
[codeblock:declaration]
a_eq.emplace(args)
[codeblock:end]

[div:description]
[para:result]
[`iterator]

[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`args].
[:zh_CN] [`value_type] 为以 [`args] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Inserts a [`value_type] object [`t] constructed with
[`std::forward<Args>(args)...] and returns the iterator pointing to the newly
inserted element.
[:zh_CN] 插入以 [`std::forward<Args>(args)...] 构造的 [`value_type] 对象 [`t]，
并返回指向新插入元素的迭代器。

[:en] If a range containing elements equivalent to [`t] exists in [`a_eq],
[`t] is inserted at the end of that range.
[:zh_CN] 如果 [`a_eq] 中存在包含等价于 [`t] 的元素的范围，则 [`t] 被插入到
该范围的末尾。

[para:returns]
[:en] An iterator pointing to the newly inserted element.
[:zh_CN] 指向新插入元素的迭代器。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem emplace_hint]
[codeblock:declaration]
a.emplace_hint(p, args)
[codeblock:end]

[div:description]
[para:result]
[`iterator]

[para:effects]
[:en] Equivalent to [`a.emplace(std::forward<Args>(args)...)], except that the
element is inserted as close as possible to the position just prior to [`p].
[:zh_CN] 等价于 [`a.emplace(std::forward<Args>(args)...)]，但元素被插入到与紧接
[`p] 之前的位置尽可能靠近之处。

[para:returns]
[:en] An iterator pointing to the element with the key equivalent to the newly
inserted element.
[:zh_CN] 指向其键与新插入元素等价的元素的迭代器。

[para:complexity]
[:en] Logarithmic in general, but amortized constant if the element is inserted
right before [`p].
[:zh_CN] 通常为对数，但当元素被插入到紧接 [`p] 之前时为摊销常量。
[div:end]

[?indexordmem insert]
[codeblock:declaration]
a_uniq.insert(t)
[codeblock:end]

[div:description]
[para:result]
[`pair<iterator, bool>]

[para:expects]
[:en] If [`t] is a non-const rvalue, [`value_type] is [^:oc MoveInsertable]
into [`X]; otherwise, [`value_type] is [^:oc CopyInsertable] into [`X].
[:zh_CN] 如果 [`t] 是非 const 右值，则 [`value_type] 为向 [`X] 中
[^:oc MoveInsertable]；否则 [`value_type] 为向 [`X] 中 [^:oc CopyInsertable]。

[para:effects]
[:en] Inserts [`t] if and only if there is no element in the container with
key equivalent to the key of [`t].
[:zh_CN] 当且仅当容器中不存在其键等价于 [`t] 的键的元素时，插入 [`t]。

[para:returns]
[:en] The [`bool] component of the returned pair is [`true] if and only if
the insertion takes place, and the [`iterator] component of the pair points
to the element with key equivalent to the key of [`t].
[:zh_CN] 当且仅当发生了插入时，所返回的对偶的 [`bool] 成分为 [`true]；对偶的
[`iterator] 成分指向其键与 [`t] 的键等价的元素。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem insert]
[codeblock:declaration]
a_eq.insert(t)
[codeblock:end]

[div:description]
[para:result]
[`iterator]

[para:expects]
[:en] If [`t] is a non-const rvalue, [`value_type] is [^:oc MoveInsertable]
into [`X]; otherwise, [`value_type] is [^:oc CopyInsertable] into [`X].
[:zh_CN] 如果 [`t] 是非 const 右值，则 [`value_type] 为向 [`X] 中
[^:oc MoveInsertable]；否则 [`value_type] 为向 [`X] 中 [^:oc CopyInsertable]。

[para:effects]
[:en] Inserts [`t] and returns the iterator pointing to the newly inserted
element.
[:zh_CN] 插入 [`t]，并返回指向新插入元素的迭代器。

[:en] If a range containing elements equivalent to [`t] exists in [`a_eq],
[`t] is inserted at the end of that range.
[:zh_CN] 如果 [`a_eq] 中存在所包含的元素与 [`t] 等价的范围，则 [`t] 被插入到
该范围的末尾。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem insert]
[codeblock:declaration]
a.insert(p, t)
[codeblock:end]

[div:description]
[para:result]
[`iterator]

[para:expects]
[:en] If [`t] is a non-const rvalue, [`value_type] is [^:oc MoveInsertable]
into [`X]; otherwise, [`value_type] is [^:oc CopyInsertable] into [`X].
[:zh_CN] 如果 [`t] 是非 const 右值，则 [`value_type] 为向 [`X] 中
[^:oc MoveInsertable]；否则 [`value_type] 为向 [`X] 中 [^:oc CopyInsertable]。

[para:effects]
[:en] Inserts [`t] if and only if there is no element with key equivalent to
the key of [`t] in containers with unique keys; always inserts [`t] in
containers with equivalent keys.
[:zh_CN] 当且仅当具有唯一键的容器中不存在其键与 [`t] 的键等价的元素时，插入 [`t]；
总是向具有等价键的容器中插入 [`t]。

[:en] [`t] is inserted as close as possible to the position just prior to [`p].
[:zh_CN] [`t] 被插入到与紧接 [`p] 之前的位置尽可能靠近。

[para:returns]
[:en] An iterator pointing to the element with key equivalent to the key of [`t].
[:zh_CN] 指向其键与 [`t] 的键等价的元素的迭代器。

[para:complexity]
[:en] Logarithmic in general, but amortized constant if [`t] is inserted
right before [`p].
[:zh_CN] 通常为对数，但当 [`t] 被插入到紧接 [`p] 之前时为摊销常量。
[div:end]

[?indexordmem insert]
[codeblock:declaration]
a.insert(i, j)
[codeblock:end]

[div:description]
[para:result]
[`:key void]

[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`*i].
[:zh_CN] [`value_type] 为以 [`*i] 向 [`X] 中 [^:oc EmplaceConstructible]。

[:en] Neither [`i] nor [`j] are iterators into [`a].
[:zh_CN] [`i] 和 [`j] 都不是 [`a] 中的迭代器。

[para:effects]
[:en] Inserts each element from the range [=range(i,j)] if and only if there is
no element with key equivalent to the key of that element in containers with
unique keys; always inserts that element in containers with equivalent keys.
[:zh_CN] 对于范围 [=range(i,j)] 中的每个元素，当且仅当具有唯一键的容器中不存在
其键与该元素的键等价的元素时，插入该元素；总是向具有等价键的容器中插入该元素。

[para:complexity]
[:en] [$N \log ([`a.size()] + N)], where [$N] has the value [`distance(i, j)].
[:zh_CN] [$N \log ([`a.size()] + N)]，其中 [$N] 的值为 [`distance(i, j)]。
[div:end]

[?indexordmem insert]
[codeblock:declaration]
a.insert_range(rg)
[codeblock:end]

[div:description]
[para:result]
[`:key void]

[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from
[`*ranges::begin(rg)].
[:zh_CN] [`value_type] 为以 [`*ranges::begin(rg)] 向 [`X] 中
[^:oc EmplaceConstructible]。

[:en] [`rg] and [`a] do not overlap.
[:zh_CN] [`rg] 和 [`a] 没有重叠。

[para:effects]
[:en] Inserts each element from [`rg] if and only if there is no element with
key equivalent to the key of that element in containers with unique keys; always
inserts that element in containers with equivalent keys.
[:zh_CN] 对于 [`rg] 中的每个元素，当且仅当具有唯一键的容器中不存在其键与该元素的
键等价的元素时，插入该元素；总是向具有等价键的容器中插入该元素。

[para:complexity]
[:en] [$N \log ([`a.size()] + N)], where [$N] has the value [`ranges::distance(rg)].
[:zh_CN] [$N \log ([`a.size()] + N)]，其中 [$N] 的值为 [`ranges::distance(rg)]。
[div:end]

[?indexordmem insert]
[codeblock:declaration]
a.insert(il)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`a.insert(il.begin(), il.end())].
[:zh_CN] 等价于 [`a.insert(il.begin(), il.end())]。
[div:end]

[?indexordmem insert]
[codeblock:declaration]
a_uniq.insert(nh)
[codeblock:end]

[div:description]
[para:result]
[`insert_return_type]

[para:expects]
[:en] [`nh] is empty or [`a_uniq.get_allocator() == nh.get_allocator()] is [`true].
[:zh_CN] [`nh] 为空，或者 [`a_uniq.get_allocator() == nh.get_allocator()] 为 [`true]。

[para:effects]
[:en] If [`nh] is empty, has no effect.
[:zh_CN] 若 [`nh] 为空则没有效果。

[:en] Otherwise, inserts the element owned by [`nh] if and only if there is
no element in the container with a key equivalent to [`nh.key()].
[:zh_CN] 否则，当且仅当该容器中不存在带有与 [`nh.key()] 等价的键的元素时，
插入由 [`nh] 所拥有的元素。

[para:returns]
[:en] If [`nh] is empty, [`inserted] is [`false], [`position] is [`end()],
and [`node] is empty.
[:zh_CN] 若 [`nh] 为空，则 [`inserted] 为 [`false]，[`position] 为 [`end()]，
且 [`node] 为空。

[:en] Otherwise if the insertion took place, [`inserted] is [`true],
[`position] points to the inserted element, and [`node] is empty; if the
insertion failed, [`inserted] is [`false], [`node] has the previous value of
[`nh], and [`position] points to an element with a key equivalent to [`nh.key()].
[:zh_CN] 否则如果发生了插入，则 [`inserted] 为 [`true]，[`position] 指向所插入
的元素，而 [`node] 为空；如果插入失败，则 [`inserted] 为 [`false]，[`node] 具有
[`nh] 之前的值，而 [`position] 指向带有等价于 [`nh.key()] 的键的元素。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem insert]
[codeblock:declaration]
a_eq.insert(nh)
[codeblock:end]

[div:description]
[para:result]
[`iterator]

[para:expects]
[:en] [`nh] is empty or [`a_eq.get_allocator() == nh.get_allocator()] is [`true].
[:zh_CN] [`nh] 为空，或者 [`a_eq.get_allocator() == nh.get_allocator()] 为 [`true]。

[para:effects]
[:en] If [`nh] is empty, has no effect and returns [`a_eq.end()].
[:zh_CN] 若 [`nh] 为空，则没有效果并返回 [`a_eq.end()]。

[:en] Otherwise, inserts the element owned by [`nh] and returns an iterator
pointing to the newly inserted element.
[:zh_CN] 否则，插入由 [`nh] 所拥有的元素，并返回指向新插入的元素的迭代器。

[:en] If a range containing elements with keys equivalent to [`nh.key()]
exists in [`a_eq], the element is inserted at the end of that range.
[:zh_CN] 如果 [`a_eq] 中存在包含带有与 [`nh.key()] 等价的键的元素的一个范围，
则元素被插入到这个范围的末尾。

[para:ensures]
[:en] [`nh] is empty.
[:zh_CN] [`nh] 为空。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem insert]
[codeblock:declaration]
a.insert(p, nh)
[codeblock:end]

[div:description]
[para:result]
[`iterator]

[para:expects]
[:en] [`nh] is empty or [`a.get_allocator() == nh.get_allocator()] is [`true].
[:zh_CN] [`nh] 为空，或者 [`a.get_allocator() == nh.get_allocator()] 为 [`true]。

[para:effects]
[:en] If [`nh] is empty, has no effect and returns [`a_eq.end()].
[:zh_CN] 若 [`nh] 为空，则没有效果并返回 [`a_eq.end()]。

[:en] Otherwise, inserts the element owned by [`nh] if and only if there is no
element with key equivalent to [`nh.key()] in containers with unique keys;
always inserts the element owned by [`nh] in containers with equivalent keys.
[:zh_CN] 否则，在带有唯一键的容器中当且仅当不存在带有与 [`nh.key()] 等价的键的
元素时，插入由 [`nh] 所拥有的元素；在带有等价键的容器中总是插入由 [`nh] 所拥有的
元素。

[:en] The element is inserted as close as possible to the position just prior to
[`p].
[:zh_CN] 元素被插入到与紧接 [`p] 之前的位置尽可能靠近。

[para:ensures]
[:en] [`nh] is empty if insertion succeeds, unchanged if insertion fails.
[:zh_CN] 若插入成功则 [`nh] 为空，若插入失败则其无变化。

[para:returns]
[:en] An iterator pointing to the element with key equivalent to [`nh.key()].
[:zh_CN] 指向其键与 [`nh.key()] 等价的元素的迭代器。

[para:complexity]
[:en] Logarithmic in general, but amortized constant if the element is inserted
right before [`p].
[:zh_CN] 通常为对数，但当元素被插入到紧接 [`p] 之前时为摊销常量。
[div:end]

[?indexordmem extract]
[codeblock:declaration]
a.extract(k)
[codeblock:end]

[div:description]
[para:result]
[`node_type]

[para:effects]
[:en] Removes the first element in the container with key equivalent to [`k].
[:zh_CN] 移除容器中第一个其键等价于 [`k] 的元素。

[para:returns]
[:en] A [`node_type] owning the element if found, otherwise an empty [`node_type].
[:zh_CN] 如果找到则为一个拥有该元素的 [`node_type]，否则为空 [`node_type]。

[para:complexity]
[$\log ([`a.size()])]
[div:end]

[?indexordmem extract]
[codeblock:declaration]
a_tran.extract(kx)
[codeblock:end]

[div:description]
[para:result]
[`node_type]

[para:effects]
[:en] Removes the first element in the container with key [`r] such that
[`!c(r, kx) && !c(kx, r)] is [`true].
[:zh_CN] 移除容器中第一个键其键 [`r] 使得 [`!c(r, kx) && !c(kx, r)] 为 [`true]
的元素。

[para:returns]
[:en] A [`node_type] owning the element if found, otherwise an empty [`node_type].
[:zh_CN] 如果找到则为一个拥有该元素的 [`node_type]，否则为空 [`node_type]。

[para:complexity]
[$\log([`a_tran.size()])]
[div:end]

[?indexordmem extract]
[codeblock:declaration]
a.extract(q)
[codeblock:end]

[div:description]
[para:result]
[`node_type]

[para:effects]
[:en] Removes the element pointed to by [`q].
[:zh_CN] 移除 [`q] 所指向的元素。

[para:returns]
[:en] A [`node_type] owning that element.
[:zh_CN] 一个拥有该元素的 [`node_type]。

[para:complexity]
[:en] Amortized constant.
[:zh_CN] 摊销常量。
[div:end]

[?indexordmem merge]
[codeblock:declaration]
a.merge(a2)
[codeblock:end]

[div:description]
[para:result]
[`:key void]

[para:expects]
[:en] [`a.get_allocator() == a2.get_allocator()].
[:zh_CN] [`a.get_allocator() == a2.get_allocator()]。

[para:effects]
[:en] Attempts to extract each element in [`a2] and insert it into [`a]
using the comparison object of [`a].
[:zh_CN] 尝试提取 [`a2] 中的每个元素，并使用 [`a] 的比较对象来将之插入到
[`a] 之中。

[:en] In containers with unique keys, if there is an element in [`a] with
key equivalent to the key of an element from [`a2], then that element is not
extracted from [`a2].
[:zh_CN] 在带有唯一键的容器中，如果 [`a] 之中存在某个元素的键与 [`a2] 中的
元素的键等价，则该元素不会从 [`a2] 中提取出来。

[para:ensures]
[:en] Pointers and references to the transferred elements of [`a2] refer to
those same elements but as members of [`a].
[:zh_CN] 曾指代被迁移的 [`a2] 的元素的指针和引用，仍指代相同的元素，但它们
已经是 [`a] 的成员。

[:en] Iterators referring to the transferred elements will continue to refer
to their elements, but they now behave as iterators into [`a], not into [`a2].
[:zh_CN] 曾指代被迁移的元素的迭代器将会继续指代它们的元素，但它们变为 [`a]
的迭代器而不是 [`a2] 的迭代器。

[para:throws]
[:en] Nothing unless the comparison object throws.
[:zh_CN] 无，除非比较对象抛出异常。

[para:complexity]
[:en] [$N \log([`a.size()] + N)] where [$N] has the value [`a2.size()].
[:zh_CN] [$N \log([`a.size()] + N)]，其中 [$N] 的值为 [`a2.size()]。
[div:end]

[?indexordmem erase]
[codeblock:declaration]
a.erase(k)
[codeblock:end]

[div:description]
[para:result]
[`size_type]

[para:effects]
[:en] Erases all elements in the container with key equivalent to [`k].
[:zh_CN] 清除容器中所有具有与 [`k] 等价的键的元素。

[para:returns]
[:en] The number of erased elements.
[:zh_CN] 所清除的元素数量。

[para:complexity]
[$\log ([`a.size()]) + [`a.count(k)]]
[div:end]

[?indexordmem erase]
[codeblock:declaration]
a_tran.erase(kx)
[codeblock:end]

[div:description]
[para:result]
[`size_type]

[para:effects]
[:en] Erases all elements in the container with key [`r] such that
[`!c(r, kx) && !c(kx, r)] is [`true].
[:zh_CN] 清除容器中所有其键 [`r] 使得 [`!c(r, kx) && !c(kx, r)] 为 [`true]
的元素。

[para:returns]
[:en] The number of erased elements.
[:zh_CN] 所清除的元素数量。

[para:complexity]
[$\log ([`a_tran.size()]) + [`a_tran.count(kx)]]
[div:end]

[?indexordmem erase]
[codeblock:declaration]
a.erase(q)
[codeblock:end]

[div:description]
[para:result]
[`iterator]

[para:effects]
[:en] Erases the element pointed to by [`q].
[:zh_CN] 清除由 [`q] 所指向的元素。

[para:returns]
[:en] An iterator pointing to the element immediately following [`q] prior
to the element being erased.
[:zh_CN] 指向元素被清除前紧跟 [`q] 之后的元素的迭代器。

[:en] If no such element exists, returns [`a.end()].
[:zh_CN] 如果不存在这种元素，则返回 [`a.end()]。

[para:complexity]
[:en] Amortized constant.
[:zh_CN] 摊销常量。
[div:end]

[?indexordmem erase]
[codeblock:declaration]
a.erase(r)
[codeblock:end]

[div:description]
[para:result]
[`iterator]

[para:effects]
[:en] Erases the element pointed to by [`r].
[:zh_CN] 清除由 [`r] 所指向的元素。

[para:returns]
[:en] An iterator pointing to the element immediately following [`r] prior
to the element being erased.
[:zh_CN] 指向元素被清除前紧跟 [`r] 之后的元素的迭代器。

[:en] If no such element exists, returns [`a.end()].
[:zh_CN] 如果不存在这种元素，则返回 [`a.end()]。

[para:complexity]
[:en] Amortized constant.
[:zh_CN] 摊销常量。
[div:end]

[?indexordmem erase]
[codeblock:declaration]
a.erase(q1, q2)
[codeblock:end]

[div:description]
[para:result]
[`iterator]

[para:effects]
[:en] Erases all the elements in the range [=range(q1,q2)].
[:zh_CN] 清除范围 [=range(q1,q2)] 中的所有元素。

[para:returns]
[:en] An iterator pointing to the element pointed to by [`q2] prior to any
elements being erased.
[:zh_CN] 指向任何元素被清除前紧跟 [`q2] 之后的元素的迭代器。

[:en] If no such element exists, [`a.end()] is returned.
[:zh_CN] 如果不存在这种元素，则返回 [`a.end()]。

[para:complexity]
[:en] [$\log([`a.size()]) + N] where [$N] has the value [`distance(q1, q2)].
[:zh_CN] [$\log([`a.size()]) + N]，其中 [$N] 的值为 [`distance(q1, q2)]。
[div:end]

[?indexordmem clear]
[codeblock:declaration]
a.clear()
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`a.erase(a.begin(), a.end())].
[:zh_CN] 等价于 [`a.erase(a.begin(), a.end())]。

[para:ensures]
[:en] [`a.empty()] is [`true].
[:zh_CN] [`a.empty()] 为 [`true]。

[para:complexity]
[:en] Linear in [`a.size()].
[:zh_CN] 对于 [`a.size()] 为线性。
[div:end]

[?indexordmem find]
[codeblock:declaration]
b.find(k)
[codeblock:end]

[div:description]
[para:result]
[:en] [`iterator]; [`const_iterator] for constant [`b].
[:zh_CN] [`iterator]；对于常量 [`b] 为 [`const_iterator]。

[para:returns]
[:en] An iterator pointing to an element with the key equivalent to [`k], or
[`b.end()] if such an element is not found.
[:zh_CN] 指向其键与 [`k] 等价的元素的迭代器，如果无法找到这种元素则返回 [`b.end()]。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem find]
[codeblock:declaration]
a_tran.find(ke)
[codeblock:end]

[div:description]
[para:result]
[:en] [`iterator]; [`const_iterator] for constant [`a_tran].
[:zh_CN] [`iterator]；对于常量 [`a_tran] 为 [`const_iterator]。

[para:returns]
[:en] An iterator pointing to an element with key [`r] such that
[`!c(r, ke) && !c(ke, r)] is [`true], or [`a_tran.end()] if such an element is
not found.
[:zh_CN] 指向具有键 [`r] 并使得 [`!c(r, ke) && !c(ke, r)] 为 [`true] 的元素的
迭代器，如果无法找到这种元素则返回 [`a.end()]。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem count]
[codeblock:declaration]
b.count(k)
[codeblock:end]

[div:description]
[para:result]
[`size_type]

[para:returns]
[:en] The number of elements with key equivalent to [`k].
[:zh_CN] 具有与 [`k] 等价的键的元素数量。

[para:complexity]
[$\log ([`b.size()]) + [`b.count(k)]]
[div:end]

[?indexordmem count]
[codeblock:declaration]
a_tran.count(ke)
[codeblock:end]

[div:description]
[para:result]
[`size_type]

[para:returns]
[:en] The number of elements with key [`r] such that [`!c(r, ke) && !c(ke, r)].
[:zh_CN] 具有键 [`r] 并使得 [`!c(r, ke) && !c(ke, r)] 的元素数量。

[para:complexity]
[$\log ([`a_tran.size()]) + [`a_tran.count(ke)]]
[div:end]

[?indexordmem contains]
[codeblock:declaration]
b.contains(k)
[codeblock:end]

[div:description]
[para:result]
[`bool]

[para:effects]
[:en] Equivalent to: [`return b.find(k) != b.end();]
[:zh_CN] 等价于：[`return b.find(k) != b.end();]
[div:end]

[?indexordmem contains]
[codeblock:declaration]
a_tran.contains(ke)
[codeblock:end]

[div:description]
[para:result]
[`bool]

[para:effects]
[:en] Equivalent to: [`return a_tran.find(ke) != a_tran.end();]
[:zh_CN] 等价于：[`return a_tran.find(ke) != a_tran.end();]
[div:end]

[?indexordmem lower_bound]
[codeblock:declaration]
b.lower_bound(k)
[codeblock:end]

[div:description]
[para:result]
[:en] [`iterator]; [`const_iterator] for constant [`b].
[:zh_CN] [`iterator]；对于常量 [`b] 为 [`const_iterator]。

[para:returns]
[:en] An iterator pointing to the first element with key not less than [`k],
or [`b.end()] if such an element is not found.
[:zh_CN] 指向其键不小于 [`k] 的第一个元素的迭代器，如果无法找到这种元素则返回
[`b.end()]。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem lower_bound]
[codeblock:declaration]
a_tran.lower_bound(kl)
[codeblock:end]

[div:description]
[para:result]
[:en] [`iterator]; [`const_iterator] for constant [`a_tran].
[:zh_CN] [`iterator]；对于常量 [`a_tran] 为 [`const_iterator]。

[para:returns]
[:en] An iterator pointing to the first element with key [`r] such that
[`!c(r, kl)], or [`a_tran.end()] if such an element is not found.
[:zh_CN] 指向具有键 [`r] 并使得 [`!c(r, kl)] 的第一个元素的迭代器，如果无法
找到这种元素则返回 [`a_tran.end()]。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem upper_bound]
[codeblock:declaration]
b.upper_bound(k)
[codeblock:end]

[div:description]
[para:result]
[:en] [`iterator]; [`const_iterator] for constant [`b].
[:zh_CN] [`iterator]；对于常量 [`b] 为 [`const_iterator]。

[para:returns]
[:en] An iterator pointing to the first element with key greater than [`k],
or [`b.end()] if such an element is not found.
[:zh_CN] 指向其键大于 [`k] 的第一个元素的迭代器，如果无法找到这种元素则返回
[`b.end()]。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem upper_bound]
[codeblock:declaration]
a_tran.upper_bound(ku)
[codeblock:end]

[div:description]
[para:result]
[:en] [`iterator]; [`const_iterator] for constant [`a_tran].
[:zh_CN] [`iterator]；对于常量 [`a_tran] 为 [`const_iterator]。

[para:returns]
[:en] An iterator pointing to the first element with key [`r] such that
[`c(ku, r)], or [`a_tran.end()] if such an element is not found.
[:zh_CN] 指向具有键 [`r] 并使得 [`c(ku, r)] 的第一个元素的迭代器，如果无法
找到这种元素则返回 [`a_tran.end()]。

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem equal_range]
[codeblock:declaration]
b.equal_range(k)
[codeblock:end]

[div:description]
[para:result]
[:en] [`pair<iterator, iterator>]; [`pair<const_iterator, const_iterator>]
for constant [`b].
[:zh_CN] [`pair<iterator, iterator>]；对于常量 [`b] 为
[`pair<const_iterator, const_iterator>]。

[para:effects]
[:en] Equivalent to: [`return make_pair(b.lower_bound(k), b.upper_bound(k));]
[:zh_CN] 等价于：[`return make_pair(b.lower_bound(k), b.upper_bound(k));]

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[?indexordmem equal_range]
[codeblock:declaration]
a_tran.equal_range(ke)
[codeblock:end]

[div:description]
[para:result]
[:en] [`pair<iterator, iterator>]; [`pair<const_iterator, const_iterator>]
for constant [`a_tran].
[:zh_CN] [`pair<iterator, iterator>]；对于常量 [`a_tran] 为
[`pair<const_iterator, const_iterator>]。

[para:effects]
[:en] Equivalent to:
[`return make_pair(a_tran.lower_bound(ke), a_tran.upper_bound(ke));]
[:zh_CN] 等价于：
[`return make_pair(a_tran.lower_bound(ke), a_tran.upper_bound(ke));]

[para:complexity]
[:en] Logarithmic.
[:zh_CN] 对数。
[div:end]

[para]
[:en] The [`insert], [`insert_range], and [`emplace] members shall not affect
the validity of iterators and references to the container, and the [`erase]
members shall invalidate only iterators and references to the erased elements.
[:zh_CN] [`insert]，[`insert_range]，和 [`emplace] 成员不能影响容器的迭代器和
引用的有效性，而 [`erase] 成员只能使指代被清除的元素的迭代器和引用失效。

[para]
[:en] The [`extract] members invalidate only iterators to the removed element;
pointers and references to the removed element remain valid.
[:zh_CN] 各 [`extract] 成员仅会使被移除的元素的迭代器失效；而指代被移除的元素的
指针和引用则保持有效。

[:en] However, accessing the element through such pointers and references while
the element is owned by a [`node_type] is undefined behavior.
[:zh_CN] 不过，当元素由 [`node_type] 拥有时，通过这样的指针和引用来访问元素是
未定义的行为。

[:en] References and pointers to an element obtained while it is owned by a
[`node_type] are invalidated if the element is successfully inserted.
[:zh_CN] 当元素被 [`node_type] 所拥有时所获得的引用和指针，在元素被成功插入之后
就失效。

[para]
[:en] The fundamental property of iterators of associative containers is that
they iterate through the containers in the non-descending order of keys where
non-descending is defined by the comparison that was used to construct them.
[:zh_CN] 关联容器的迭代器的基本性质是，它们以键的非降序方式对容器进行迭代，其中
的非降序是以用于构造它们的比较对象所定义的。

[:en] For any two dereferenceable iterators [`i] and [`j] such that distance
from [`i] to [`j] is positive, the following condition holds:
[:zh_CN] 对于任意两个可解引用的迭代器 [`i] 和 [`j]，且有从 [`i] 到 [`j] 的距离
为正，则以下条件能够满足：

[codeblock]
value_comp(*j, *i) == false
[codeblock:end]

[para]
[:en] For associative containers with unique keys the stronger condition holds:
[:zh_CN] 对于具有唯一键的关联容器，能够满足更强的条件：

[codeblock]
value_comp(*i, *j) != false.
[codeblock:end]

[para]
[:en] When an associative container is constructed by passing a comparison
object the container shall not store a pointer or reference to the passed object,
even if that object is passed by reference.
[:zh_CN] 当传递一个比较对象来构造关联容器时，容器不能存储所传递的对象的指针或
引用，即使这个对象是以引用方式传递也是如此。

[:en] When an associative container is copied, through either a copy constructor
or an assignment operator, the target container shall then use the comparison
object from the container being copied, as if that comparison object had been
passed to the target container in its constructor.
[:zh_CN] 当无论是通过复制构造函数还是赋值运算符复制了关联容器后，目标容器应当
随即使用被复制容器的比较对象，如同这个比较对象是传递给了目标容器的构造函数一样。

[para]
[:en] The member function templates [`find], [`count], [`contains],
[`lower_bound], [`upper_bound], [`equal_range], [`erase], and [`extract] shall
not participate in overload resolution unless the [~qualified-id]
[`Compare::is_transparent] is valid and denotes a type ([#temp.deduct]).
[:zh_CN] 成员函数模板 [`find]，[`count]，[`contains]，[`lower_bound]，
[`upper_bound]，[`equal_range]，[`erase]，和 [`extract]，除非[~限定标识]
[`Compare::is_transparent] 有效且代表某个类型（[#temp.deduct]），否则它们不能
参与重载决议。

[:en] Additionally, the member function templates [`extract] and [`erase]
shall not participate in overload resolution if
[`is_convertible_v<K&&, iterator> || is_convertible_v<K&&, const_iterator>]
is [`true], where [`K] is the type substituted as the first template argument.
[:zh_CN] 此外，成员函数模板 [`extract] 和 [`erase]，当
[`is_convertible_v<K&&, iterator> || is_convertible_v<K&&, const_iterator>] 为
[`true] 时不能参与重载决议，其中 [`K] 是作为第一个模板实参进行代换的类型。

[para]
[:en] A deduction guide for an associative container shall not participate in
overload resolution if any of the following are true:
[:zh_CN] 关联容器的推断导引，当以下有任意一项为真时不能参与重载决议：

[list]
[item]
[:en] It has an [`InputIterator] template parameter and a type that does not
qualify as an input iterator is deduced for that parameter.
[:zh_CN] 它具有一个 [`InputIterator] 模板形参，而为该形参所推断的类型无法作为
输入迭代器。

[item]
[:en] It has an [`Allocator] template parameter and a type that does not qualify
as an allocator is deduced for that parameter.
[:zh_CN] 它具有一个 [`Allocator] 模板形参，而为该形参所推断的类型无法作为分配器。

[item]
[:en] It has a [`Compare] template parameter and a type that qualifies as an
allocator is deduced for that parameter.
[:zh_CN] 它具有一个 [`Compare] 模板形参，而为该形参所推断的类型可以作为分配器。
[list:end]
