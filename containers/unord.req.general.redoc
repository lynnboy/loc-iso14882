[section#unord.req.general
    [:en] General
    [:zh_CN] 概述
]

[para]
[:en] Unordered associative containers provide an ability for fast retrieval of
data based on keys.
[:zh_CN] 无序关联容器提供基于键来快速检索数据的能力。

[:en]
[%unordered associative containers[!complexity]]
The worst-case complexity for most operations is linear, but the average
case is much faster.
[:zh_CN]
[%无序关联容器[!复杂度]]
大多数操作的最差复杂度是线性的，但其平均情况下要快得多。

[:en] The library provides four unordered associative containers:
[`unordered_set], [`unordered_map], [`unordered_multiset], and
[`unordered_multimap].
[:zh_CN] 程序库中提供了四种无序关联容器：[`unordered_set]，[`unordered_map]，
[`unordered_multiset]，以及 [`unordered_multimap]。

[para]
[:en]
[%unordered associative containers[!lack of comparison functions]]
[%unordered associative containers[!requirements]]
[%requirements[!container[!not required for unordered associated containers]]]
Unordered associative containers conform to the requirements for Containers
([#container.requirements]), except that the expressions [`a == b] and [`a != b]
have different semantics than for the other container types.
[:zh_CN]
[%无序关联容器[!缺少比较函数]]
[%无序关联容器[!规定]]
[%规定[!容器[!无序关联容器所不需要的～]]]
无序关联容器符合对于容器的规定（[#container.requirements]），但表达式 [`a == b]
和 [`a != b] 具有不同于其它容器类型的语义。

[para]
[:en] Each unordered associative container is parameterized by [`Key], by a
function object type [`Hash] that meets the [^:oc Hash] requirements
([#hash.requirements]) and acts as a hash function for argument values of type
[`Key], and by a binary predicate [`Pred] that induces an equivalence relation
on values of type [`Key].
[:zh_CN] 每种无序关联容器均以 [`Key]，一种满足 [^:oc Hash] 的规定
（[#hash.requirements]）的函数对象类型 [`Hash]（表现为 [`Key] 类型的实参值上的
散列函数），以及一种二元谓词 [`Pred]（归纳 [`Key] 类型的值之间的一种等价关系）
所参数化。

[:en] Additionally, [`unordered_map] and [`unordered_multimap] associate an
arbitrary [+:% mapped type] [`T] with the [`Key].
[:zh_CN] 此外，[`unordered_map] 和 [`unordered_multimap] 还为 [`Key] 关联任意
一种[+:% 映射类型] [`T]。

[para]
[:en]
[%unordered associative containers[!hash function]]
[%hash function]
The container[=']s object of type [`Hash] [=--] denoted by [`hash] [=--] is
called the [+:% hash function] of the container.
[:zh_CN]
[%无序关联容器[!散列函数]]
[%散列函数]
容器中 [`Hash] 类型的对象（由 [`hash] 代表），被称为该容器的[+:% 散列函数]。

[:en] The container[=']s object of type [`Pred] [=--] denoted by [`pred] [=--]
is called the [+:% key equality predicate] of the container.
[:zh_CN]
容器中 [`Pred] 类型的对象（由 [`pred] 代表），被称为该容器的[+:% 键相等性谓词]。

[para]
[:en]
[%unordered associative containers[!equality function]]
Two values [`k1] and [`k2] are considered equivalent if the container[=']s key
equality predicate [`pred(k1, k2)] is valid and returns [`true] when passed
those values.
[:zh_CN]
[%无序关联容器[!相等函数]]
两个键 [`k1] 和 [`k2]，如果容器的键相等性谓词 [`pred(k1, k2)] 有效，且将这两个值
传递给它时返回 [`true]，则认为它们等价。

[:en] If [`k1] and [`k2] are equivalent, the container[=']s hash function shall
return the same value for both.
[:zh_CN] 如果 [`k1] 和 [`k2] 等价，则该容器的散列函数应当为二者返回相同的值。

[begin:note]
[:en] Thus, when an unordered associative container is instantiated with
a non-default [`Pred] parameter it usually needs a non-default [`Hash] parameter
as well.
[:zh_CN] 因此，当以非默认的 [`Pred] 形参来实例化无序关联容器时，通常也需要非默认
的 [`Hash] 形参。
[end:note]

[:en] For any two keys [`k1] and [`k2] in the same container, calling
[`pred(k1, k2)] shall always return the same value.
[:zh_CN] 对于同一个容器中的任意两个键 [`k1] 和 [`k2]，调用 [`pred(k1, k2)] 应当
总是返回相同的值。

[:en] For any key [`k] in a container, calling [`hash(k)] shall always return
the same value.
[:zh_CN] 对于容器中的任意键 [`k]，调用 [`hash(k)] 应当总是返回相同的值。

[para]
[:en]
[%unordered associative containers[!unique keys]]
[%unordered associative containers[!equivalent keys]]
An unordered associative container supports [+:% unique keys] if it may contain
at most one element for each key.
[:zh_CN]
[%无序关联容器[!唯一键]]
[%无序关联容器[!等价键]]
如果关联容器为每个键最多可以包含一个元素，则它支持[+:% 唯一键]。

[:en] Otherwise, it supports [+:% equivalent keys].
[:zh_CN] 否则，它支持[+:% 等价键]。

[:en] [`unordered_set] and [`unordered_map] support unique keys.
[:zh_CN] [`unordered_set] 和 [`unordered_map] 支持唯一键。

[:en] [`unordered_multiset] and [`unordered_multimap] support equivalent keys.
[:zh_CN] [`unordered_multiset] 和 [`unordered_multimap] 支持等价键。

[:en] In containers that support equivalent keys, elements with equivalent keys
are adjacent to each other in the iteration order of the container.
[:zh_CN] 在支持等价键的容器中，具有等价的键的元素在该容器的迭代顺序中相邻。

[:en] Thus, although the absolute order of elements in an unordered container is
not specified, its elements are grouped into [+equivalent-key groups
[%equivalent-key group]] such that all elements of each group have equivalent
keys.
[:zh_CN] 因此，虽然无序容器中的元素的绝对顺序是未指明的，但元素被分组到
[+等价键组]中，使得每个组中的元素均具有等价的键。

[:en] Mutating operations on unordered containers shall preserve the relative
order of elements within each equivalent-key group unless otherwise specified.
[:zh_CN] 除非另有规定，无序容器上的改动操作应当保持元素在各自的等价键组之内的
相对顺序。

[para]
[:en] For [`unordered_set] and [`unordered_multiset] the value type is the same
as the key type.
[:zh_CN] 对于 [`unordered_set] 和 [`unordered_multiset]，其值类型与键类型相同。

[:en] For [`unordered_map] and [`unordered_multimap] it is [`pair<const Key, T>].
[:zh_CN] 对于 [`unordered_map] 和 [`unordered_multimap]，值类型为
[`pair<const Key, T>]。

[para]
[:en] For unordered containers where the value type is the same as the key type,
both [`iterator] and [`const_iterator] are constant iterators.
[:zh_CN] 对于值类型与键类型相同的无序容器，[`iterator] 和 [`const_iterator] 都是
常量迭代器。

[:en] It is unspecified whether or not [`iterator] and [`const_iterator] are the
same type.
[:zh_CN] [`iterator] 和 [`const_iterator] 是否是相同类型是未指明的。

[begin:note]
[:en] [`iterator] and [`const_iterator] have identical semantics in this case,
and [`iterator] is convertible to [`const_iterator].
[:zh_CN] 这种情况下 [`iterator] 和 [`const_iterator] 具有相同的语义，而且
[`iterator] 可以转换为 [`const_iterator]。

[:en] Users can avoid violating the one definition rule by always using
[`const_iterator] in their function parameter lists.
[:zh_CN] 用户可以通过在其函数形参列表中总是使用 [`const_iterator] 来避免对唯一
定义原则的违反。
[end:note]

[para]
[:en]
[%buckets]
[%hash code]
The elements of an unordered associative container are organized into
[+:% buckets].
[:zh_CN]
[%桶]
[%散列码]
无序关联容器的元素被组织到各个[+:% 桶]中。

[:en] Keys with the same hash code appear in the same bucket.
[:zh_CN] 具有相同散列码的键处于相同的桶中。

[:en] The number of buckets is automatically increased as elements are added to
an unordered associative container, so that the average number of elements per
bucket is kept below a bound.
[:zh_CN] 桶的数量是向无序关联容器中添加元素时自动增长的，以此来保持每个桶的平均
元素数量低于某个界限。

[:en] Rehashing invalidates iterators, changes ordering between elements, and
changes which buckets elements appear in, but does not invalidate pointers or
references to elements.
[:zh_CN] 重散列将会使迭代器失效，改变元素之间的顺序，并改变元素出现于哪个桶中，
但不会使指代元素的指针或引用失效。

[:en] For [`unordered_multiset] and [`unordered_multimap], rehashing preserves
the relative ordering of equivalent elements.
[:zh_CN] 对于 [`unordered_multiset] 和 [`unordered_multimap]，重散列时保持等价
元素之间的相对顺序。

[para]
[:en]
[%unordered associative containers]
[%unordered associative containers[!requirements]]
[%requirements[!unordered associative container]]
[%unordered associative containers[!unique keys]]
[%unordered associative containers[!equivalent keys]]
[%requirements[!container]]
In this subclause:
[:zh_CN]
[%无序关联容器]
[%无序关联容器[!规定]]
[%规定[!无序关联容器]]
[%无序关联容器[!唯一键]]
[%无序关联容器[!等价键]]
[%规定[!容器]]
本子条款中：

[list]
[item]
[:en] [`X] denotes an unordered associative container class,
[:zh_CN] [`X] 代表某个无序关联容器类，
[item]
[:en] [`a] denotes a value of type [`X],
[:zh_CN] [`a] 代表 [`X] 类型的值，
[item]
[:en] [`a2] denotes a value of a type with nodes compatible with type [`X]
([#:tab#container.node.compat]),
[:zh_CN] [`a2] 代表具有与类型 [`X] 兼容的节点（[#:tab#container.node.compat]）的
类型的值，
[item]
[:en] [`b] denotes a value of type [`X] or [`const X],
[:zh_CN] [`b] 代表 [`X] 或 [`const X] 类型的值，
[item]
[:en] [`a_uniq] denotes a value of type [`X] when [`X] supports unique keys,
[:zh_CN] [`a_uniq] 代表当 [`X] 支持唯一键时 [`X] 类型的值，
[item]
[:en] [`a_eq] denotes a value of type [`X] when [`X] supports equivalent keys,
[:zh_CN] [`a_eq] 代表当 [`X] 支持等价键时 [`X] 类型的值，
[item]
[:en] [`a_tran] denotes a value of type [`X] or [`const X] when the
[~qualified-id]s [`X::key_equal::is_transparent] an [`X::hasher::is_transparent]
are both valid and denote types ([#temp.deduct]),
[:zh_CN] [`a_tran] 在当[~限定标识] [`X::key_equal::is_transparent] 和
[`X::hasher::is_transparent] 均有效且代表类型（[#temp.deduct]）时，代表 [`X] 或
[`const X] 类型的值，
[item]
[:en] [`i] and [`j] denote input iterators that refer to [`value_type],
[:zh_CN] [`i] 和 [`j] 代表指代 [`value_type] 的输入迭代器，
[item]
[:en] [``[i, j)] denotes a valid range,
[:zh_CN] [``[i, j)] 代表有效的范围，
[item]
[:en] [`rg] denotes a value of a type [`R] that models
[`[*:c container-compatible-range]<value_type>],
[:zh_CN] [`rg] 代表构成了 [`[*:c container-compatible-range]<value_type>] 的
类型 [`R] 的值，
[item]
[:en] [`p] and [`q2] denote valid constant iterators to [`a],
[:zh_CN] [`p] 和 [`q2] 代表 [`a] 的有效常量迭代器，
[item]
[:en] [`q] and [`q1] denote valid dereferenceable constant iterators to [`a],
[:zh_CN] [`q] 和 [`q1] 代表 [`a] 的有效可解引用常量迭代器，
[item]
[:en] [`r] denotes a valid dereferenceable iterator to [`a],
[:zh_CN] [`r] 代表 [`a] 的有效可解引用迭代器，
[item]
[:en] [``[q1, q2)] denotes a valid range in [`a],
[:zh_CN] [``[q1, q2)] 代表 [`a] 中的有效范围，
[item]
[:en] [`il] denotes a value of type [`initializer_list<value_type>],
[:zh_CN] [`il] 代表 [`initializer_list<value_type>] 类型的值，
[item]
[:en] [`t] denotes a value of type [`X::value_type],
[:zh_CN] [`t] 代表 [`X::value_type] 类型的值，
[item]
[:en] [`k] denotes a value of type [`key_type],
[:zh_CN] [`k] 代表 [`X::key_type] 类型的值，
[item]
[:en] [`hf] denotes a value of type [`hasher] or [`const hasher],
[:zh_CN] [`hf] 代表 [`hasher] 或 [`const hasher] 类型的值，
[item]
[:en] [`eq] denotes a value of type [`key_equal] or [`const key_equal],
[:zh_CN] [`eq] 代表 [`key_equal] 或 [`const key_equal] 类型的值，
[item]
[:en] [`ke] is a value such that
[list]
[item]
[:en@~] [`eq(r1, ke) == eq(ke, r1)],
[:zh_CN@~] [`eq(r1, ke) == eq(ke, r1)]，
[item]
[:en@~] [`hf(r1) == hf(ke)] if [`eq(r1, ke)] is [`true], and
[:zh_CN@~] 当 [`eq(r1, ke)] 为 [`true] 是有 [`hf(r1) == hf(ke)]，且
[item]
[:en@~] if any two of [`eq(r1, ke)], [`eq(r2, ke)], and [`eq(r1, r2)] are [`true],
then all three are [`true],
[:zh_CN@~] 当 [`eq(r1, ke)]，[`eq(r2, ke)] 和 [`eq(r1, r2)] 中任意两个为 [`true]
时，三者均为 [`true]，
[list:end]
[:en@~] where [`r1] and [`r2] are keys of elements in [`a_tran],
[:zh_CN@~] 其中 [`r1] 和 [`r2] 为 [`a_tran] 中的元素的键，
[item]
[:en] [`kx] is a value such that
[list]
[item]
[:en@~] [`eq(r1, kx) == eq(kx, r1)],
[:zh_CN@~] [`eq(r1, kx) == eq(kx, r1)]，
[item]
[:en@~] [`hf(r1) == hf(kx)] if [`eq(r1, kx)] is [`true],
[:zh_CN@~] 当 [`eq(r1, kx)] 为 [`true] 是有 [`hf(r1) == hf(kx)]，
[item]
[:en@~] if any two of [`eq(r1, kx)], [`eq(r2, kx)], and [`eq(r1, r2)] are [`true],
then all three are [`true],
[:zh_CN@~] 当 [`eq(r1, kx)]，[`eq(r2, kx)] 和 [`eq(r1, r2)] 中任意两个为 [`true]
时，三者均为 [`true]，
[item]
[:en@~] [`kx] is not convertible to either [`iterator] or [`const_iterator],
[:zh_CN@~] [`kx] 不能转换为 [`iterator] 或 [`const_iterator]，
[list:end]
[:en@~] where [`r1] and [`r2] are keys of elements in [`a_tran],
[:zh_CN@~] 其中 [`r1] 和 [`r2] 为 [`a_tran] 中的元素的键，
[item]
[:en] [`n] denotes a value of type [`size_type],
[:zh_CN] [`n] 代表 [`size_type] 类型的值，
[item]
[:en] [`z] denotes a value of type [`float], and
[:zh_CN] [`z] 代表 [`float] 类型的值，并且
[item]
[:en] [`nh] denotes an rvalue of type [`X::node_type].
[:zh_CN] [`nh] 代表 [`X::node_type] 类型的右值。
[list:end]

[para]
[:en] A type [`X] meets the [+:adj unordered associative[!container]]
requirements if [`X] meets all the requirements of an allocator-aware container
([#container.alloc.reqmts]) and the following types, statements, and expressions are
well-formed and have the specified semantics, except that for [`unordered_map]
and [`unordered_multimap], the requirements placed on [`value_type] in
[#container.reqmts] apply instead to [`key_type] and [`mapped_type].
[:zh_CN] 如果类型 [`X] 满足分配器感知容器的所要规定（[#container.alloc.reqmts]），并且
下列各类型、语句和表达式均良构且具有规定的语义，则 [`X] 满足[+:adj 无序关联[!容器]]
的规定，但对于 [`unordered_map] 和 [`unordered_multimap]，[#container.reqmts]
中针对 [`value_type] 的规定改为针对 [`key_type] 和 [`mapped_type]。

[begin:note]
[:en] For example, [`key_type] and [`mapped_type] sometimes need to be
[^:oc CopyAssignable] even though the associated [`value_type],
[`pair<const key_type, mapped_type>], is not [^:oc CopyAssignable].
[:zh_CN] 例如，有时候需要 [`key_type] 和 [`mapped_type] 为 [^:oc CopyAssignable]，
即使其所关联的 [`value_type]（即 [`pair<const key_type, mapped_type>]）并非
[^:oc CopyAssignable]。
[end:note]

[<
@applyTo(['?indexunordmem'])
def indexunordmem(_1):
    return f'''[%@lib@raw [`{_1}][![:en]unordered associative containers[:zh_CN]无序关联容器]]
    [%@lib@raw [`unordered_set][![`{_1}]]]
    [%@lib@raw [`unordered_map][![`{_1}]]]
    [%@lib@raw [`unordered_multiset][![`{_1}]]]
    [%@lib@raw [`unordered_multimap][![`{_1}]]]'''
>]

[?indexunordmem key_type]
[codeblock:declaration]
typename X::key_type
[codeblock:end]

[div:description]
[para:result]
[:en] [`Key].
[:zh_CN] [`Key]。
[div:end]

[?indexunordmem mapped_type]
[codeblock:declaration]
typename X::mapped_type
[codeblock:end]

[div:description]
[para:result]
[:en] [`T].
[:zh_CN] [`T]。

[para:remarks]
[:en] For [`unordered_map] and [`unordered_multimap] only.
[:zh_CN] 仅为 [`unordered_map] 和 [`unordered_multimap] 提供。
[div:end]

[?indexunordmem value_type]
[codeblock:declaration]
typename X::value_type
[codeblock:end]

[div:description]
[para:result]
[:en] [`Key] for [`unordered_set] and [`unordered_multiset] only;
[`pair<const Key, T>] for [`unordered_map] and [`unordered_multimap] only.
[:zh_CN] 仅对于 [`unordered_set] 和 [`unordered_multiset] 为 [`Key]；仅对于
[`unordered_map] 和 [`unordered_multimap] 为 [`pair<const Key, T>]。

[para:expects]
[:en] [`value_type] is [^:oc Erasable] from [`X].
[:zh_CN] [`value_type] 为从 [`X] 中 [^:oc Erasable]。
[div:end]

[?indexunordmem hasher]
[codeblock:declaration]
typename X::hasher
[codeblock:end]

[div:description]
[para:result]
[:en] [`Hash].
[:zh_CN] [`Hash]。

[para:expects]
[:en] [`Hash] is a unary function object type such that the expression [`hf(k)]
has type [`size_t].
[:zh_CN] [`Hash] 为一元函数对象类型，并使表达式 [`hf(k)] 的类型为 [`size_t]。
[div:end]

[?indexunordmem key_equal]
[codeblock:declaration]
typename X::key_equal
[codeblock:end]

[div:description]
[para:result]
[:en] [`Pred].
[:zh_CN] [`Pred]。

[para:expects]
[:en] [`Pred] meets the [^:oc CopyConstructible] requirements.
[:zh_CN] [`Pred] 满足 [^:oc CopyConstructible] 的规定。

[:en] [`Pred] is a binary predicate that takes two arguments of type [`Key].
[:zh_CN] [`Pred] 为接受两个 [`Key] 类型的实参的二元谓词。

[:en] [`Pred] is an equivalence relation.
[:zh_CN] [`Pred] 为一种等价关系。
[div:end]

[?indexunordmem local_iterator]
[codeblock:declaration]
typename X::local_iterator
[codeblock:end]

[div:description]
[para:result]
[:en] An iterator type whose category, value type, difference type, and pointer
and reference types are the same as [`X::iterator][=']s.
[:zh_CN] 具有与 [`X::iterator] 相同的类别，值类型，差类型，以及指针和引用类型的
迭代器类型。

[begin:note]
[:en] A [`local_iterator] object may be used to iterate through a single bucket,
but may not be used to iterate across buckets.
[:zh_CN] [`local_iterator] 对象可被用于在一个桶中迭代，但不能用于跨越不同桶
的迭代。
[end:note]
[div:end]

[?indexunordmem const_local_iterator]
[codeblock:declaration]
typename X::const_local_iterator
[codeblock:end]

[div:description]
[para:result]
[:en] An iterator type whose category, value type, difference type, and pointer
and reference types are the same as [`X::const_iterator][=']s.
[:zh_CN] 具有与 [`X::const_iterator] 相同的类别，值类型，差类型，以及指针和
引用类型的迭代器类型。

[begin:note]
[:en] A [`const_local_iterator] object may be used to iterate through a single
bucket, but may not be used to iterate across buckets.
[:zh_CN] [`const_local_iterator] 对象可被用于在一个桶中迭代，但不能用于跨越不同
桶的迭代。
[end:note]
[div:end]

[?indexunordmem node_type]
[codeblock:declaration]
typename X::node_type
[codeblock:end]

[div:description]
[para:result]
[:en] A specialization of a [*node-handle] class template ([#container.node]),
such that the public nested types are the same types as the corresponding types
in [`X].
[:zh_CN] 类模板 [*node-handle] 的特例（[#container.node]），其各个公开嵌套类型与
[`X] 中的对应类型为相同的类型。
[div:end]

[%@lib@ctor unordered_set]
[%@lib@ctor unordered_map]
[%@lib@ctor unordered_multiset]
[%@lib@ctor unordered_multimap]
[codeblock:declaration]
X(n, hf, eq)
[codeblock:end]

[div:description]
[para:effects]
[:en] Constructs an empty container with at least [`n] buckets, using [`hf] as
the hash function and [`eq] as the key equality predicate.
[:zh_CN] 构造一个具有至少 [`n] 个桶的空容器，使用 [`hf] 作为其散列函数，并使用
[`eq] 作为其键相等性谓词。

[para:complexity]
[?bigoh [`n]]
[div:end]

[codeblock:declaration]
X(n, hf)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`key_equal] meets the [^:oc DefaultConstructible] requirements.
[:zh_CN] [`key_equal] 满足 [^:oc DefaultConstructible] 的规定。

[para:effects]
[:en] Constructs an empty container with at least [`n] buckets, using [`hf]
as the hash function and [`key_equal()] as the key equality predicate.
[:zh_CN] 构造一个具有至少 [`n] 个桶的空容器，使用 [`hf] 作为其散列函数，并
使用 [`key_equal()] 作为其键相等性谓词。

[para:complexity]
[?bigoh [`n]]
[div:end]

[codeblock:declaration]
X(n)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`hasher] and [`key_equal] meet the [^:oc DefaultConstructible]
requirements.
[:zh_CN] [`hasher] 和 [`key_equal] 满足 [^:oc DefaultConstructible] 的规定。

[para:effects]
[:en] Constructs an empty container with at least [`n] buckets, using [`hasher()]
as the hash function and [`key_equal()] as the key equality predicate.
[:zh_CN] 构造一个具有至少 [`n] 个桶的空容器，使用 [`hasher()] 作为其散列函数，
并使用 [`key_equal()] 作为其键相等性谓词。

[para:complexity]
[?bigoh [`n]]
[div:end]

[codeblock:declaration]
X a = X();
X a;
[codeblock:end]

[div:description]
[para:expects]
[:en] [`hasher] and [`key_equal] meet the [^:oc DefaultConstructible]
requirements.
[:zh_CN] [`hasher] 和 [`key_equal] 满足 [^:oc DefaultConstructible] 的规定。

[para:effects]
[:en] Constructs an empty container with an unspecified number of buckets, using
[`hasher()] as the hash function and [`key_equal()] as the key equality predicate.
[:zh_CN] 构造一个具有未指明的桶数的空容器，使用 [`hasher()] 作为其散列函数，
并使用 [`key_equal()] 作为其键相等性谓词。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[codeblock:declaration]
X(i, j, n, hf, eq)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`*i].
[:zh_CN] [`value_type] 为以 [`*i] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container with at least [`n] buckets, using [`hf]
as the hash function and [`eq] as the key equality predicate, and inserts
elements from [=range(i,j)] into it.
[:zh_CN] 构造一个具有至少 [`n] 个桶的空容器，使用 [`hf] 作为其散列函数，并
使用 [`eq] 作为其键相等性谓词，并且将 [=range(i,j)] 中的元素插入其中。

[para:complexity]
[:en] Average case [?bigoh N] ([$N] is [`distance(i, j)]), worst case [?bigoh N^2].
[:zh_CN] 平均情况为 [?bigoh N]（[$N] 为 [`distance(i, j)]），最差情况为 [?bigoh N^2]。
[div:end]

[codeblock:declaration]
X(i, j, n, hf)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`key_equal] meets the [^:oc DefaultConstructible] requirements.
[:zh_CN] [`key_equal] 满足 [^:oc DefaultConstructible] 的规定。

[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`*i].
[:zh_CN] [`value_type] 为以 [`*i] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container with at least [`n] buckets, using [`hf]
as the hash function and [`key_equal()] as the key equality predicate, and
inserts elements from [=range(i,j)] into it.
[:zh_CN] 构造一个具有至少 [`n] 个桶的空容器，使用 [`hf] 作为其散列函数，并
使用 [`key_equal()] 作为其键相等性谓词，并且将 [=range(i,j)] 中的元素插入其中。

[para:complexity]
[:en] Average case [?bigoh N] ([$N] is [`distance(i, j)]), worst case [?bigoh N^2].
[:zh_CN] 平均情况为 [?bigoh N]（[$N] 为 [`distance(i, j)]），最差情况为 [?bigoh N^2]。
[div:end]

[codeblock:declaration]
X(i, j, n)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`hasher] and [`key_equal] meet the [^:oc DefaultConstructible]
requirements.
[:zh_CN] [`hasher] 和 [`key_equal] 满足 [^:oc DefaultConstructible] 的规定。

[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`*i].
[:zh_CN] [`value_type] 为以 [`*i] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container with at least [`n] buckets, using [`hasher()]
as the hash function and [`key_equal()] as the key equality predicate, and
inserts elements from [=range(i,j)] into it.
[:zh_CN] 构造一个具有至少 [`n] 个桶的空容器，使用 [`hasher()] 作为其散列函数，并
使用 [`key_equal()] 作为其键相等性谓词，并且将 [=range(i,j)] 中的元素插入其中。

[para:complexity]
[:en] Average case [?bigoh N] ([$N] is [`distance(i, j)]), worst case [?bigoh N^2].
[:zh_CN] 平均情况为 [?bigoh N]（[$N] 为 [`distance(i, j)]），最差情况为 [?bigoh N^2]。
[div:end]

[codeblock:declaration]
X(i, j)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`hasher] and [`key_equal] meet the [^:oc DefaultConstructible]
requirements.
[:zh_CN] [`hasher] 和 [`key_equal] 满足 [^:oc DefaultConstructible] 的规定。

[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`*i].
[:zh_CN] [`value_type] 为以 [`*i] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container with an unspecified number of buckets, using
[`hasher()] as the hash function and [`key_equal()] as the key equality
predicate, and inserts elements from [=range(i,j)] into it.
[:zh_CN] 构造一个具有未指明的桶数的空容器，使用 [`hasher()] 作为其散列函数，并
使用 [`key_equal()] 作为其键相等性谓词，并且将 [=range(i,j)] 中的元素插入其中。

[para:complexity]
[:en] Average case [?bigoh N] ([$N] is [`distance(i, j)]), worst case [?bigoh N^2].
[:zh_CN] 平均情况为 [?bigoh N]（[$N] 为 [`distance(i, j)]），最差情况为 [?bigoh N^2]。
[div:end]

[codeblock:declaration]
X(from_range, rg, n, hf, eq)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from
[`*ranges::begin(rg)].
[:zh_CN] [`value_type] 为以 [`*ranges::begin(rg)] 向 [`X] 中
[^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container with at least [`n] buckets, using [`hf]
as the hash function and [`eq] as the key equality predicate, and inserts
elements from [`rg] into it.
[:zh_CN] 构造一个具有至少 [`n] 个桶的空容器，使用 [`hf] 作为其散列函数，并使用
[`eq] 作为其键相等性谓词，并且将 [`rg] 中的元素插入其中。

[para:complexity]
[:en] Average case [?bigoh N] ([$N] is [`ranges::distance(rg)]), worst case
[?bigoh N^2].
[:zh_CN] 平均情况为 [?bigoh N]（[$N] 为 [`ranges::distance(rg)]），最差情况为
[?bigoh N^2]。
[div:end]

[codeblock:declaration]
X(from_range, rg, n, hf)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`key_equal] meets the [^:oc DefaultConstructible] requirements.
[:zh_CN] [`key_equal] 满足 [^:oc DefaultConstructible] 的规定。

[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from
[`*ranges::begin(rg)].
[:zh_CN] [`value_type] 为以 [`*ranges::begin(rg)] 向 [`X] 中
[^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container with at least [`n] buckets, using [`hf]
as the hash function and [`key_equal()] as the key equality predicate, and
inserts elements from [`rg] into it.
[:zh_CN] 构造一个具有至少 [`n] 个桶的空容器，使用 [`hf] 作为其散列函数，并使用
[`key_equal()] 作为其键相等性谓词，并且将 [`rg] 中的元素插入其中。

[para:complexity]
[:en] Average case [?bigoh N] ([$N] is [`ranges::distance(rg)]), worst case
[?bigoh N^2].
[:zh_CN] 平均情况为 [?bigoh N]（[$N] 为 [`ranges::distance(rg)]），最差情况为
[?bigoh N^2]。
[div:end]

[codeblock:declaration]
X(from_range, rg, n)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`hasher] and [`key_equal] meet the [^:oc DefaultConstructible]
requirements.
[:zh_CN] [`hasher] 和 [`key_equal] 满足 [^:oc DefaultConstructible] 的规定。

[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from
[`*ranges::begin(rg)].
[:zh_CN] [`value_type] 为以 [`*ranges::begin(rg)] 向 [`X] 中
[^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container with at least [`n] buckets, using [`hasher()]
as the hash function and [`key_equal()] as the key equality predicate, and
inserts elements from [`rg] into it.
[:zh_CN] 构造一个具有至少 [`n] 个桶的空容器，使用 [`hasher()] 作为其散列函数，并
使用 [`key_equal()] 作为其键相等性谓词，并且将 [`rg] 中的元素插入其中。

[para:complexity]
[:en] Average case [?bigoh N] ([$N] is [`ranges::distance(rg)]), worst case
[?bigoh N^2].
[:zh_CN] 平均情况为 [?bigoh N]（[$N] 为 [`ranges::distance(rg)]），最差情况为
[?bigoh N^2]。
[div:end]

[codeblock:declaration]
X(from_range, rg)
[codeblock:end]

[div:description]
[para:expects]
[:en] [`hasher] and [`key_equal] meet the [^:oc DefaultConstructible]
requirements.
[:zh_CN] [`hasher] 和 [`key_equal] 满足 [^:oc DefaultConstructible] 的规定。

[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from
[`*ranges::begin(rg)].
[:zh_CN] [`value_type] 为以 [`*ranges::begin(rg)] 向 [`X] 中
[^:oc EmplaceConstructible]。

[para:effects]
[:en] Constructs an empty container with an unspecified number of buckets, using
[`hasher()] as the hash function and [`key_equal()] as the key equality
predicate, and inserts elements from [`rg] into it.
[:zh_CN] 构造一个具有未指明的桶数的空容器，使用 [`hasher()] 作为其散列函数，并
使用 [`key_equal()] 作为其键相等性谓词，并且将 [`rg] 中的元素插入其中。

[para:complexity]
[:en] Average case [?bigoh N] ([$N] is [`ranges::distance(rg)]), worst case
[?bigoh N^2].
[:zh_CN] 平均情况为 [?bigoh N]（[$N] 为 [`ranges::distance(rg)]），最差情况为
[?bigoh N^2]。
[div:end]

[codeblock:declaration]
X(il)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`X(il.begin(), il.end())].
[:zh_CN] 等价于 [`X(il.begin(), il.end())]。
[div:end]

[codeblock:declaration]
X(il, n)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`X(il.begin(), il.end(), n)].
[:zh_CN] 等价于 [`X(il.begin(), il.end(), n)]。
[div:end]

[codeblock:declaration]
X(il, n, hf)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`X(il.begin(), il.end(), n, hf)].
[:zh_CN] 等价于 [`X(il.begin(), il.end(), n, hf)]。
[div:end]

[codeblock:declaration]
X(il, n, hf, eq)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`X(il.begin(), il.end(), n, hf, eq)].
[:zh_CN] 等价于 [`X(il.begin(), il.end(), n, hf, eq)]。
[div:end]

[codeblock:declaration]
X(b)
[codeblock:end]

[div:description]
[para:effects]
[:en] In addition to the container requirements ([#container.reqmts]), copies
the hash function, predicate, and maximum load factor.
[:zh_CN] 除了容器的规定（[#container.reqmts]）外，还复制散列函数，谓词，以及最大
负载系数。

[para:complexity]
[:en] Average case linear in [`b.size()], worst case quadratic.
[:zh_CN] 平均情况下对于 [`b.size()] 线性，最差情况为平方阶。
[div:end]

[codeblock:declaration]
a = b
[codeblock:end]

[div:description]
[para:result] [`X&]

[para:effects]
[:en] In addition to the container requirements, copies the hash function,
predicate, and maximum load factor.
[:zh_CN] 除了容器的规定外，还复制散列函数，谓词，以及最大负载系数。

[para:complexity]
[:en] Average case linear in [`b.size()], worst case quadratic.
[:zh_CN] 平均情况下对于 [`b.size()] 线性，最差情况为平方阶。
[div:end]

[codeblock:declaration]
a = il
[codeblock:end]

[div:description]
[para:result] [`X&]

[para:expects]
[:en] [`value_type] is [^:oc CopyInsertable] into [`X] and [^:oc CopyAssignable].
[:zh_CN] [`value_type] 为向 [`X] 中 [^:oc CopyInsertable]，且为
[^:oc CopyAssignable]。

[para:effects]
[:en] Assigns the range [=range(il.begin(),il.end())] into [`a].
[:zh_CN] 将范围 [=range(il.begin(),il.end())] 赋值到 [`a] 中。

[:en] All existing elements of [`a] are either assigned to or destroyed.
[:zh_CN] [`a] 的所有现存元素要么被赋值要么被销毁。

[para:complexity]
[:en] Average case linear in [`il.size()], worst case quadratic.
[:zh_CN] 平均情况下对于 [`il.size()] 线性，最差情况为平方阶。
[div:end]

[?indexunordmem hash_function]
[codeblock:declaration]
b.hash_function()
[codeblock:end]

[div:description]
[para:result] [`hasher]

[para:returns]
[:en] [`b][=']s hash function.
[:zh_CN] [`b] 的散列函数。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem key_eq]
[codeblock:declaration]
b.key_eq()
[codeblock:end]

[div:description]
[para:result] [`key_equal]

[para:returns]
[:en] [`b][=']s key equality predicate.
[:zh_CN] [`b] 的键相等性谓词。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem emplace]
[codeblock:declaration]
a_uniq.emplace(args)
[codeblock:end]

[div:description]
[para:result] [`pair<iterator, bool>]

[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`args].
[:zh_CN] [`value_type] 为以 [`args] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Inserts a [`value_type] object [`t] constructed with
[`std::forward<Args>(args)...] if and only if there is no element in the
container with key equivalent to the key of [`t].
[:zh_CN] 当且仅当容器中不存在其键与 [`t] 的键等价的元素时，插入以
[`std::forward<Args>(args)...] 构造的 [`value_type] 对象 [`t]。

[para:returns]
[:en] The [`bool] component of the returned pair is [`true] if and only if
the insertion takes place, and the iterator component of the pair points
to the element with key equivalent to the key of [`t].
[:zh_CN] 当且仅当发生了插入时，所返回的对偶的 [`bool] 成分为 [`true]；对偶的
[`iterator] 成分指向其键与 [`t] 的键等价的元素。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a_uniq.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a_uniq.size()]]。
[div:end]

[?indexunordmem emplace]
[codeblock:declaration]
a_eq.emplace(args)
[codeblock:end]

[div:description]
[para:result] [`iterator]

[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`args].
[:zh_CN] [`value_type] 为以 [`args] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Inserts a [`value_type] object [`t] constructed with
[`std::forward<Args>(args)...].
[:zh_CN] 插入以 [`std::forward<Args>(args)...] 构造的 [`value_type] 对象 [`t]。

[para:returns]
[:en] An iterator pointing to the newly inserted element.
[:zh_CN] 指向新插入元素的迭代器。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a_eq.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a_eq.size()]]。
[div:end]

[?indexunordmem emplace_hint]
[codeblock:declaration]
a.emplace_hint(p, args)
[codeblock:end]

[div:description]
[para:result] [`iterator]

[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`args].
[:zh_CN] [`value_type] 为以 [`args] 向 [`X] 中 [^:oc EmplaceConstructible]。

[para:effects]
[:en] Equivalent to [`a.emplace(std::forward<Args>(args)...)].
[:zh_CN] 等价于 [`a.emplace(std::forward<Args>(args)...)]。

[para:returns]
[:en] An iterator pointing to the element with the key equivalent to the newly
inserted element.
[:zh_CN] 指向其键等价于新插入的元素的元素的迭代器。

[:en] The [`const_iterator] [`p] is a hint pointing to where the search
should start.
[:zh_CN] [`const_iterator] [`p] 是对最好从何处开始搜索的提示。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a.size()]]。
[div:end]

[?indexunordmem insert]
[codeblock:declaration]
a_uniq.insert(t)
[codeblock:end]

[div:description]
[para:result] [`pair<iterator, bool>]

[para:expects]
[:en] If [`t] is a non-const rvalue, [`value_type] is [^:oc MoveInsertable]
into [`X]; otherwise, [`value_type] is [^:oc CopyInsertable] into [`X].
[:zh_CN] 如果 [`t] 是非 const 右值，则 [`value_type] 为向 [`X] 中
[^:oc MoveInsertable]；否则 [`value_type] 为向 [`X] 中 [^:oc CopyInsertable]。

[para:effects]
[:en] Inserts [`t] if and only if there is no element in the container with
key equivalent to the key of [`t].
[:zh_CN] 当且仅当容器中不存在其键与 [`t] 的键等价的元素时，插入 [`t]。

[para:returns]
[:en] The [`bool] component of the returned pair indicates whether the insertion
takes place, and the [`iterator] component points to the element with key
equivalent to the key of [`t].
[:zh_CN] 所返回的对偶的 [`bool] 成分指出是否发生了插入，而 [`iterator] 成分指向
其键与 [`t] 的键等价的元素。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a_uniq.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a_uniq.size()]]。
[div:end]

[?indexunordmem insert]
[codeblock:declaration]
a_eq.insert(t)
[codeblock:end]

[div:description]
[para:result] [`iterator]

[para:expects]
[:en] If [`t] is a non-const rvalue, [`value_type] is [^:oc MoveInsertable]
into [`X]; otherwise, [`value_type] is [^:oc CopyInsertable] into [`X].
[:zh_CN] 如果 [`t] 是非 const 右值，则 [`value_type] 为向 [`X] 中
[^:oc MoveInsertable]；否则 [`value_type] 为向 [`X] 中 [^:oc CopyInsertable]。

[para:effects]
[:en] Inserts [`t].
[:zh_CN] 插入 [`t]。

[para:returns]
[:en] An iterator pointing to the newly inserted element.
[:zh_CN] 指向新插入元素的迭代器。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a_eq.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a_eq.size()]]。
[div:end]

[?indexunordmem insert]
[codeblock:declaration]
a.insert(p, t)
[codeblock:end]

[div:description]
[para:result] [`iterator]

[para:expects]
[:en] If [`t] is a non-const rvalue, [`value_type] is [^:oc MoveInsertable]
into [`X]; otherwise, [`value_type] is [^:oc CopyInsertable] into [`X].
[:zh_CN] 如果 [`t] 是非 const 右值，则 [`value_type] 为向 [`X] 中
[^:oc MoveInsertable]；否则 [`value_type] 为向 [`X] 中 [^:oc CopyInsertable]。

[para:effects]
[:en] Equivalent to [`a.insert(t)].
[:zh_CN] 等价于 [`a.insert(t)]。

[:en] The iterator [`p] is a hint pointing to where the search should start.
[:zh_CN] 迭代器 [`p] 是对最好从何处开始搜索的提示。

[:en] Implementations are permitted to ignore the hint.
[:zh_CN] 允许实现忽略这个提示。

[para:returns]
[:en] An iterator pointing to the element with the key equivalent to that of [`t].
[:zh_CN] 指向其键与 [`t] 的键等价的元素的迭代器。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a.size()]]。
[div:end]

[?indexunordmem insert]
[codeblock:declaration]
a.insert(i, j)
[codeblock:end]

[div:description]
[para:result] [`:key void]

[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from [`*i].
[:zh_CN] [`value_type] 为以 [`*i] 向 [`X] 中 [^:oc EmplaceConstructible]。

[:en] Neither [`i] nor [`j] are iterators in [`a].
[:zh_CN] [`i] 和 [`j] 都不是 [`a] 中的迭代器。

[para:effects]
[:en] Equivalent to [`a.insert(t)] for each element in [``[i,j)].
[:zh_CN] 等价于对 [``[i,j)] 中的每个元素执行 [`a.insert(t)]。

[para:complexity]
[:en] Average case [?bigoh N], where [$N] is [`distance(i, j)], worst case
[?bigoh N([`a.size()]+1)].
[:zh_CN] 平均情况为 [?bigoh N]，其中 [$N] 为 [`distance(i, j)]，最差情况为
[?bigoh N([`a.size()]+1)]。
[div:end]

[?indexunordmem insert_range]
[codeblock:declaration]
a.insert_range(rg)
[codeblock:end]

[div:description]
[para:result] [`:key void]

[para:expects]
[:en] [`value_type] is [^:oc EmplaceConstructible] into [`X] from
[`*ranges::begin(rg)].
[:zh_CN] [`value_type] 为以 [`*ranges::begin(rg)] 向 [`X] 中
[^:oc EmplaceConstructible]。

[:en] [`rg] and [`a] do not overlap.
[:zh_CN] [`rg] 和 [`a] 没有交叠。

[para:effects]
[:en] Equivalent to [`a.insert(t)] for each element [`t] in [`rg].
[:zh_CN] 等价于对 [`rg] 中的每个元素 [`t] 执行 [`a.insert(t)]。

[para:complexity]
[:en] Average case [?bigoh N], where [$N] is [`ranges::distance(rg)], worst case
[?bigoh N([`a.size()]+1)].
[:zh_CN] 平均情况为 [?bigoh N]，其中 [$N] 为 [`ranges::distance(rg)]，最差情况为
[?bigoh N([`a.size()]+1)]。
[div:end]

[?indexunordmem insert]
[codeblock:declaration]
a.insert(il)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`a.insert(il.begin(), il.end())].
[:zh_CN] 等价于 [`a.insert(il.begin(), il.end())]。
[div:end]

[?indexunordmem insert]
[codeblock:declaration]
a_uniq.insert(nh)
[codeblock:end]

[div:description]
[para:result] [`insert_return_type]

[para:expects]
[:en] [`nh] is empty or [`a_uniq.get_allocator() == nh.get_allocator()] is
[`true].
[:zh_CN] [`nh] 为空，或者 [`a_uniq.get_allocator() == nh.get_allocator()] 为
[`true]。

[para:effects]
[:en] If [`nh] is empty, has no effect.
[:zh_CN] 若 [`nh] 为空则没有效果。

[:en] Otherwise, inserts the element owned by [`nh] if and only if there is
no element in the container with a key equivalent to [`nh.key()].
[:zh_CN] 否则，当且仅当该容器中不存在其键与 [`nh.key()] 的键等价的元素时，
插入由 [`nh] 所拥有的元素。

[para:ensures]
[:en] If [`nh] is empty, [`inserted] is [`false], [`position] is [`end()],
and [`node] is empty.
[:zh_CN] 若 [`nh] 为空，则 [`inserted] 为 [`false]，[`position] 为 [`end()]，
且 [`node] 为空。

[:en] Otherwise if the insertion took place, [`inserted] is [`true], [`position]
points to the inserted element, and [`node] is empty; if the insertion failed,
[`inserted] is [`false], [`node] has the previous value of [`nh], and [`position]
points to an element with a key equivalent to [`nh.key()].
[:zh_CN] 否则如果发生了插入，则 [`inserted] 为 [`true]，[`position] 指向所插入的
元素，而 [`node] 为空；如果插入失败，则 [`inserted] 为 [`false]，[`node] 具有
[`nh] 之前的值，而 [`position] 指向其键与 [`nh.key()] 的键等价的元素。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a_uniq.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a_uniq.size()]]。
[div:end]

[?indexunordmem insert]
[codeblock:declaration]
a_eq.insert(nh)
[codeblock:end]

[div:description]
[para:result] [`iterator]

[para:expects]
[:en] [`nh] is empty or [`a_eq.get_allocator() == nh.get_allocator()] is [`true].
[:zh_CN] [`nh] 为空，或者 [`a_eq.get_allocator() == nh.get_allocator()] 为 [`true]。

[para:effects]
[:en] If [`nh] is empty, has no effect and returns [`a_eq.end()].
[:zh_CN] 若 [`nh] 为空，则没有效果并返回 [`a_eq.end()]。

[:en] Otherwise, inserts the element owned by [`nh] and returns an iterator
pointing to the newly inserted element.
[:zh_CN] 否则，插入由 [`nh] 所拥有的元素，并返回指向新插入的元素的迭代器。

[para:ensures]
[:en] [`nh] is empty.
[:zh_CN] [`nh] 为空。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a_eq.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a_eq.size()]]。
[div:end]

[?indexunordmem insert]
[codeblock:declaration]
a.insert(q, nh)
[codeblock:end]

[div:description]
[para:result] [`iterator]

[para:expects]
[:en] [`nh] is empty or [`a.get_allocator() == nh.get_allocator()] is [`true].
[:zh_CN] [`nh] 为空，或者 [`a.get_allocator() == nh.get_allocator()] 为 [`true]。

[para:effects]
[:en] If [`nh] is empty, has no effect and returns [`a.end()].
[:zh_CN] 若 [`nh] 为空，则没有效果并返回 [`a.end()]。

[:en] Otherwise, inserts the element owned by [`nh] if and only if there is
no element with key equivalent to [`nh.key()] in containers with unique keys;
always inserts the element owned by [`nh] in containers with equivalent keys.
[:zh_CN] 否则，在带有唯一键的容器中当且仅当不存在其键与 [`nh.key()] 的键等价
的元素时，插入由 [`nh] 所拥有的元素；在带有等价键的容器中总是插入由 [`nh] 所
拥有的元素。

[:en] The iterator [`q] is a hint pointing to where the search should start.
[:zh_CN] 迭代器 [`q] 是对最好从何处开始搜索的提示。

[:en] Implementations are permitted to ignore the hint.
[:zh_CN] 允许实现忽略这个提示。

[para:ensures]
[:en] [`nh] is empty if insertion succeeds, unchanged if insertion fails.
[:zh_CN] 若插入成功则 [`nh] 为空，若插入失败则其无变化。

[para:returns]
[:en] An iterator pointing to the element with key equivalent to [`nh.key()].
[:zh_CN] 指向其键与 [`nh.key()] 的键等价的元素的迭代器。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a.size()]]。
[div:end]

[?indexunordmem extract]
[codeblock:declaration]
a.extract(k)
[codeblock:end]

[div:description]
[para:result] [`node_type]

[para:effects]
[:en] Removes an element in the container with key equivalent to [`k].
[:zh_CN] 移除容器中的一个其键与 [`k] 的键等价的元素。

[para:returns]
[:en] A [`node_type] owning the element if found, otherwise an empty [`node_type].
[:zh_CN] 如果找到则为一个拥有该元素的 [`node_type]，否则为空 [`node_type]。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a.size()]]。
[div:end]

[?indexunordmem extract]
[codeblock:declaration]
a_tran.extract(kx)
[codeblock:end]

[div:description]
[para:result] [`node_type]

[para:effects]
[:en] Removes an element in the container with key equivalent to [`kx].
[:zh_CN] 移除容器中的一个其键与 [`kx] 的键等价的元素。

[para:returns]
[:en] A [`node_type] owning the element if found, otherwise an empty [`node_type].
[:zh_CN] 如果找到则为一个拥有该元素的 [`node_type]，否则为空 [`node_type]。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a_tran.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a_tran.size()]]。
[div:end]

[?indexunordmem extract]
[codeblock:declaration]
a.extract(q)
[codeblock:end]

[div:description]
[para:result] [`node_type]

[para:effects]
[:en] Removes the element pointed to by [`q].
[:zh_CN] 移除 [`q] 所指向的元素。

[para:returns]
[:en] A [`node_type] owning that element.
[:zh_CN] 一个拥有该元素的 [`node_type]。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a.size()]]。
[div:end]

[?indexunordmem merge]
[codeblock:declaration]
a.merge(a2)
[codeblock:end]

[div:description]
[para:result] [`:key void]

[para:expects]
[:en] [`a.get_allocator() == a2.get_allocator()].
[:zh_CN] [`a.get_allocator() == a2.get_allocator()]。

[para:effects]
[:en] Attempts to extract each element in [`a2] and insert it into [`a]
using the hash function and key equality predicate of [`a].
[:zh_CN] 尝试提取 [`a2] 中的每个元素，并使用 [`a] 的散列函数和键相等性谓词来
将之插入到 [`a] 之中。

[:en] In containers with unique keys, if there is an element in [`a] with
key equivalent to the key of an element from [`a2], then that element is not
extracted from [`a2].
[:zh_CN] 在带有唯一键的容器中，如果 [`a] 之中存在某个元素的键与 [`a2] 中
的某个元素的键等价，则该元素不会从 [`a2] 中提取出来。

[para:ensures]
[:en] Pointers and references to the transferred elements of [`a2] refer to
those same elements but as members of [`a].
[:zh_CN] 曾指代被迁移的 [`a2] 的元素的指针和引用，仍指代相同的元素，但它们
已经是 [`a] 的成员。

[:en] Iterators referring to the transferred elements and all iterators
referring to [`a] will be invalidated, but iterators to elements remaining
in [`a2] will remain valid.
[:zh_CN] 曾指代被迁移的元素的迭代器和指代 [`a] 的所有迭代器都将失效，但指代
留在 [`a2] 中的元素的迭代器则保持有效。

[para:complexity]
[:en] Average case [?bigoh N], where [$N] is [`a2.size()], worst case
[?bigoh [`*a.size() +] N].
[:zh_CN] 平均情况为 [?bigoh N]，其中 [$N] 为 [`a2.size()]，最差情况为
[?bigoh [`*a.size() +] N]。
[div:end]

[?indexunordmem erase]
[codeblock:declaration]
a.erase(k)
[codeblock:end]

[div:description]
[para:result] [`size_type]

[para:effects]
[:en] Erases all elements with key equivalent to [`k].
[:zh_CN] 清除具有等价于 [`k] 的键的所有元素。

[para:returns]
[:en] The number of elements erased.
[:zh_CN] 所清除的元素数量。

[para:complexity]
[:en] Average case [?bigoh[`a.count(k)]], worst case [?bigoh[`a.size()]].
[:zh_CN] 平均情况为 [?bigoh[`a.count(k)]]，最差情况为 [?bigoh[`a.size()]]。
[div:end]

[?indexunordmem erase]
[codeblock:declaration]
a_tran.erase(kx)
[codeblock:end]

[div:description]
[para:result] [`size_type]

[para:effects]
[:en] Erases all elements with key equivalent to [`kx].
[:zh_CN] 清除具有等价于 [`kx] 的键的所有元素。

[para:returns]
[:en] The number of elements erased.
[:zh_CN] 所清除的元素数量。

[para:complexity]
[:en] Average case [?bigoh[`a_tran.count(kx)]], worst case [?bigoh[`a_tran.size()]].
[:zh_CN] 平均情况为 [?bigoh[`a_tran.count(kx)]]，最差情况为 [?bigoh[`a_tran.size()]]。
[div:end]

[?indexunordmem erase]
[codeblock:declaration]
a.erase(q)
[codeblock:end]

[div:description]
[para:result] [`iterator]

[para:effects]
[:en] Erases the element pointed to by [`q].
[:zh_CN] 清除由 [`q] 所指向的元素。

[para:returns]
[:en] The iterator immediately following [`q] prior to the erasure.
[:zh_CN] 进行清除前紧跟 [`q] 之后的迭代器。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh [`a.size()]]。
[div:end]

[?indexunordmem erase]
[codeblock:declaration]
a.erase(r)
[codeblock:end]

[div:description]
[para:result] [`iterator]

[para:effects]
[:en] Erases the element pointed to by [`r].
[:zh_CN] 清除由 [`r] 所指向的元素。

[para:returns]
[:en] The iterator immediately following [`r] prior to the erasure.
[:zh_CN] 进行清除前紧跟 [`r] 之后的迭代器。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh [`a.size()]]。
[div:end]

[?indexunordmem erase]
[codeblock:declaration]
a.erase(q1, q2)
[codeblock:end]

[div:description]
[para:result] [`iterator]

[para:effects]
[:en] Erases all elements in the range [``[q1, q2)].
[:zh_CN] 清除范围 [``[q1, q2)] 中的所有元素。

[para:returns]
[:en] The iterator immediately following the erased elements prior to the
erasure.
[:zh_CN] 进行清除前紧跟所清除的元素之后的迭代器。

[para:complexity]
[:en] Average case linear in [`distance(q1, q2)], worst case [?bigoh[`a.size()]].
[:zh_CN] 平均情况对于 [`distance(q1, q2)] 线性，最差情况为 [?bigoh[`a.size()]]。
[div:end]

[?indexunordmem clear]
[codeblock:declaration]
a.clear()
[codeblock:end]

[div:description]
[para:result] [`:key void]

[para:effects]
[:en] Erases all elements in the container.
[:zh_CN] 清除容器中的所有元素。

[para:ensures]
[:en] [`a.empty()] is [`true].
[:zh_CN] [`a.empty()] 为 [`true]。

[para:complexity]
[:en] Linear in [`a.size()].
[:zh_CN] 对于 [`a.size()] 线性。
[div:end]

[?indexunordmem find]
[codeblock:declaration]
b.find(k)
[codeblock:end]

[div:description]
[para:result]
[:en] [`iterator]; [`const_iterator] for constant [`b].
[:zh_CN] [`iterator]；对于常量 [`b] 为 [`const_iterator]。

[para:returns]
[:en] An iterator pointing to an element with key equivalent to [`k], or
[`b.end()] if no such element exists.
[:zh_CN] 指向其键与 [`k] 等价的元素的迭代器，如果不存在这种元素则返回 [`b.end()]。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a.size()]]。
[div:end]

[?indexunordmem find]
[codeblock:declaration]
a_tran.find(ke)
[codeblock:end]

[div:description]
[para:result]
[:en] [`iterator]; [`const_iterator] for constant [`a_tran].
[:zh_CN] [`iterator]；对于常量 [`a_tran] 为 [`const_iterator]。

[para:returns]
[:en] An iterator pointing to an element with key equivalent to [`ke], or
[`a_tran.end()] if no such element exists.
[:zh_CN] 指向其键与 [`ke] 等价的元素的迭代器，如果不存在这种元素则返回
[`a_tran.end()]。

[para:complexity]
[:en] Average case [?bigoh 1], worst case [?bigoh[`a_tran.size()]].
[:zh_CN] 平均情况为 [?bigoh 1]，最差情况为 [?bigoh[`a_tran.size()]]。
[div:end]

[?indexunordmem count]
[codeblock:declaration]
b.count(k)
[codeblock:end]

[div:description]
[para:result] [`size_type]

[para:returns]
[:en] The number of elements with key equivalent to [`k].
[:zh_CN] 具有等价于 [`k] 的键的元素数量。

[para:complexity]
[:en] Average case [?bigoh[`b.count(k)]], worst case [?bigoh[`b.size()]].
[:zh_CN] 平均情况为 [?bigoh[`b.count(k)]]，最差情况为 [?bigoh[`b.size()]]。
[div:end]

[?indexunordmem count]
[codeblock:declaration]
a_tran.count(ke)
[codeblock:end]

[div:description]
[para:result] [`size_type]

[para:returns]
[:en] The number of elements with key equivalent to [`ke].
[:zh_CN] 具有等价于 [`ke] 的键的元素数量。

[para:complexity]
[:en] Average case [?bigoh[`a_tran.count(ke)]], worst case [?bigoh[`a_tran.size()]].
[:zh_CN] 平均情况为 [?bigoh[`a_tran.count(ke)]]，最差情况为 [?bigoh[`a_tran.size()]]。
[div:end]

[?indexunordmem contains]
[codeblock:declaration]
b.contains(k)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`b.find(k) != b.end()].
[:zh_CN] 等价于 [`b.find(k) != b.end()]。
[div:end]

[?indexunordmem contains]
[codeblock:declaration]
a_tran.contains(ke)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`a_tran.find(ke) != b.end()].
[:zh_CN] 等价于 [`a_tran.find(ke) != b.end()]。
[div:end]

[?indexunordmem equal_range]
[codeblock:declaration]
b.equal_range(k)
[codeblock:end]

[div:description]
[para:result]
[:en] [`pair<iterator, iterator>]; [`pair<const_iterator, const_iterator>]
for constant [`b].
[:zh_CN] [`pair<iterator, iterator>]；对于常量 [`b] 为
[`pair<const_iterator, const_iterator>]。

[para:returns]
[:en] A range containing all elements with keys equivalent to [`k].
[:zh_CN] 一个包含全部具有等价于 [`k] 的键的元素的范围。

[:en] Returns [`make_pair(b.end(), b.end())] if no such elements exist.
[:zh_CN] 如果不存在这种元素则返回 [`make_pair(b.end(), b.end())]。

[para:complexity]
[:en] Average case [?bigoh[`b.count(k)]], worst case [?bigoh[`b.size()]].
[:zh_CN] 平均情况为 [?bigoh[`b.count(k)]]，最差情况为 [?bigoh[`b.size()]]。
[div:end]

[?indexunordmem equal_range]
[codeblock:declaration]
a_tran.equal_range(ke)
[codeblock:end]

[div:description]
[para:result]
[:en] [`pair<iterator, iterator>]; [`pair<const_iterator, const_iterator>]
for constant [`a_tran].
[:zh_CN] [`pair<iterator, iterator>]；对于常量 [`a_tran] 为
[`pair<const_iterator, const_iterator>]。

[para:returns]
[:en] A range containing all elements with keys equivalent to [`ke].
[:zh_CN] 一个包含全部具有等价于 [`ke] 的键的元素的范围。

[:en] Returns [`make_pair(a_tran.end(), a_tran.end())] if no such elements exist.
[:zh_CN] 如果不存在这种元素则返回 [`make_pair(a_tran.end(), a_tran.end())]。

[para:complexity]
[:en] Average case [?bigoh[`a_tran.count(k)]], worst case [?bigoh[`a_tran.size()]].
[:zh_CN] 平均情况为 [?bigoh[`a_tran.count(k)]]，最差情况为 [?bigoh[`a_tran.size()]]。
[div:end]

[?indexunordmem bucket_count]
[codeblock:declaration]
b.bucket_count()
[codeblock:end]

[div:description]
[para:result] [`size_type]

[para:returns]
[:en] The number of buckets that [`b] contains.
[:zh_CN] [`b] 所包含的桶数。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem max_bucket_count]
[codeblock:declaration]
b.max_bucket_count()
[codeblock:end]

[div:description]
[para:result] [`size_type]

[para:returns]
[:en] An upper bound on the number of buckets that [`b] can ever contain.
[:zh_CN] [`b] 可以包含的桶数的上界。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem bucket]
[codeblock:declaration]
b.bucket(k)
[codeblock:end]

[div:description]
[para:result] [`size_type]

[para:expects]
[:en] [`b.bucket_count() > 0].
[:zh_CN] [`b.bucket_count() > 0]。

[para:returns]
[:en] The index of the bucket in which elements with keys equivalent to [`k]
would be found, if any such element existed.
[:zh_CN] 桶的索引，在其中将能找到其键与 [`k] 等价的元素（如果这种元素存在）。

[:en] The return value is in the range [``[0, b.bucket_count())].
[:zh_CN] 返回值处于范围 [``[0, b.bucket_count())] 之内。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem bucket]
[codeblock:declaration]
a_tran.bucket(ke)
[codeblock:end]

[div:description]
[para:result] [`size_type]

[para:expects]
[:en] [`a_tran.bucket_count() > 0].
[:zh_CN] [`a_tran.bucket_count() > 0]。

[para:ensures]
[:en] The return value is in the range [``[0, a_tran.bucket_count())].
[:zh_CN] 返回值处于范围 [``[0, a_tran.bucket_count())] 之内。

[para:returns]
[:en] The index of the bucket in which elements with keys equivalent to [`ke]
would be found, if any such element existed.
[:zh_CN] 桶的索引，在其中将能找到其键与 [`ke] 等价的元素（如果这种元素存在）。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem bucket_size]
[codeblock:declaration]
b.bucket_size(n)
[codeblock:end]

[div:description]
[para:result] [`size_type]

[para:expects]
[:en] [`n] shall be in the range [``[0, b.bucket_count())].
[:zh_CN] [`n] 应当处于范围 [``[0, b.bucket_count())] 之内。

[para:returns]
[:en] The number of elements in the [$n^\text{th}] bucket.
[:zh_CN] 第 [$n] 个桶中的元素数量。

[para:complexity]
[?bigoh[`b.bucket_size(n)]]
[div:end]

[?indexunordmem begin]
[codeblock:declaration]
b.begin(n)
[codeblock:end]

[div:description]
[para:result]
[:en] [`local_iterator]; [`const_local_iterator] for constant [`b].
[:zh_CN] [`local_iterator]；对于常量 [`b] 为 [`const_local_iterator]。

[para:expects]
[:en] [`n] is in the range [``[0, b.bucket_count())].
[:zh_CN] [`n] 处于范围 [``[0, b.bucket_count())] 之内。

[para:returns]
[:en] An iterator referring to the first element in the bucket.
[:zh_CN] 指代这个桶中的第一个元素的迭代器。

[:en] If the bucket is empty, then [`b.begin(n) == b.end(n)].
[:zh_CN] 如果该桶为空，则有 [`b.begin(n) == b.end(n)]。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem end]
[codeblock:declaration]
b.end(n)
[codeblock:end]

[div:description]
[para:result]
[:en] [`local_iterator]; [`const_local_iterator] for constant [`b].
[:zh_CN] [`local_iterator]；对于常量 [`b] 为 [`const_local_iterator]。

[para:expects]
[:en] [`n] is in the range [``[0, b.bucket_count())].
[:zh_CN] [`n] 处于范围 [``[0, b.bucket_count())] 之内。

[para:returns]
[:en] An iterator which is the past-the-end value for the bucket.
[:zh_CN] 这个桶中的越过末尾迭代器。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem cbegin]
[codeblock:declaration]
b.cbegin(n)
[codeblock:end]

[div:description]
[para:result]
[`const_local_iterator]

[para:expects]
[:en] [`n] shall be in the range [``[0, b.bucket_count())].
[:zh_CN] [`n] 应当处于范围 [``[0, b.bucket_count())] 之内。

[para:returns]
[:en] An iterator referring to the first element in the bucket.
[:zh_CN] 指代这个桶中的第一个元素的迭代器。

[:en] If the bucket is empty, then [`b.cbegin(n) == b.cend(n)].
[:zh_CN] 如果该桶为空，则有 [`b.cbegin(n) == b.cend(n)]。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem cend]
[codeblock:declaration]
b.cend(n)
[codeblock:end]

[div:description]
[para:result]
[`const_local_iterator]

[para:expects]
[:en] [`n] is in the range [``[0, b.bucket_count())].
[:zh_CN] [`n] 处于范围 [``[0, b.bucket_count())] 之内。

[para:returns]
[:en] An iterator which is the past-the-end value for the bucket.
[:zh_CN] 这个桶中的越过末尾迭代器。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem load_factor]
[codeblock:declaration]
b.load_factor()
[codeblock:end]

[div:description]
[para:result] [`float]

[para:returns]
[:en] The average number of elements per bucket.
[:zh_CN] 每个桶的平均元素数量。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem max_load_factor]
[codeblock:declaration]
b.max_load_factor()
[codeblock:end]

[div:description]
[para:result] [`float]

[para:returns]
[:en] A positive number that the container attempts to keep the load factor
less than or equal to.
[:zh_CN] 一个正数，该容器试图保持其负载系数小于或等于这个值。

[:en] The container automatically increases the number of buckets as
necessary to keep the load factor below this number.
[:zh_CN] 容器将自动增加桶数，以保持负载系数低于这个数值。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem max_load_factor]
[codeblock:declaration]
a.max_load_factor(z)
[codeblock:end]

[div:description]
[para:result] [`:key void]

[para:expects]
[:en] [`z] is positive.
[:zh_CN] [`z] 为正数。

[:en] May change the container[=']s maximum load factor, using [`z] as a hint.
[:zh_CN] 可能改变容器的最大负载系数，[`z] 被用作一个提示。

[para:complexity]
[:en] Constant.
[:zh_CN] 常量。
[div:end]

[?indexunordmem rehash]
[codeblock:declaration]
a.rehash(n)
[codeblock:end]

[div:description]
[para:result] [`:key void]

[para:ensures]
[:en] [`a.bucket_count() >= a.size() / a.max_load_factor()] and
[`a.bucket_count() >= n].
[:zh_CN] [`a.bucket_count() >= a.size() / a.max_load_factor()] 并且
[`a.bucket_count() >= n]。

[para:complexity]
[:en] Average case linear in [`a.size()], worst case quadratic.
[:zh_CN] 平均情况对于 [`a.size()] 为线性，最差情况为平方阶。
[div:end]

[?indexunordmem reserve]
[codeblock:declaration]
a.reserve(n)
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`a.rehash(ceil(n / a.max_load_factor()))].
[:zh_CN] 等价于 [`a.rehash(ceil(n / a.max_load_factor()))]。
[div:end]

[para]
[:en] Two unordered containers [`a] and [`b] compare equal if
[`a.size() == b.size()] and, for every equivalent-key group [=range(Ea1,Ea2)]
obtained from [`a.equal_range(Ea1)], there exists an equivalent-key group
[=range(Eb1,Eb2)] obtained from [`b.equal_range(Ea1)], such that
[`is_permutation(Ea1, Ea2, Eb1, Eb2)] returns [`true].
[:zh_CN] 两个无序容器 [`a] 和 [`b]，如果 [`a.size() == b.size()]，并且对于以
[`a.equal_range(Ea1)] 获得的每个等价键组 [=range(Ea1,Ea2)]，都存在一个以
[`b.equal_range(Ea1)] 获得的等价键组 [=range(Eb1,Eb2)]，使得
[`is_permutation(Ea1, Ea2, Eb1, Eb2)] 返回 [`true]，则两个容器比较为相等。

[:en] For [`unordered_set] and [`unordered_map], the complexity of [`operator==]
(i.e., the number of calls to the [`==] operator of the [`value_type], to the
predicate returned by [`key_eq()], and to the hasher returned by
[`hash_function()]) is proportional to [$N] in the average case and to [$N^2] in
the worst case, where [$N] is [`a.size()].
[:zh_CN] 对于 [`unordered_set] 和 [`unordered_map]，[`operator==] 的复杂度（亦即
[`value_type] 的 [`==] 运算符的调用次数，[`key_eq()] 所返回的谓词的调用次数，
以及 [`hash_function()] 所返回的散列函数的调用次数），在平均情况下正比于 [$N]，
而在最差情况下正比于 [$N^2]，其中 [$N] 为 [`a.size()]。

[:en] For [`unordered_multiset] and [`unordered_multimap], the complexity of
[`operator==] is proportional to [$\sum E_i^2] in the average case and to [$N^2]
in the worst case, where [$N] is [`a.size()], and [$E_i] is the size of the
[$i^\text{th}] equivalent-key group in [`a].
[:zh_CN] 对于 [`unordered_multiset] 和 [`unordered_multimap]，[`operator==] 的
复杂度在平均情况下正比于 [$\sum E_i^2]，而在最差情况下正比于 [$N^2]，其中 [$N]
为 [`a.size()]，而 [$E_i] 为 [`a] 中的第 [$i] 个等价键组的大小。

[:en] However, if the respective elements of each corresponding pair of
equivalent-key groups [$Ea_i] and [$Eb_i] are arranged in the same order (as is
commonly the case, e.g., if [`a] and [`b] are unmodified copies of the same
container), then the average-case complexity for [`unordered_multiset] and
[`unordered_multimap] becomes proportional to [$N] (but worst-case complexity
remains [?bigoh N^2], e.g., for a pathologically bad hash function).
[:zh_CN] 然而，如果每个对应的等价键组对 [$Ea_i] 和 [$Eb_i] 的各个元素都是以相同
顺序排列的（比如当 [`a] 和 [`b] 都是同一个容器的未改动过的副本时，通常为这种
情况），[`unordered_multiset] 和 [`unordered_multimap] 的平均情况的复杂度将变为
正比于 [$N]（但其最差情况的复杂度仍为 [?bigoh N^2]，比如当具有一个极差的散列函数
时）。

[:en] The behavior of a program that uses [`operator==] or [`operator!=] on
unordered containers is undefined unless the [`Pred] function object has the
same behavior for both containers and the equality comparison function for
[`Key] is a refinement[#:fn] of the partition into equivalent-key groups
produced by [`Pred].
[:zh_CN] 对无序容器使用 [`operator==] 或 [`operator!=] 的程序的行为是未定义的，
除非其 [`Hash] 函数对象对两个容器具有相同的行为，并且 [`Key] 的相等性比较函数是
对由 [`Pred] 所产生的等价键组分区的提炼[#:fn]。

[note:foot]
[:en] Equality comparison is a refinement of partitioning if no two objects that
compare equal fall into different partitions.
[:zh_CN] 如果没有相等的两个对象被分到不同分区，则相等性比较就是对分区的提炼。
[note:end]

[para]
[:en]
[%unordered associative containers[!iterators]]
The iterator types [`iterator] and [`const_iterator] of an unordered associative
container are of at least the forward iterator category.
[:zh_CN]
[%无序关联容器[!迭代器]]
无序关联容器的迭代器类型 [`iterator] 和 [`const_iterator] 至少属于前向迭代器类别。

[:en] For unordered associative containers where the key type and value type are
the same, both [`iterator] and [`const_iterator] are constant iterators.
[:zh_CN] 键类型和值类型相同的无序关联容器的 [`iterator] 和 [`const_iterator]
都是常量迭代器。

[para]
[:en]
[%unordered associative containers[!iterator invalidation]]
The [`insert], [`insert_range], and [`emplace] members shall not affect the
validity of references to container elements, but may invalidate all iterators
to the container.
[:zh_CN]
[%无序关联容器[!迭代器失效]]
[`insert]，[`insert_range]，和 [`emplace] 成员不能影响指代容器元素的引用的有效性，
但可能无效化指代该容器的所有迭代器。

[:en] The [`erase] members shall invalidate only iterators and references to the
erased elements, and preserve the relative order of the elements that are not
erased.
[:zh_CN] [`erase] 成员只能使指代所清除的元素的迭代器和引用，并保持未被清除的元素
之间的相对顺序。

[para]
[:en]
[%unordered associative containers[!iterator invalidation]]
[%unordered associative containers[!requirements]]
The [`insert], [`insert_range], and [`emplace] members shall not affect the
validity of iterators if [`(N+n) <= z * B], where [`N] is the number of elements
in the container prior to the insert operation, [`n] is the number of elements
inserted, [`B] is the container[=']s bucket count, and [`z] is the container[=']s
maximum load factor.
[:zh_CN]
[%无序关联容器[!迭代器失效]]
[%无序关联容器[!规定]]
当 [`(N+n) <= z * B] 时，[`insert]，[`insert_range]，和 [`emplace] 成员不能影响
迭代器的有效性，其中 [`N] 为该容器在插入操作之前的元素数量，[`n] 为所插入元素的
数量，[`B] 为该容器的桶数，而 [`z] 为该容器的最大负载系数。

[para]
[:en] The [`extract] members invalidate only iterators to the removed element,
and preserve the relative order of the elements that are not erased; pointers
and references to the removed element remain valid.
[:zh_CN] 各 [`extract] 成员仅会使被移除的元素的迭代器失效，并保持未被清除的元素
之间的相对顺序；而指代被移除的元素的指针和引用则保持有效。

[:en] However, accessing the element through such pointers and references while
the element is owned by a [`node_type] is undefined behavior.
[:zh_CN] 不过，当元素由 [`node_type] 拥有时，通过这样的指针和引用来访问元素是
未定义的行为。

[:en] References and pointers to an element obtained while it is owned by a
[`node_type] are invalidated if the element is successfully inserted.
[:zh_CN] 当元素被 [`node_type] 所拥有时所获得的引用和指针，在元素被成功插入之后
就失效。

[para]
[:en] The member function templates [`find], [`count], [`equal_range],
[`contains], [`extract], [`erase], and [`bucket] shall not participate in
overload resolution unless the [~qualified-id]s [`Pred::is_transparent] and
[`Hash::is_transparent] are both valid and denote types ([#temp.deduct]).
[:zh_CN] 除非[~限定标识] [`Pred::is_transparent] 和 [`Hash::is_transparent] 均
有效且代表类型（[#temp.deduct]），否则成员函数模板 [`find]、[`count]、
[`equal_range]、[`contains]、[`extract]、[`erase] 和 [`bucket] 不能参与重载决议。

[:en] Additionally, the member function templates [`extract] and [`erase]
shall not participate in overload resolution if
[`is_convertible_v<K&&, iterator> || is_convertible_v<K&&, const_iterator>]
is [`true], where [`K] is the type substituted as the first template argument.
[:zh_CN] 此外，成员函数模板 [`extract] 和 [`erase]，当
[`is_convertible_v<K&&, iterator> || is_convertible_v<K&&, const_iterator>] 为
[`true] 时不能参与重载决议，其中 [`K] 是作为第一个模板实参进行代换的类型。

[para]
[:en] A deduction guide for an unordered associative container shall not
participate in overload resolution if any of the following are true:
[:zh_CN] 无序关联容器的推断导引，当以下有任意一项为真时不能参与重载决议：

[list]
[item]
[:en] It has an [`InputIterator] template parameter and a type that does not
qualify as an input iterator is deduced for that parameter.
[:zh_CN] 它具有一个 [`InputIterator] 模板形参，而为该形参所推断的类型无法作为
输入迭代器。

[item]
[:en] It has an [`Allocator] template parameter and a type that does not qualify
as an allocator is deduced for that parameter.
[:zh_CN] 它具有一个 [`Allocator] 模板形参，而为该形参所推断的类型无法作为分配器。

[item]
[:en] It has a [`Hash] template parameter and an integral type or a type that
qualifies as an allocator is deduced for that parameter.
[:zh_CN] 它具有一个 [`Hash] 模板形参，而为该形参所推断的类型为整型类型或者为可以
作为分配器的类型。

[item]
[:en] It has a [`Pred] template parameter and a type that qualifies as an
allocator is deduced for that parameter.
[:zh_CN] 它具有一个 [`Pred] 模板形参，而为该形参所推断的类型可以作为分配器。
[list:end]
