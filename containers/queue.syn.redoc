[section#queue.syn
    [:en] Header [`<queue>] synopsis
    [:zh_CN] 头文件 [`<queue>] 纲要
]

[%@hdr@def queue]

[codeblock:synopsis]
#include <compare>              // [:en] see [#compare.syn] \
                                [:zh_CN] 参见 [#compare.syn]
#include <initializer_list>     // [:en] see [#initializer.list.syn] \
                                [:zh_CN] 参见 [#initializer.list.syn]

namespace std {
  // [:en] [#queue], class template [`queue] \
  [:zh_CN] [#queue]，类模板 [`queue]
  template<class T, class Container = deque<T>> class queue;

  template<class T, class Container>
    bool operator==(const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, class Container>
    bool operator!=(const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, class Container>
    bool operator< (const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, class Container>
    bool operator> (const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, class Container>
    bool operator<=(const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, class Container>
    bool operator>=(const queue<T, Container>& x, const queue<T, Container>& y);
  template<class T, [[redoc("`:c>")]]three_way_comparable Container>
    compare_three_way_result_t<Container>
      operator<=>(const queue<T, Container>& x, const queue<T, Container>& y);

  template<class T, class Container>
    void swap(queue<T, Container>& x, queue<T, Container>& y) noexcept(noexcept(x.swap(y)));
  template<class T, class Container, class Alloc>
    struct uses_allocator<queue<T, Container>, Alloc>;

  // [:en] [#priority.queue], class template [`priority_queue] \
  [:zh_CN] [#priority.queue]，类模板 [`priority_queue]
  template<class T, class Container = vector<T>,
           class Compare = less<typename Container::value_type>>
    class priority_queue;

  template<class T, class Container, class Compare>
    void swap(priority_queue<T, Container, Compare>& x,
              priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));
  template<class T, class Container, class Compare, class Alloc>
    struct uses_allocator<priority_queue<T, Container, Compare>, Alloc>;
}
[codeblock:end]
