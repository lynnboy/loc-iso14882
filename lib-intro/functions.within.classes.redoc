[section#functions.within.classes
    [:en] Functions within classes
    [:zh_CN] 类中的函数
]

[para]
[:en]
[%constructor[!copy]]
[%operator[!assignment]]
[%destructor]
For the sake of exposition, Clauses [#language.support] through [#thread] and
Annex [#depr] do not describe copy/move constructors, assignment operators, or
(non-virtual) destructors with the same apparent semantics as those that can be
generated by default ([#class.ctor], [#class.dtor], [#class.copy]).
[:zh_CN]
[%构造函数[!复制～]]
[%运算符[!赋值～]]
[%析构函数]
为便于阐述，第 [#language.support] 到第 [#thread] 章以及附录 [#depr] 并不描述
那些与可以在默认情况下生成的函数具有相同语义表现的复制/移动构造函数、赋值运算符
或（非虚）析构函数（[#class.ctor]，[#class.dtor]，[#class.copy]）。

[para]
[:en]
It is unspecified whether the implementation provides explicit definitions for
such member function signatures, or for virtual destructors that can be
generated by default.
[:zh_CN]
实现是否为这些成员函数签名，或者为可以被默认生成的虚析构函数提供显式定义式是
未指明的。

[para]
[:en]
For the sake of exposition, the library clauses sometimes annotate constructors
with [`[*EXPLICIT]].
[:zh_CN]
为便于阐述，程序库章节中有时会为构造函数标记为 [`[*EXPLICIT]]。

[:en]
Such a constructor is conditionally declared as either explicit or non-explicit
([#class.conv.ctor]).
[:zh_CN]
这样的构造函数根据条件被声明为显式的或者非显式的（[#class.conv.ctor]）。

[enter:note]
[:en]
This is typically implemented by declaring two such constructors, of which at
most one participates in overload resolution.
[:zh_CN]
这通常是以声明两个构造函数，而让其中最多一个能够参与重载决议的方式实现的。
[exit:note]
