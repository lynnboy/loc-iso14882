[section#util.smartptr.shared.cast
    [:en] [`shared_ptr] casts
    [:zh_CN] [`shared_ptr] 的强制转换
]

[%@library shared_ptr[!static_pointer_cast]]
[%@library static_pointer_cast[!shared_ptr]]
[codeblock:declaration]
template<class T, class U>
  shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
[codeblock:end]

[enter:description]
[para:requires]
[:en] The expression [`static_cast<T*>((U*)0)] shall be well formed.
[:zh_CN] 表达式 [`static_cast<T*>((U*)0)] 应当是良构的。

[para:returns]
[codeblock:notation]
shared_ptr<T>(r, static_cast<typename shared_ptr<T>::element_type*>(r.get()))
[codeblock:end]

[para]
[enter:note]
[:en] The seemingly equivalent expression
[`shared_ptr<T>(static_cast<T*>(r.get()))] will eventually result in undefined
behavior, attempting to delete the same object twice.
[:zh_CN] 看起来等价的表达式 [`shared_ptr<T>(static_cast<T*>(r.get()))] 最终将
导致未定义行为，因为其试图两次删除相同的对象。
[exit:note]
[exit:description]

[%@library shared_ptr[!dynamic_pointer_cast]]
[%@library dynamic_pointer_cast[!shared_ptr]]
[codeblock:declaration]
template<class T, class U>
  shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
[codeblock:end]

[enter:description]
[para:requires]
[:en] The expression [`dynamic_cast<T*>((U*)0)] shall be well formed and shall
have well defined behavior.
[:zh_CN] 表达式 [`dynamic_cast<T*>((U*)0)] 应当是良构的，且应当具有良构的行为。

[para:returns]
[list]
[item]
[:en] When [`dynamic_cast<typename shared_ptr<T>::element_type*>(r.get())]
returns a nonzero value [`p], a [`shared_ptr<T>(r, p)].
[:zh_CN] 当 [`dynamic_cast<typename shared_ptr<T>::element_type*>(r.get())] 返回
非零值 [`p] 时返回 [`shared_ptr<T>(r, p)]。

[item]
[:en] Otherwise, [`shared_ptr<T>()].
[:zh_CN] 否则，返回 [`shared_ptr<T>]。
[list:end]

[para]
[enter:note]
[:en] The seemingly equivalent expression
[`shared_ptr<T>(dynamic_cast<T*>(r.get()))] will eventually result in undefined
behavior, attempting to delete the same object twice.
[:zh_CN] 看起来等价的表达式 [`shared_ptr<T>(dynamic_cast<T*>(r.get()))] 最终将
导致未定义行为，因为其试图两次删除相同的对象。
[exit:note]
[exit:description]

[%@library shared_ptr[!const_pointer_cast]]
[%@library const_pointer_cast[!shared_ptr]]
[codeblock:declaration]
template<class T, class U>
  shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
[codeblock:end]

[enter:description]
[para:requires]
[:en] The expression [`const_cast<T*>((U*)0)] shall be well formed.
[:zh_CN] 表达式 [`const_cast<T*>((U*)0)] 应当是良构的。

[para:returns]
[codeblock:notation]
shared_ptr<T>(r, const_cast<typename shared_ptr<T>::element_type*>(r.get()))
[codeblock:end]

[para]
[enter:note]
[:en] The seemingly equivalent expression
[`shared_ptr<T>(const_cast<T*>(r.get()))] will eventually result in undefined
behavior, attempting to delete the same object twice.
[:zh_CN] 看起来等价的表达式 [`shared_ptr<T>(const_cast<T*>(r.get()))] 最终将
导致未定义行为，因为其试图两次删除相同的对象。
[exit:note]
[exit:description]

[%@library shared_ptr[!reinterpret_pointer_cast]]
[%@library reinterpret_pointer_cast[!shared_ptr]]
[codeblock:declaration]
template<class T, class U>
  shared_ptr<T> reinterpret_pointer_cast(const shared_ptr<U>& r) noexcept;
[codeblock:end]

[enter:description]
[para:requires]
[:en] The expression [`reinterpret_cast<T*>((U*)0)] shall be well formed.
[:zh_CN] 表达式 [`reinterpret_cast<T*>((U*)0)] 应当是良构的。

[para:returns]
[codeblock]
shared_ptr<T>(r, reinterpret_cast<typename shared_ptr<T>::element_type*>(r.get()))
[codeblock:end]

[para]
[enter:note]
[:en] The seemingly equivalent expression
[`shared_ptr<T>(reinterpret_cast<T*>(r.get()))] will eventually result in
undefined behavior, attempting to delete the same object twice.
[:zh_CN] 看起来等价的表达式 [`shared_ptr<T>(reinterpret_cast<T*>(r.get()))] 最终
将导致未定义行为，因为其试图两次删除相同的对象。
[exit:note]
[exit:description]
