[section#pairs.spec
    [:en] Specialized algorithms
    [:zh_CN] 特化的算法
]

[%@library operator==[!pair]]
[%@library pair[!operator==]]
[codeblock:declaration]
template<class T1, class T2>
  constexpr bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.first == y.first && x.second == y.second].
[:zh_CN] [`x.first == y.first && x.second == y.second]。
[exit:description]

[%@library operator<[!pair]]
[%@library pair[!operator<]]
[codeblock:declaration]
template<class T1, class T2>
  constexpr bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.first < y.first || (!(y.first < x.first) && x.second < y.second)].
[:zh_CN] [`x.first < y.first || (!(y.first < x.first) && x.second < y.second)]。
[exit:description]

[%@library operator!=[!pair]]
[%@library pair[!operator!=]]
[codeblock:declaration]
template<class T1, class T2>
  constexpr bool operator!=(const pair<T1, T2>& x, const pair<T1, T2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`!(x == y)].
[:zh_CN] [`!(x == y)]。
[exit:description]

[%@library operator>[!pair]]
[%@library pair[!operator>]]
[codeblock:declaration]
template<class T1, class T2>
  constexpr bool operator>(const pair<T1, T2>& x, const pair<T1, T2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`y < x].
[:zh_CN] [`y < x]。
[exit:description]

[%@library operator>=[!pair]]
[%@library pair[!operator>=]]
[codeblock:declaration]
template<class T1, class T2>
  constexpr bool operator>=(const pair<T1, T2>& x, const pair<T1, T2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`!(x < y)].
[:zh_CN] [`!(x < y)]。
[exit:description]

[%@library operator<=[!pair]]
[%@library pair[!operator<=]]
[codeblock:declaration]
template<class T1, class T2>
  constexpr bool operator<=(const pair<T1, T2>& x, const pair<T1, T2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`!(y < x)].
[:zh_CN] [`!(y < x)]。
[exit:description]

[%@library swap[!pair]]
[%@library pair[!swap]]
[codeblock:declaration]
template<class T1, class T2>
  void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[:en] As if by [`x.swap(y)].
[:zh_CN] 如同执行 [`x.swap(y)]。

[para:remarks]
[:en] This function shall not participate in overload resolution unless
[`is_swappable_v<T1>] is [`true] and [`is_swappable_v<T2>] is [`true].
[:zh_CN] 除非 [`is_swappable_v<T1>] 为 [`true] 并且 [`is_swappable_v<T2>] 为
[`true]，否则这个函数不能参与重载决议。
[exit:description]

[%@library make_pair]
[codeblock:declaration]
template<class T1, class T2>
  constexpr pair<V1, V2> make_pair(T1&& x, T2&& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`pair<V1, V2>(std::forward<T1>(x), std::forward<T2>(y))], where [`V1] and
[`V2] are determined as follows:
[:zh_CN] [`pair<V1, V2>(std::forward<T1>(x), std::forward<T2>(y))]，其中的 [`V1]
和 [`V2] 以如下方式确定：

[:en] Let [`Ui] be [`decay_t<Ti>] for each [`Ti].
[:zh_CN] 对于每个 [`Ti]，令 [`Ui] 为 [`decay_t<Ti>]。

[:en]
If [`Ui] is a specialization of [`reference_wrapper], then [`Vi] is
[`Ui::type&], otherwise [`Vi] is [`Ui].
[:zh_CN]
当 [`Ui] 为 [`reference_wrapper] 的特例时 [`Vi] 为 [`Ui::type&]，否则 [`Vi] 为
[`Ui]。
[exit:description]

[para]
[enter:example]
[:en]
In place of:
[:zh_CN]
当使用

[codeblock]
  return pair<int, double>(5, 3.1415926);   // [:en] explicit types
                                            // [|:zh_CN] 明确的类型
[codeblock:end]

[:en@~]
a [=Cpp] program may contain:
[:zh_CN@~]
时，[=Cpp] 程序可以代之以

[codeblock]
  return make_pair(5, 3.1415926);           // [:en] types are deduced
                                            // [|:zh_CN] 类型被推断
[codeblock:end]
[exit:example]
