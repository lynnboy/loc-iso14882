[section#func.bind.place
    [:en] Placeholders
    [:zh_CN] 占位符
]

[%@lib placeholders]
[%@lib@raw [`_1][@1]]
[codeblock:synopsis]
namespace std::placeholders {
  // [:en] M is the [?impldef number of placeholders for bind expressions] number of placeholders \
  [:zh_CN] M 为[?impldef bind 表达式中的占位符的数量]占位符的数量
  [[redoc("[=seebelow]")]] _1;
  [[redoc("[=seebelow]")]] _2;
              .
              .
              .
  [[redoc("[=seebelow]")]] _M;
}
[codeblock:end]

[para]
[:en]
All placeholder types meet [^:oc DefaultConstructible] and
[^:oc CopyConstructible] requirements, and their default constructors and
copy/move constructors are constexpr functions that do not throw exceptions.
[:zh_CN]
所有占位符类型均满足 [^:oc DefaultConstructible] 和 [^:oc CopyConstructible]
的规定，并且它们的默认构造函数和复制/移动构造函数均为不抛出任何异常的 constexpr
函数。

[:en]
It is [?impldef assignability of placeholder objects] whether placeholder types
meet the [^:oc CopyAssignable] requirements, but if so, their copy assignment
operators are constexpr functions that do not throw exceptions.
[:zh_CN]
占位符类型是否满足 [^:oc CopyAssignable] 的规定是[?impldef 占位符对象的可赋值性]，
但当如此时，它们的复制赋值运算符均为不抛出任何异常的 constexpr 函数。

[para]
[:en] Placeholders should be defined as:
[:zh_CN] 占位符应当定义如下：

[codeblock]
inline constexpr [[redoc("[=unspec]")]] _1{};
[codeblock:end]

[:en] If they are not, they are declared as:
[:zh_CN] 如果不是这样，则它们被声明为：

[codeblock]
extern [[redoc("[=unspec]")]] _1;
[codeblock:end]
