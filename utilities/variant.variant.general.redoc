[section#variant.variant.general
    [:en] General
    [:zh_CN] 概述
]

[codeblock:synopsis]
namespace std {
  template<class... Types>
  class variant {
  public:
    // [:en] [#variant.ctor], constructors \
    [:zh_CN] [#variant.ctor]，构造函数
    constexpr variant() noexcept([[redoc("[=seebelow]")]]);
    constexpr variant(const variant&);
    constexpr variant(variant&&) noexcept([[redoc("[=seebelow]")]]);

    template<class T>
      constexpr variant(T&&) noexcept([[redoc("[=seebelow]")]]);

    template<class T, class... Args>
      constexpr explicit variant(in_place_type_t<T>, Args&&...);
    template<class T, class U, class... Args>
      constexpr explicit variant(in_place_type_t<T>, initializer_list<U>, Args&&...);

    template<size_t I, class... Args>
      constexpr explicit variant(in_place_index_t<I>, Args&&...);
    template<size_t I, class U, class... Args>
      constexpr explicit variant(in_place_index_t<I>, initializer_list<U>, Args&&...);

    // [:en] [#variant.dtor], destructor \
    [:zh_CN] [#variant.dtor]，析构函数
    constexpr ~variant();

    // [:en] [#variant.assign], assignment \
    [:zh_CN] [#variant.assign]，赋值
    constexpr variant& operator=(const variant&);
    constexpr variant& operator=(variant&&) noexcept([[redoc("[=seebelow]")]]);

    template<class T> constexpr variant& operator=(T&&) noexcept([[redoc("[=seebelow]")]]);

    // [:en] [#variant.mod], modifiers \
    [:zh_CN] [#variant.mod]，改动函数
    template<class T, class... Args>
      constexpr T& emplace(Args&&...);
    template<class T, class U, class... Args>
      constexpr T& emplace(initializer_list<U>, Args&&...);
    template<size_t I, class... Args>
      constexpr variant_alternative_t<I, variant<Types...>>& emplace(Args&&...);
    template<size_t I, class U, class... Args>
      constexpr variant_alternative_t<I, variant<Types...>>&
        emplace(initializer_list<U>, Args&&...);

    // [:en] [#variant.status], value status \
    [:zh_CN] [#variant.status]，值的状态
    constexpr bool valueless_by_exception() const noexcept;
    constexpr size_t index() const noexcept;

    // [:en] [#variant.swap], swap \
    [:zh_CN] [#variant.swap]，交换
    constexpr void swap(variant&) noexcept([[redoc("[=seebelow]")]]);
  };
}
[codeblock:end]

[para]
[:en]
Any instance of [`variant] at any given time either holds a value of one of its
alternative types or holds no value.
[:zh_CN]
[`variant] 的任何实例在任意给定时刻，或者持有一个其候选类型之一的值，或者不持有值。

[:en]
When an instance of [`variant] holds a value of alternative type [`T], it means
that a value of type [`T], referred to as the [`variant] object[=']s
[+contained value[%contained value[![`variant]]]], is allocated within the
storage of the [`variant] object.
[:zh_CN]
当 [`variant] 的一个实例持有候选类型 [`T] 的值时，意味着一个 [`T] 类型的值, 
被分配在该 [`variant] 对象的存储之内，它被称之为该 [`variant] 对象所[+包含的值
[%包含的值[![`variant]]]]。

[:en]
Implementations are not permitted to use additional storage, such as dynamic
memory, to allocate the contained value.
[:zh_CN]
不允许实现利用诸如动态内存这样的其他存储来分配其所包含的值。

[:en]
The contained value shall be allocated in a region of the [`variant] storage
suitably aligned for all types in [`Types].
[:zh_CN]
[`variant] 所包含的值应当分配于其存储中为 [`Types] 中的所有类型适当对齐的一个
区域中。

[para]
[:en]
All types in [`Types] shall meet the [^:oc Destructible] requirements
([#:tab#cpp17.destructible]).
[:zh_CN]
[`Types] 中的所有类型均应当满足 [^:oc Destructible] 的规定
（[#:tab#cpp17.destructible]）。

[para]
[:en]
A program that instantiates the definition of [`variant] with
no template arguments is ill-formed.
[:zh_CN]
不用任何模板实参而实例化 [`variant] 的定义式的程序是非良构的。
