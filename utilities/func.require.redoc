[section#func.require
    [:en] Requirements
    [:zh_CN] 规定
]

[para]
[%@library [*INVOKE]]
[:en]
Define [`[*INVOKE](f, t1, t2, ..., tN)] as follows:
[:zh_CN]
定义 [`[*INVOKE](f, t1, t2, ..., tN)] 如下：

[list]
[item]
[:en] [`(t1.*f)(t2, ..., tN)] when [`f] is a pointer to a member function of a
class [`T] and [`is_base_of_v<T, decay_t<decltype(t1)>>] is [`true];
[:zh_CN] 当 [`f] 为指向类 [`T] 的成员函数的指针，并且
[`is_base_of_v<T, decay_t<decltype(t1)>>] 为 [`true] 时，为
[`(t1.*f)(t2, ..., tN)]；

[item]
[:en] [`(t1.get().*f)(t2, ..., tN)] when [`f] is a pointer to a member function
of a class [`T] and [`decay_t<decltype(t1)>] is a specialization of
[`reference_wrapper];
[:zh_CN] 当 [`f] 为指向类 [`T] 的成员函数的指针，并且 [`decay_t<decltype(t1)>]
是 [`reference_wrapper] 的某个特例时，为 [`(t1.get().*f)(t2, ..., tN)]；

[item]
[:en] [`((*t1).*f)(t2, ..., tN)] when [`f] is a pointer to a member function of
a class [`T] and [`t1] does not satisfy the previous two items;
[:zh_CN] 当 [`f] 为指向类 [`T] 的成员函数的指针，并且 [`t1] 并不符合以上两条时，
为 [`((*t1).*f)(t2, ..., tN)]；

[item]
[:en] [`t1.*f] when [`N == 1] and [`f] is a pointer to data member of a class
[`T] and [`is_base_of_v<T, decay_t<decltype(t1)>>] is [`true];
[:zh_CN] 当 [`N == 1] 且 [`f] 为指向类 [`T] 的数据成员的指针，并且
[`is_base_of_v<T, decay_t<decltype(t1)>>] 为 [`true] 时，为 [`t1.*f]；

[item]
[:em] [`t1.get().*f] when [`N == 1] and [`f] is a pointer to data member of a
class [`T] and [`decay_t<decltype(t1)>] is a specialization of
[`reference_wrapper];
[:zh_CN] 当 [`N == 1] 且 [`f] 为指向类 [`T] 的数据成员的指针，并且
[`decay_t<decltype(t1)>] 是 [`reference_wrapper] 的某个特例时，为
[`t1.get().*f]；

[item]
[:en] [`(*t1).*f] when [`N == 1] and [`f] is a pointer to data member of a class
[`T] and [`t1] does not satisfy the previous two items;
[:zh_CN] 当 [`N == 1] 且 [`f] 为指向类 [`T] 的数据成员的指针，并且 [`t1] 并不
符合以上两条时，为 [`(*t1).*f]；

[item]
[:en] [`f(t1, t2, ..., tN)] in all other cases.
[:zh_CN] 在所有其他情况下为 [`f(t1, t2, ..., tN)]。
[list:end]

[para]
[%@library [*INVOKE]]
[:en]
Define [`[*INVOKE]<R>(f, t1, t2, ..., tN)] as
[`static_cast<void>([*INVOKE](f, t1, t2, ..., tN))] if [`R] is [$cv] [`void],
otherwise [`[*INVOKE](f, t1, t2, ..., tN)] implicitly converted to [`R].
[:zh_CN]
定义 [`[*INVOKE]<R>(f, t1, t2, ..., tN)] 为，当 [`R] 为 [$cv] [`void] 时为
[`static_cast<void>([*INVOKE](f, t1, t2, ..., tN))]，否则为
[`[*INVOKE](f, t1, t2, ..., tN)] 并隐式转换为 [`R]。

[para]
[:en]
[%call wrapper]
[%call wrapper[!simple]]
[%call wrapper[!forwarding]]
[%simple call wrapper]
[%forwarding call wrapper]
Every call wrapper ([#func.def]) shall be [`MoveConstructible].
[:zh_CN]
[%调用包装器]
[%调用包装器[!简单～]]
[%调用包装器[!转发～]]
[%简单调用包装器]
[%转发调用包装器]
每个调用包装器（[#func.def]）均应为 [`MoveConstructible]。

[:en]
A [+forwarding call wrapper[%]] is a call wrapper that can be called with an
arbitrary argument list and delivers the arguments to the wrapped callable
object as references.
[:zh_CN]
[+转发调用包装器[%]]是可以用任意实参列表调用，并将其实参以引用递交给所包装的
可调用对象的调用包装器。

[:en]
This forwarding step shall ensure that rvalue arguments are delivered as rvalue
references and lvalue arguments are delivered as lvalue references.
[:zh_CN]
转发步骤中应当确保右值实参以右值引用递交而左值实参以左值引用递交。

[:en]
A [+simple call wrapper[%]] is a forwarding call wrapper that is
[`CopyConstructible] and [`CopyAssignable] and whose copy constructor, move
constructor, and assignment operator do not throw exceptions.
[:zh_CN]
[+简单调用包装器[%]]是 [`CopyConstructible] 且 [`CopyAssignable] 的转发调用
包装器，且其复制构造函数、移动构造函数和赋值运算符并不抛出异常。

[enter:note]
[:en]
In a typical implementation forwarding call wrappers have an overloaded function
call operator of the form
[:zh_CN]
在典型实现中转发调用包装器具有如下形式的重载函数调用运算符

[codeblock:notation [!:var cv-qual] ]
template<class... UnBoundArgs>
R operator()(UnBoundArgs&&... unbound_args) [*cv-qual];
[codeblock:end]
[exit:note]
