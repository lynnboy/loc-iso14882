[section#func.require
    [:en] Requirements
    [:zh_CN] 规定
]

[para]
[%@library [*INVOKE]]
[:en]
Define [`[*INVOKE](f, t[$_1], t[$_2], [$\dotsc], t[$_N])] as follows:
[:zh_CN]
定义 [`[*INVOKE](f, t[$_1], t[$_2], [$\dotsc], t[$_N])] 如下：

[list]
[item]
[:en] [`(t[$_1].*f)(t[$_2], [$\dotsc], t[$_N])] when [`f] is a pointer to a
member function of a class [`T] and
[`is_base_of_v<T, remove_reference_t<decltype(t[$_1])>>] is [`true];
[:zh_CN] 当 [`f] 为指向类 [`T] 的成员函数的指针，并且
[`is_base_of_v<T, remove_reference_t<decltype(t[$_1])>>] 为 [`true] 时，为
[`(t[$_1].*f)(t[$_2], [$\dotsc], t[$_N])]；

[item]
[:en] [`(t[$_1].get().*f)(t[$_2], [$\dotsc], t[$_N])] when [`f] is a pointer to
a member function of a class [`T] and [`remove_reference_t<decltype(t[$_1])>] is
a specialization of [`reference_wrapper];
[:zh_CN] 当 [`f] 为指向类 [`T] 的成员函数的指针，并且
[`remove_reference_t<decltype(t[$_1])>] 是 [`reference_wrapper] 的某个特例时，为
[`(t[$_1].get().*f)(t[$_2], [$\dotsc], t[$_N])]；

[item]
[:en] [`((*t[$_1]).*f)(t[$_2], [$\dotsc], t[$_N])] when [`f] is a pointer to a
member function of a class [`T] and [`t[$_1]] does not satisfy the previous two
items;
[:zh_CN] 当 [`f] 为指向类 [`T] 的成员函数的指针，并且 [`t[$_1]] 并不符合以上两条
时，为 [`((*t[$_1]).*f)(t[$_2], [$\dotsc], t[$_N])]；

[item]
[:en] [`t[$_1].*f] when [`N == 1] and [`f] is a pointer to data member of a
class [`T] and [`is_base_of_v<T, remove_reference_t<decltype(t[$_1])>>] is
[`true];
[:zh_CN] 当 [`N == 1] 且 [`f] 为指向类 [`T] 的数据成员的指针，并且
[`is_base_of_v<T, remove_reference_t<decltype(t[$_1])>>] 为 [`true] 时，为
[`t[$_1].*f]；

[item]
[:em] [`t[$_1].get().*f] when [`N == 1] and [`f] is a pointer to data member of
a class [`T] and [`remove_reference_t<decltype(t[$_1])>] is a specialization of
[`reference_wrapper];
[:zh_CN] 当 [`N == 1] 且 [`f] 为指向类 [`T] 的数据成员的指针，并且
[`remove_reference_t<decltype(t[$_1])>] 是 [`reference_wrapper] 的某个特例时，为
[`t[$_1].get().*f]；

[item]
[:en] [`(*t[$_1]).*f] when [`N == 1] and [`f] is a pointer to data member of a
class [`T] and [`t[$_1]] does not satisfy the previous two items;
[:zh_CN] 当 [`N == 1] 且 [`f] 为指向类 [`T] 的数据成员的指针，并且 [`t[$_1]]
并不符合以上两条时，为 [`(*t[$_1]).*f]；

[item]
[:en] [`f(t[$_1], t[$_2], [$\dotsc], t[$_N])] in all other cases.
[:zh_CN] 在所有其他情况下为 [`f(t[$_1], t[$_2], [$\dotsc], t[$_N])]。
[list:end]

[para]
[%@library [*INVOKE]]
[:en]
Define [`[*INVOKE]<R>(f, t[$_1], t[$_2], [$\dotsc], t[$_N])] as
[`static_cast<void>([*INVOKE](f, t[$_1], t[$_2], [$\dotsc], t[$_N]))] if [`R] is
[$cv] [`void], otherwise [`[*INVOKE](f, t[$_1], t[$_2], [$\dotsc], t[$_N])]
implicitly converted to [`R].
[:zh_CN]
定义 [`[*INVOKE]<R>(f, t[$_1], t[$_2], [$\dotsc], t[$_N])] 为，当 [`R] 为
[$cv] [`void] 时为
[`static_cast<void>([*INVOKE](f, t[$_1], t[$_2], [$\dotsc], t[$_N]))]，否则为
[`[*INVOKE](f, t[$_1], t[$_2], [$\dotsc], t[$_N])] 并隐式转换为 [`R]。

[para]
[:en]
[%call wrapper]
[%call wrapper[!simple]]
[%call wrapper[!forwarding]]
Every call wrapper ([#func.def]) shall be [`MoveConstructible].
[:zh_CN]
[%调用包装器]
[%调用包装器[!简单～]]
[%调用包装器[!转发～]]
每个调用包装器（[#func.def]）均应为 [`MoveConstructible]。

[:en]
A [+forwarding call wrapper[%forwarding call wrapper]] is a call wrapper that
can be called with an arbitrary argument list and delivers the arguments to the
wrapped callable object as references.
[:zh_CN]
[+转发调用包装器[%转发调用包装器]]是可以用任意实参列表调用，并将其实参以引用递交
给所包装的可调用对象的调用包装器。

[:en]
This forwarding step shall ensure that rvalue arguments are delivered as rvalue
references and lvalue arguments are delivered as lvalue references.
[:zh_CN]
转发步骤中应当确保右值实参以右值引用递交而左值实参以左值引用递交。

[:en]
A [+simple call wrapper[%simple call wrapper]] is a forwarding call wrapper that
is [`CopyConstructible] and [`CopyAssignable] and whose copy constructor, move
constructor, copy assignment operator, and move assignment operator do not throw
exceptions.
[:zh_CN]
[+简单调用包装器[%简单调用包装器]]是 [`CopyConstructible] 且 [`CopyAssignable]
的转发调用包装器，且其复制构造函数、移动构造函数、复制赋值运算符和移动赋值运算符
并不抛出异常。

[enter:note]
[:en]
In a typical implementation forwarding call wrappers have an overloaded function
call operator of the form
[:zh_CN]
在典型实现中转发调用包装器具有如下形式的重载函数调用运算符

[codeblock:notation [!:var cv-qual] ]
template<class... UnBoundArgs>
  R operator()(UnBoundArgs&&... unbound_args) [*cv-qual];
[codeblock:end]
[exit:note]
