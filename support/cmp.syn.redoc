[section#cmp.syn
    [:en] Header [`<compare>] synopsis
    [:zh_CN] 头文件 [`<compare>] 纲要
]

[para]
[:en]
The header [`<compare>] specifies types, objects, and functions for use
primarily in connection with the three-way comparison operator
([#expr.spaceship]).
[:zh_CN]
头文件 [`<compare>] 指定了一些类型、对象和函数，主要用于和三路比较运算符结合
使用（[#expr.spaceship]）。

[%@header compare]
[%@library is_eq]
[%@library is_neq]
[%@library is_lt]
[%@library is_lteq]
[%@library is_gt]
[%@library is_geq]
[%@library is_gteq]
[%@library common_comparison_category_t]
[codeblock:synopsis [!:mark SeeBelow] ]
namespace std {
  // [:en] [#cmp.categories], comparison category types
  // [|:zh_CN] [#cmp.categories]，比较类别类型
  class weak_equality;
  class strong_equality;
  class partial_ordering;
  class weak_ordering;
  class strong_ordering;

  // [:en] named comparison functions
  // [|:zh_CN] 具名比较函数
  constexpr bool is_eq  (weak_equality cmp) noexcept    { return cmp == 0; }
  constexpr bool is_neq (weak_equality cmp) noexcept    { return cmp != 0; }
  constexpr bool is_lt  (partial_ordering cmp) noexcept { return cmp < 0; }
  constexpr bool is_lteq(partial_ordering cmp) noexcept { return cmp <= 0; }
  constexpr bool is_gt  (partial_ordering cmp) noexcept { return cmp > 0; }
  constexpr bool is_gteq(partial_ordering cmp) noexcept { return cmp >= 0; }

  // [:en] [#cmp.common], common comparison category type
  // [|:zh_CN] [#cmp.common]，一般比较类别类型
  template<class... Ts>
  struct common_comparison_category {
    using type = [=SeeBelow];
  };
  template<class... Ts>
    using common_comparison_category_t = typename common_comparison_category<Ts...>::type;

  // [:en] [#cmp.alg], comparison algorithms
  // [|:zh_CN] [#cmp.alg]，比较算法
  template<class T> constexpr strong_ordering strong_order(const T& a, const T& b);
  template<class T> constexpr weak_ordering weak_order(const T& a, const T& b);
  template<class T> constexpr partial_ordering partial_order(const T& a, const T& b);
  template<class T> constexpr strong_equality strong_equal(const T& a, const T& b);
  template<class T> constexpr weak_equality weak_equal(const T& a, const T& b);
}
[codeblock:end]
