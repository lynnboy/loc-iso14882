[section#temp.param
    [:en] Template parameters
    [:zh_CN] 模板形参
]

[para]
[:en]
The syntax for [~template-parameter]s is:
[:zh_CN]
[~模板形参]的语法是：

[syntax]
[rule template-parameter [:zh_CN] 模板形参 ]
    [| type-parameter ]
    [| parameter-declaration ]
    [| constrained-parameter ]
[rule:end]

[rule type-parameter [:zh_CN] 类型形参 ]
    [| type-parameter-key [`:opt ...] [~:opt identifier] ]
    [| type-parameter-key [~:opt identifier] [`=] type-id ]
    [| [`template] [`<] template-parameter-list [`>] type-parameter-key [`:opt ...] [~:opt identifier] ]
    [| [`template] [`<] template-parameter-list [`>] type-parameter-key [~:opt identifier] [`=] id-expression ]
[rule:end]

[rule type-parameter-key [:zh_CN] 类型形参关键字 ]
    [| [`class] ]
    [| [`typename] ]
[rule:end]

[rule constrained-parameter [:zh_CN] 受约束形参 ]
    [| qualified-concept-name [`...] [~:opt identifier] ]
    [| qualified-concept-name [~:opt identifier] [~:opt default-template-argument] ]
[rule:end]

[rule qualified-concept-name [:zh_CN] 限定概念名 ]
    [| [~:opt nested-name-specifier] concept-name ]
    [| [~:opt nested-name-specifier] partial-concept-id ]
[rule:end]

[rule partial-concept-id [:zh_CN] 部分概念标识 ]
    [| concept-name [`<] [~:opt template-argument-list] [`>] ]
[rule:end]

[rule default-template-argument [:zh_CN] 默认模板实参 ]
    [| [`=] type-id ]
    [| [`=] id-expression ]
    [| [`=] initializer-clause ]
[rule:end]
[syntax:end]

[enter:note]
[:en]
The [`>] token following the [~template-parameter-list] of a [~type-parameter]
may be the product of replacing a [`>>] token by two consecutive [`>] tokens
([#temp.names]).
[:zh_CN]
[~类型形参]的[~模板形参列表]后面跟着的 [`>] 记号，可能是把 [`>>] 记号替换为两个
连续的 [`>] 记号而产生的（[#temp.names]）。
[exit:note]

[para]
[:en]
There is no semantic difference between [`class] and [`typename] in a
[~type-parameter-key].
[:zh_CN]
[~类型形参关键字]中的 [`class] 和 [`typename] 之间没有语义差别。

[:en]
[`typename] followed by an [~unqualified-id] names a template type parameter.
[:zh_CN]
[`typename] 后面跟着[~未限定标识]指名一个模板类型形参。

[:en]
[`typename] followed by a [~qualified-id] denotes the type in a non-type
[#:note#fn:$section.1] [~parameter-declaration].
[:zh_CN]
[`typename] 后面跟着[~限定标识]代表非类型[#:note#fn:$section.1][~形参声明式]中的
类型。

[note:foot#fn:$section.1]
[:en]
Since template [~template-parameter]s and template [~template-argument]s are
treated as types for descriptive purposes, the terms [+non-type parameter[%]]
and [+non-type argument[%]] are used to refer to non-type, non-template
parameters and arguments.
[:zh_CN]
由于在进行描述时模板[~模板形参]和模板[~模板实参]被当作类型，所以术语[+非类型
形参[%]]和[+非类型实参[%]]用来指代非类型非模板形参和实参。
[note:end]

[:en]
A [~template-parameter] of the form [`class] [~identifier] is a
[~type-parameter].
[:zh_CN]
形式为“[`class] [~标识符]”的[~模板形参]是[~类型形参]。

[enter:example]
[codeblock]
class T { /* ... */ };
int i;

template<class T, T i> void f(T t) {
  T t1 = i;         // [:en] [~template-parameter]s [`T] and [`i]
                    // [|:zh_CN] [~模板形参] [`T] 和 [`i]
  ::T t2 = ::i;     // [:en] global namespace members [`T] and [`i]
                    // [|:zh_CN] 全局命名空间成员 [`T] 和 [`i]
}
[codeblock:end]

[:en]
Here, the template [`f] has a [~type-parameter] called [`T], rather than an
unnamed non-type [~template-parameter] of class [`T].
[:zh_CN]
此处，模板 [`f] 带有一个叫作 [`T] 的[~类型形参]，而不是类 [`T] 的无名非类型
[~模板形参]。
[exit:example]

[:en]
A storage class shall not be specified in a [~template-parameter] declaration.
[:zh_CN]
[~模板形参]声明式中不能指定存储类。

[:en]
Types shall not be defined in a [~template-parameter] declaration.
[:zh_CN]
[~模板形参]声明式中不能定义类型。

[para]
[:en]
A [~type-parameter] whose identifier does not follow an ellipsis defines its
[~identifier] to be a [~typedef-name] (if declared without [`template]) or
[~template-name] (if declared with [`template]) in the scope of the template
declaration.
[:zh_CN]
标识符并不跟着省略号的[~类型形参]，将其[~标识符]定义为其模板声明式的作用域中的
[~typedef-名]（不以 [`template] 声明时）或[~模板名]（以 [`template] 声明时）。

[enter:note]
[:en]
A template argument may be a class template or alias template.
[:zh_CN]
模板实参可以是类模板或别名模板。

[:en]
For example,
[:zh_CN]
例如，

[codeblock]
template<class T> class myarray { /* ... */ };

template<class K, class V, template<class T> class C = myarray>
class Map {
  C<K> key;
  C<V> value;
};
[codeblock:end]
[exit:note]

[para]
[:en]
A non-type [~template-parameter] shall have one of the following (optionally
cv-qualified) types:
[:zh_CN]
非类型[~模板形参]应当具有如下之一的（可能被 cv 限定的）类型：

[list]
[item]
[:en@~] integral or enumeration type,
[:zh_CN@~] 整型或枚举类型，

[item]
[:en@~] pointer to object or pointer to function,
[:zh_CN@~] 对象指针或函数指针，

[item]
[:en@~] lvalue reference to object or lvalue reference to function,
[:zh_CN@~] 对象的左值引用或函数的左值引用，

[item]
[:en@~] pointer to member,
[:zh_CN@~] 成员指针，

[item]
[:en@~] [`std::nullptr_t], or
[:zh_CN@~] [`std::nullptr_t]，或者

[item]
[:en@~] a type that contains a placeholder type ([#dcl.spec.auto]).
[:zh_CN@~] 包含占位符类型的类型（[#dcl.spec.auto]）。
[list:end]

[para]
[enter:note]
[:en]
Other types are disallowed either explicitly below or implicitly by the rules
governing the form of [~template-argument]s ([#temp.arg]).
[:zh_CN]
其他的类型，要么在下文中明确禁止，要么隐含地在[~模板实参]的构成规则中被禁止
（[#temp.arg]）。
[exit:note]

[:en]
The top-level [~cv-qualifier]s on the [~template-parameter] are ignored when
determining its type.
[:zh_CN]
在确定[~模板形参]的类型时，忽略其顶层 [~cv-限定符]。

[para]
[:en]
A non-type non-reference [~template-parameter] is a prvalue.
[:zh_CN]
非类型非引用[~模板形参]是纯右值。

[:en]
It shall not be assigned to or in any other way have its value changed.
[:zh_CN]
它不能被赋值或以任意其他方式改变其值。

[:en]
A non-type non-reference [~template-parameter] cannot have its address taken.
[:zh_CN]
不能获取非类型非引用[~模板形参]的地址。

[:en]
When a non-type non-reference [~template-parameter] is used as an initializer
for a reference, a temporary is always used.
[:zh_CN]
当非类型非引用[~模板形参]用作引用的初始化式时，总要使用临时对象。

[enter:example]
[codeblock]
template<const X& x, int i> void f() {
  i++;                          // [:en] error: change of [~template-parameter] value
                                // [|:zh_CN] 错误：[~模板形参]的值被改变

  &x;                           // OK
  &i;                           // [:en] error: address of non-reference [~template-parameter]
                                // [|:zh_CN] 错误：非引用[~模板形参]的地址

  int& ri = i;                  // [:en] error: non-const reference bound to temporary
                                // [|:zh_CN] 错误：将非 const 引用绑定到临时对象上
  const int& cri = i;           // [:en] OK: const reference bound to temporary
                                // [|:zh_CN] OK：const 引用绑定到临时对象上
}
[codeblock:end]
[exit:example]

[para]
[:en]
A non-type [~template-parameter] shall not be declared to have floating point,
class, or void type.
[:zh_CN]
非类型[~模板形参]不能被声明为具有浮点、类或 [`void] 类型。

[enter:example]
[codeblock]
template<double d> class X;     // [:en] error
                                // [|:zh_CN] 错误
template<double* pd> class Y;   // OK
template<double& rd> class Z;   // OK
[codeblock:end]
[exit:example]

[para]
[:en]
[%array[!template parameter of type]]
A non-type [~template-parameter] of type ["array of [`T]] or
[%function[!template parameter of type]]
of function type [`T] is adjusted to be of type ["pointer to [`T]].
[:zh_CN]
[%数组[!～类型的模板形参]]
“[`T] 的数组”或
[%函数[!～类型的模板形参]]
函数类型 [`T] 的非类型[~模板形参]被调整为类型“[`T] 的指针”。

[enter:example]
[codeblock]
template<int* a>   struct R { /* ... */ };
template<int b[5]> struct S { /* ... */ };
int p;
R<&p> w;                        // OK
S<&p> x;                        // [:en] OK due to parameter adjustment
                                // [|:zh_CN] OK 由于形参调整
int v[5];
R<v> y;                         // [:en] OK due to implicit argument conversion
                                // [|:zh_CN] OK 由于隐式实参转换
S<v> z;                         // [:en] OK due to both adjustment and conversion
                                // [|:zh_CN] OK 由于调整和转换
[codeblock:end]
[exit:example]

[para]
[:en]
A [~partial-concept-id] is a [~concept-name] followed by a sequence of
[~template-argument]s.
[:zh_CN]
[~部分概念标识]是[~概念名]后面跟着一系列的[~模板实参]。

[:en]
These template arguments are used to form a [~constraint-expression] as
described below.
[:zh_CN]
这些模板实参用于构成[~约束表达式]，如下文所述。

[para]
[:en]
A [~constrained-parameter] declares a template parameter whose kind (type,
non-type, template) and type match that of the prototype parameter
([#temp.concept]) of the concept designated by the [~qualified-concept-name] in
the [~constrained-parameter].
[:zh_CN]
一个[~受约束形参]声明一个模板形参，其种类（类型、非类型或模板）和类型与由该
[~受约束形参]中的[~限定概念名]所代表的概念中的原型形参（[#temp.concept]）向匹配。

[:en]
Let [`X] be the prototype parameter of the designated concept.
[:zh_CN]
令 [`X] 为所代表的概念的原型形参。

[:en]
The declared template parameter is determined by the kind of [`X] (type,
non-type, template) and the optional ellipsis in the [~constrained-parameter]
as follows.
[:zh_CN]
所声明的模板形参，由 [`X] 的种类（类型、非类型或模板）以及[~受约束形参]中可选的
省略号，按如下方式确定。

[list]
[item]
[:en] If [`X] is a type [~template-parameter], the declared parameter is a type
[~template-parameter].
[:zh_CN] 如果 [`X] 是一个类型[~模板形参]，则所声明的形参为类型[~模板形参]。

[item]
[:en] If [`X] is a non-type [~template-parameter], the declared parameter is a
non-type [~template-parameter] having the same type as [`X].
[:zh_CN] 如果 [`X] 是一个非类型[~模板形参]，则所声明的形参是具有与 [`X] 相同类型
的非类型[~模板形参]。

[item]
[:en] If [`X] is a template [~template-parameter], the declared parameter is a
template [~template-parameter] having the same [~template-parameter-list] as
[`X], excluding default template arguments.
[:zh_CN] 如果 [`X] 为模板[~模板形参]，则所声明的形参是具有与 [`X] 相同
[~模板形参列表]，但排除默认模板实参的模板[~模板形参]。

[item]
[:en] If the [~qualified-concept-name] is followed by an ellipsis, then the
declared parameter is a template parameter pack ([#temp.variadic]).
[:zh_CN] 如果[~限定概念名]后面跟着省略号，则所声明的形参是模板形参包组
（[#temp.variadic]）。
[list:end]

[enter:example]
[codeblock]
template<typename T> concept C1 = true;
template<template<typename> class X> concept C2 = true;
template<int N> concept C3 = true;
template<typename... Ts> concept C4 = true;
template<char... Cs> concept C5 = true;

template<C1 T> void f1();       // [:en] OK, [`T] is a type [~template-parameter]
                                // [|:zh_CN] OK，[`T] 为类型[~模板形参]
template<C2 X> void f2();       // [:en] OK, [`X] is a template with one [~type-parameter]
                                // [|:zh_CN] OK，[`X] 为带有一个[~类型形参]的模板
template<C3 N> void f3();       // [:en] OK, [`N] has type [`int]
                                // [|:zh_CN] OK，[`N] 类型为 [`int]
template<C4... Ts> void f4();   // [:en] OK, [`Ts] is a template parameter pack of types
                                // [|:zh_CN] OK，[`Ts] 为一组类型的模板形参包组
template<C4 T> void f5();       // [:en] OK, [`T] is a type [~template-parameter]
                                // [|:zh_CN] OK，[`T] 为类型[~模板形参]
template<C5... Cs> void f6();   // [:en] OK, [`Cs] is a template parameter pack of [`char]s
                                // [|:zh_CN] OK，[`Cs] 为一组 [`char] 的模板形参包组
[codeblock:end]
[exit:example]

[para]
[:en]
A [~constrained-parameter] introduces a [~constraint-expression]
([#temp.constr.decl]).
[:zh_CN]
[~受约束形参]引入一个[~约束表达式]（[#temp.constr.decl]）。

[:en]
The expression is derived from the [~qualified-concept-name] [`Q] in the
[~constrained-parameter], its designated concept [`C], and the declared template
parameter [`P].
[:zh_CN]
该表达式由[~受约束形参]中的[~限定概念名] [`Q]，其所代表的概念 [`C]，以及所声明的
形参 [`P] 构成。

[list]
[item]
[:en] First, a template argument [`A] is formed from [`P].
[:zh_CN] 首先，从 [`P] 构成一个模板实参 [`A]。

[:en] If [`P] declares a template parameter pack ([#temp.variadic]) and [`C] is
a variadic concept ([#temp.concept]), then [`A] is the pack expansion [`P...].
[:zh_CN] 如果 [`P] 声明了一个模板形参包组([#temp.variadic]），并且 [`C] 是一个
变参概念（[#temp.concept]），则 [`A] 是包组展开式 [`P...]。

[:en] Otherwise, [`A] is the [~id-expression] [`P].
[:zh_CN] 否则，[`A] 就是[~标识表达式] [`P]。

[item]
[:en] Then, an [~id-expression] [`E] is formed as follows.
[:zh_CN] 然后，以如下方式构成一个[~标识表达式] [`E]。

[:en] If [`Q] is a [~concept-name], then [`E] is [`C<A>].
[:zh_CN] 如果 [`Q] 是一个[~概念名]，则 [`E] 为 [`C<A>]。

[:en] Otherwise, [`Q] is a [~partial-concept-id] of the form
[`C<A[$_1], A[$_2], ..., A[$_n]>], and [`E] is
[`C<A, A[$_1], A[$_2], ..., A[$_n]>].
[:zh_CN] 否则，[`Q] 为形式为 [`C<A[$_1], A[$_2], ..., A[$_n]>] 的[~部分概念
标识]，而 [`E] 为 [`C<A, A[$_1], A[$_2], ..., A[$_n]>]。

[item]
[:en] Finally, if [`P] declares a template parameter pack and [`C] is not a
variadic concept, [`E] is adjusted to be the [~fold-expression] [`(E && ...)]
([#expr.prim.fold]).
[:zh_CN] 最后，如果 [`P] 声明了一个模板形参包组而 [`C] 不是变参概念，则将 [`E]
调整为[~折叠表达式] [`(E && ...)]（[#expr.prim.fold]）。
[list:end]

[:en]
[`E] is the introduced [~constraint-expression].
[:zh_CN]
[`E] 即为所引入的[~约束表达式]。

[enter:example]
[codeblock]
template<typename T> concept C1 = true;
template<typename... Ts> concept C2 = true;
template<typename T, typename U> concept C3 = true;

template<C1 T> struct s1;       // [:en] associates [`C1<T>]
                                // [|:zh_CN] 关联 [`C1<T>]
template<C1... T> struct s2;    // [:en] associates [`(C1<T> && ...)]
                                // [|:zh_CN] 关联 [`(C1<T> && ...)]
template<C2... T> struct s3;    // [:en] associates [`C2<T...>]
                                // [|:zh_CN] 关联 [`C2<T...>]
template<C3<int> T> struct s4;  // [:en] associates [`C3<T, int>]
                                // [|:zh_CN] 关联 [`C3<T, int>]
[codeblock:end]
[exit:example]

[para]
[:en]
A [+default [~template-argument][%[~template-argument][!default]]] is a
[~template-argument] ([#temp.arg]) specified after [`=] in a
[~template-parameter].
[:zh_CN]
[+默认[~模板实参][%[~模板实参][!默认～]]]是在[~模板形参]中于 [`=] 之后所指定的
[~模板实参]（[#temp.arg]）。

[:en]
A default [~template-argument] may be specified for any kind of
[~template-parameter] (type, non-type, template) that is not a template
parameter pack ([#temp.variadic]).
[:zh_CN]
可以为除了模板形参包组（[#temp.variadic]）以外的任意种类的[~模板形参]（类型、
非类型或模板）指定默认[~模板实参]。

[:en]
A default [~template-argument] may be specified in a template declaration.
[:zh_CN]
模板声明式中可以指定默认[~模板实参]。

[:en]
A default [~template-argument] shall not be specified in the
[~template-parameter-list]s of the definition of a member of a class template
that appears outside of the member[=']s class.
[:zh_CN]
不能在类模板的成员的处于该成员所在类外面的定义式的[~模板形参列表]中指定默认
[~模板实参]。

[:en]
A default [~template-argument] shall not be specified in a friend class template
declaration.
[:zh_CN]
不能在友元类模板声明式中指定默认[~模板实参]。

[:en]
If a friend function template declaration specifies a default
[~template-argument], that declaration shall be a definition and shall be the
only declaration of the function template in the translation unit.
[:zh_CN]
若某个友元函数模板声明式指定了默认[~模板实参]，则该声明式应当是定义式，且应当是
这个翻译单元中该函数模板的唯一声明式。

[para]
[:en]
The default [~template-argument] of a [~constrained-parameter] shall match the
kind (type, non-type, template) of the declared template parameter.
[:zh_CN]
[~受约束形参]的默认[~模板实参]应当与所声明的模板形参的种类（类型、非类型或模板）
向匹配。

[enter:example]
[codeblock]
template<typename T> concept C1 = true;
template<int N> concept C2 = true;
template<template<typename> class X> concept C3 = true;

template<typename T> struct S0;

template<C1 T = int> struct S1; // OK
template<C2 N = 0> struct S2;   // OK
template<C3 X = S0> struct S3;  // OK
template<C1 T = 0> struct S4;   // [:en] error: default argument is not a type
                                // [|:zh_CN] 错误：默认实参不是类型
[codeblock:end]
[exit:example]

[para]
[:en]
The set of default [~template-argument]s available for use is obtained by
merging the default arguments from all prior declarations of the template in the
same way default function arguments are ([#dcl.fct.default]).
[:zh_CN]
可用的默认[~模板实参]的集合，是通过以同默认函数实参相同的方式
（[#dcl.fct.default]），对该模板之前的所有声明式中的默认实参进行合并所获得的。

[enter:example]
[codeblock]
template<class T1, class T2 = int> class A;
template<class T1 = int, class T2> class A;
[codeblock:end]

[:en]
is equivalent to
[:zh_CN]
等价于

[codeblock]
template<class T1 = int, class T2 = int> class A;
[codeblock:end]
[exit:example]

[para]
[:en]
If a [~template-parameter] of a class template, variable template, or alias
template has a default [~template-argument], each subsequent
[~template-parameter] shall either have a default [~template-argument] supplied
or be a template parameter pack.
[:zh_CN]
若类模板，变量模板或别名模板的某个[~模板形参]带有默认[~模板实参]，则其每个后续的
[~模板形参]应当要么提供默认[~模板实参]，要么是个模板形参包组。

[:en]
If a [~template-parameter] of a primary class template, primary variable
template, or alias template is a template parameter pack, it shall be the last
[~template-parameter].
[:zh_CN]
若主类模板，主变量模板或别名模板的某个[~模板形参]是模板形参包组，则它应当是最后
一个[~模板形参]。

[:en]
A template parameter pack of a function template shall not be followed by
another template parameter unless that template parameter can be deduced from
the parameter-type-list ([#dcl.fct]) of the function template or has a default
argument ([#temp.deduct]).
[:zh_CN]
函数模板的模板形参包组后面，不能跟着另一个模板形参，除非这个模板形参可以从该函数
模板的形参类型列表（[#dcl.fct]）进行推断或带有默认实参（[#temp.deduct]）。

[:en]
A template parameter of a deduction guide template ([#temp.deduct.guide]) that
does not have a default argument shall be deducible from the parameter-type-list
of the deduction guide template.
[:zh_CN]
推断指导模板（[#temp.deduct.guide]）的没有默认实参的模板形参，应当可以从该推断
指导模板的形参类型列表进行推断。

[enter:example]
[codeblock]
template<class T1 = int, class T2> class B;     // [:en] error
                                                // [|:zh_CN] 错误

// [:en] [`U] can be neither deduced from the parameter-type-list nor specified
// [|:zh_CN] [`U] 既不能从形参类型列表推断，也未被指定
template<class... T, class... U> void f() { }   // [:en] error
                                                // [|:zh_CN] 错误
template<class... T, class U> void g() { }      // [:en] error
                                                // [|:zh_CN] 错误
[codeblock:end]
[exit:example]

[para]
[:en]
A [~template-parameter] shall not be given default arguments by two different
declarations in the same scope.
[:zh_CN]
相同作用域中的两个不同声明式，不能同时为一个[~模板形参]给出默认实参。

[enter:example]
[codeblock]
template<class T = int> class X;
template<class T = int> class X { /*... */ };  // [:en] error
                                               // [|:zh_CN] 错误
[codeblock:end]
[exit:example]

[para]
[:en]
[%[`<][!template and]]
When parsing a default [~template-argument] for a non-type
[~template-parameter], the first non-nested [`>] is taken as the end of the
[~template-parameter-list] rather than a greater-than operator.
[:zh_CN]
[%[`<][!模板与～]]
当解析非类型[~模板形参]的默认[~模板实参]时，其第一个非嵌套的 [`>] 被当作[~模板
形参列表]的结尾而不是大于运算符。

[enter:example]
[codeblock]
template<int i = 3 > 4 >        // [:en] syntax error
                                // [|:zh_CN] 语法错误
class X { /* ... */ };

template<int i = (3 > 4) >      // OK
class Y { /* ... */ };
[codeblock:end]
[exit:example]

[para]
[:en]
A [~template-parameter] of a template [~template-parameter] is permitted to have
a default [~template-argument].
[:zh_CN]
允许模板[~模板形参]的[~模板形参]带有默认[~模板实参]。

[:en]
When such default arguments are specified, they apply to the template
[~template-parameter] in the scope of the template [~template-parameter].
[:zh_CN]
当指定了这样的模板实参时，它们适用于处于该模板[~模板形参]的作用域中的模板[~模板
形参]。

[enter:example]
[codeblock]
template <class T = float> struct B {};
template <template <class TT = float> class T> struct A {
  inline void f();
  inline void g();
};
template <template <class TT> class T> void A<T>::f() {
  T<> t;            // [:en] error - [`TT] has no default template argument
                    // [|:zh_CN] 错误 - [`TT] 没有默认模板实参
}
template <template <class TT = char> class T> void A<T>::g() {
    T<> t;          // OK - [`T<char>]
}
[codeblock:end]
[exit:example]

[para]
[:en]
If a [~template-parameter] is a [~type-parameter] with an ellipsis prior to its
optional [~identifier] or is a [~parameter-declaration] that declares a
parameter pack ([#dcl.fct]), then the [~template-parameter] is a template
parameter pack ([#temp.variadic]).
[:zh_CN]
若某个[~模板形参]是一个在其可选的[~标识符]之前带有省略号的[~类型形参]，或者是
一个声明了形参包组（[#dcl.fct]）的[~模板声明式]，则该[~模板形参]是模板形参包组
（[#temp.variadic]）。

[:en]
A template parameter pack that is a [~parameter-declaration] whose type contains
one or more unexpanded parameter packs is a pack expansion.
[:zh_CN]
如果某个模板形参包组是一个其类型中包含一个或多个未展开的形参包组的[~形参声明式]，
则它是包组展开式。

[:en]
Similarly, a template parameter pack that is a [~type-parameter] with a
[~template-parameter-list] containing one or more unexpanded parameter packs is
a pack expansion.
[:zh_CN]
相似地，如果某个模板形参包组是一个[~类型形参]，并带有包含一个或多个未展开的形参
包组的[~模板形参列表]，则它是包组展开式。

[:en]
A template parameter pack that is a pack expansion shall not expand a parameter
pack declared in the same [~template-parameter-list].
[:zh_CN]
作为包组展开式的模板形参包组，不能对声明于相同的[~模板形参列表]中的形参包组进行
展开。

[enter:example]
[codeblock]
template <class... Types> class Tuple;                // [:en] [`Types] is a template type parameter pack
                                                      // [|:zh_CN] [`Types] 是模板类型形参包组
                                                      // [:en@~] but not a pack expansion
                                                      // [|:zh_CN@~] 但不是包组展开式
template <class T, int... Dims> struct multi_array;   // [:en] [`Dims] is a non-type template parameter pack
                                                      // [|:zh_CN] [`Dims] 是非类型模板形参包组
                                                      // [:en@~] but not a pack expansion
                                                      // [|:zh_CN@~] 但不是包组展开式
template<class... T> struct value_holder {
  template<T... Values> struct apply { };             // [:en] [`Values] is a non-type template parameter pack
                                                      // [|:zh_CN] [`Values] 是非类型模板形参包组
                                                      // [:en@~] and a pack expansion
                                                      // [|:zh_CN@~] 也是包组展开式
};
template<class... T, T... Values> struct static_array;// [:en] error: [`Values] expands template type parameter
                                                      // [|:zh_CN] 错误：[`Values] 展开了同一个模板形参列表
                                                      // [:en@~] pack [`T] within the same template parameter list
                                                      // [|:zh_CN@~] 中的模板类型形参包组 [`T]
[codeblock:end]
[exit:example]
