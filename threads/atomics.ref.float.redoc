[section#atomics.ref.float
    [:en] Specializations for floating-point types
    [:zh_CN] 针对浮点类型的特化式
]

[%@lib@raw [`atomic_ref<[^floating-point-type]>]]
[para]
[:en] There are specializations of the [`atomic_ref] class template for all
floating-point types.
[:zh_CN] [`atomic_ref] 类模板对所有浮点类型进行了特化。

[:en] For each such type [`[^floating-point-type]], the specialization
[`atomic_ref<[^floating-point-type]>] provides additional atomic operations
appropriate to floating-point types.
[:zh_CN] 对于每个这样的类型 [`[^floating-point-type]]，特例
[`atomic_ref<[^floating-point-type]>] 提供了适用于该浮点类型的额外的原子性操作。

[para]
[:en] The program is ill-formed if [`is_always_lock_free] is [`false] and
[`is_volatile_v<T>] is [`true].
[:zh_CN] 如果 [`is_always_lock_free] 为 [`false] 且 [`is_volatile_v<T>] 为 [`true]，
那么程序非良构。

[codeblock:synopsis]
namespace std {
  template<> struct atomic_ref<[[redoc("^>")]]floating-point-type> {
  private:
    [[redoc("^>")]]floating-point-type* ptr;   // [=expos]
  public:
    using value_type = remove_cv_t<[[redoc("^>")]]floating-point-type>;
    using difference_type = value_type;
    static constexpr size_t required_alignment = [[redoc("[?impdefx"
        "[:en] required alignment for [`atomic_ref] type[=']s operations"
        "[:zh_CN] [`atomic_ref] 类型的操作所需的对齐]")]];

    static constexpr bool is_always_lock_free = [[redoc("[?impdefx"
        "[:en] whether a given [`atomic_ref] type[=']s operations are always lock free"
        "[:zh_CN] 给定 [`atomic_ref] 类型的操作是否总是免锁的]")]];
    bool is_lock_free() const noexcept;

    constexpr explicit atomic_ref([[redoc("^>")]]floating-point-type&);
    constexpr atomic_ref(const atomic_ref&) noexcept;
    atomic_ref& operator=(const atomic_ref&) = delete;

    constexpr void store(value_type,
                         memory_order = memory_order::seq_cst) const noexcept;
    constexpr value_type operator=(value_type) const noexcept;
    constexpr value_type load(memory_order = memory_order::seq_cst) const noexcept;
    constexpr operator value_type() const noexcept;

    constexpr value_type exchange(value_type,
                                  memory_order = memory_order::seq_cst) const noexcept;
    constexpr bool compare_exchange_weak(value_type&, value_type,
                                         memory_order, memory_order) const noexcept;
    constexpr bool compare_exchange_strong(value_type&, value_type,
                                           memory_order, memory_order) const noexcept;
    constexpr bool compare_exchange_weak(value_type&, value_type,
                                         memory_order = memory_order::seq_cst) const noexcept;
    constexpr bool compare_exchange_strong(value_type&, value_type,
                                           memory_order = memory_order::seq_cst) const noexcept;

    constexpr value_type fetch_add(value_type,
                                   memory_order = memory_order::seq_cst) const noexcept;
    constexpr value_type fetch_sub(value_type,
                                   memory_order = memory_order::seq_cst) const noexcept;

    constexpr value_type fetch_max(value_type,
                                   memory_order = memory_order::seq_cst) const noexcept;
    constexpr value_type fetch_min(value_type,
                                   memory_order = memory_order::seq_cst) const noexcept;
    constexpr value_type fetch_fmaximum(value_type,
                                        memory_order = memory_order::seq_cst) const noexcept;
    constexpr value_type fetch_fminimum(value_type,
                                        memory_order = memory_order::seq_cst) const noexcept;
    constexpr value_type fetch_fmaximum_num(value_type,
                                            memory_order = memory_order::seq_cst) const noexcept;
    constexpr value_type fetch_fminimum_num(value_type,
                                            memory_order = memory_order::seq_cst) const noexcept;

    constexpr void store_add(value_type, memory_order = memory_order::seq_cst) const noexcept;
    constexpr void store_sub(value_type, memory_order = memory_order::seq_cst) const noexcept;
    constexpr void store_max(value_type, memory_order = memory_order::seq_cst) const noexcept;
    constexpr void store_min(value_type, memory_order = memory_order::seq_cst) const noexcept;
    constexpr void store_fmaximum(value_type,
                                  memory_order = memory_order::seq_cst) const noexcept;
    constexpr void store_fminimum(value_type,
                                  memory_order = memory_order::seq_cst) const noexcept;
    constexpr void store_fmaximum_num(value_type,
                                      memory_order = memory_order::seq_cst) const noexcept;
    constexpr void store_fminimum_num(value_type,
                                      memory_order = memory_order::seq_cst) const noexcept;

    constexpr value_type operator+=(value_type) const noexcept;
    constexpr value_type operator-=(value_type) const noexcept;

    constexpr void wait(value_type,
                        memory_order = memory_order::seq_cst) const noexcept;
    constexpr void notify_one() const noexcept;
    constexpr void notify_all() const noexcept;
    constexpr [[redoc("^>")]]floating-point-type* address() const noexcept;
  };
}
[codeblock:end]

[para]
[:en] Descriptions are provided below only for members that differ from the
primary template.
[:zh_CN] 下文仅为与主模板不同的成员提供描述。

[para]
[:en] The following operations perform arithmetic computations.
[:zh_CN] 以下各操作实施算术运算。

[:en] The correspondence among key, operator, and computation is specified in
[#:tab#atomic.types.int.comp], except for the keys [`max], [`min], [`fmaximum],
[`fminimum], [`fmaximum_num], and [`fminimum_num], which are specified below.
[:zh_CN] [#:tab#atomic.types.int.comp] 给出关键词、运算符和运算之间的对应关系，
下文给出关键词 [`max]、[`min]、[`fmaximum]、[`fminimum]、[`fmaximum_num] 和 [`fminimum_num]。

[%@lib@member fetch_add[!atomic_ref<[^floating-point-type]>]]
[%@lib@member fetch_sub[!atomic_ref<[^floating-point-type]>]]
[%@lib@member fetch_fmaximum[!atomic_ref<[^floating-point-type]>]]
[%@lib@member fetch_fminimum[!atomic_ref<[^floating-point-type]>]]
[%@lib@member fetch_fmaximum_num[!atomic_ref<[^floating-point-type]>]]
[%@lib@member fetch_fminimum_num[!atomic_ref<[^floating-point-type]>]]
[%@lib@member fetch_max[!atomic_ref<[^floating-point-type]>]]
[%@lib@member fetch_min[!atomic_ref<[^floating-point-type]>]]
[codeblock:declaration]
constexpr value_type fetch_key[[redoc("^<3c")]](value_type operand,
                          memory_order order = memory_order::seq_cst) const noexcept;
[codeblock:end]

[div:description]
[para:constraints]
[:en] [`is_const_v<[^floating-point-type]>] is [`false].
[:zh_CN] [`is_const_v<[^floating-point-type]>] 为 [`false]。

[para:effects]
[:en] Atomically replaces the value referenced by [`*ptr] with the result of the
computation applied to the value referenced by [`*ptr] and the given operand.
[:zh_CN] 原子地将由 [`*ptr] 所引用的值替换为对由 [`*ptr] 所引用的值和给定的
[`operand] 实施运算的结果。

[:en] Memory is affected according to the value of [`order].
[:zh_CN] 根据 [`order] 的值影响内存。

[:en] These operations are atomic read-modify-write operations ([#intro.races]).
[:zh_CN] 这些操作是原子性读-改-写操作（[#intro.races]）。

[para:returns]
[:en] Atomically, the value referenced by [`*ptr] immediately before the effects.
[:zh_CN] 原子地返回紧接其效果生效前 [`*ptr] 所引用的值。

[para:remarks]
[:en] If the result is not a representable value for its type ([#expr.pre]), the
result is unspecified, but the operations otherwise have no undefined behavior.
[:en] 如果结果不是其类型可以表示的值（[#expr.pre]），则结果未指明，但除此以外
这些操作并没有未定义的行为。

[:en] Atomic arithmetic operations on [`[^floating-point-type]] should conform
to the [`std::numeric_limits<value_type>] traits associated with the
floating-point type ([#limits.syn]).
[:zh_CN] 对 [`[^floating-point-type]] 进行的原子性算术运算应当遵循与该浮点类型所
关联的 [`std::numeric_limits<value_type>] 特征（[#limits.syn]）。

[:en] The floating-point environment ([#cfenv]) for atomic arithmetic operations
on [`[^floating-point-type]] may be different than the calling thread[=']s
floating-point environment.
[:zh_CN] 对 [`[^floating-point-type]] 进行原子性算术运算的浮点环境（[#cfenv]）
可能与调用方线程的浮点环境不同。

[para]
[list]
[item]
[:en] For [`fetch_fmaximum] and [`fetch_fminimum], the maximum and minimum
computation is performed as if by [`fmaximum] and [`fminimum], respectively,
with [`*ptr] and the first parameter as the arguments.
[:zh_CN] [`fetch_fmaximum] 和 [`fetch_fminimum] 分别如同以 [*ptr] 和第一个形参
作为实参，通过 [`fmaximum] 和 [`fminimum] 实施最大值和最小值运算。

[item]
[:en] For [`fetch_fmaximum_num] and [`fetch_fminimum_num], the maximum and minimum
computation is performed as if by [`fmaximum_num] and [`fminimum_num], respectively,
with [`*ptr] and the first parameter as the arguments.
[:zh_CN] [`fetch_fmaximum_num] 和 [`fetch_fminimum_num] 分别如同以 [*ptr] 和第一个形参
作为实参，通过 [`fmaximum_num] 和 [`fminimum_num] 实施最大值和最小值运算。

[item]
[:en] For [`fetch_max] and [`fetch_min], the maximum and minimum computation is
performed as if by [`fmaximum_num] and [`fminimum_num], respectively,
with [`*ptr] and the first parameter as the arguments, except that:
[:zh_CN] [`fetch_max] 和 [`fetch_min] 分别如同以 [*ptr] 和第一个形参作为实参，
通过 [`fmaximum_num] 和 [`fminimum_num] 实施最大值和最小值运算，但：
 [list]
 [item]
[:en] If both arguments are NaN, an unspecified NaN value is stored at [`*ptr].
[:zh_CN] 如果两个实参均为 NaN，则将未指明的 NaN 值存入 [`*ptr]。
 [item]
[:en] If exactly one argument is a NaN, either the other argument or
an unspecified NaN value is stored at [`ptr]; it is unspecified which.
[:zh_CN] 如果恰有一个实参为 NaN，则将另一个实参或未指明的 NaN 值存储 [`*ptr]；未指明采用哪项。
 [item]
[:en] If the arguments are differently signed zeros,
which of these values is stored at [`*ptr] is unspecified.
[:zh_CN] 如果两个实参是带不同符号的零，则未指明将那个值存入 [`*ptr]。
 [list:end]
[list:end]

[para:recommended]
[:en] The implementation of [`fetch_max] and [`fetch_min]
should treat negative zero as smaller than positive zero.
[:zh_CN] [`fetch_max] 和 [`fetch_min] 的实现最好将负零当作小于正零。
[div:end]

[%@lib@member store_add[!atomic_ref<[^floating-point-type]>]]
[%@lib@member store_sub[!atomic_ref<[^floating-point-type]>]]
[%@lib@member store_fmaximum[!atomic_ref<[^floating-point-type]>]]
[%@lib@member store_fminimum[!atomic_ref<[^floating-point-type]>]]
[%@lib@member store_fmaximum_num[!atomic_ref<[^floating-point-type]>]]
[%@lib@member store_fminimum_num[!atomic_ref<[^floating-point-type]>]]
[%@lib@member store_max[!atomic_ref<[^floating-point-type]>]]
[%@lib@member store_min[!atomic_ref<[^floating-point-type]>]]
[codeblock:declaration]
constexpr void store_key[[redoc("^<3c")]](value_type operand,
                          memory_order order = memory_order::seq_cst) const noexcept;
[codeblock:end]

[div:description]
[para:expects]
[:en] [`order] is [`memory_order::relaxed], [`memory_order::release], or [`memory_order::seq_cst].
[:zh_CN] [`order] 为 [`memory_order::relaxed]、[`memory_order::release] 或 [`memory_order::seq_cst].

[para:effects]
[:en] Atomically replaces the value referenced by [`*ptr] with the result of the
computation applied to the value referenced by [`*ptr] and the given operand.
[:zh_CN] 原子地将由 [`*ptr] 所引用的值替换为对由 [`*ptr] 所引用的值和给定的
[`operand] 实施运算的结果。

[:en] Memory is affected according to the value of [`order].
[:zh_CN] 根据 [`order] 的值影响内存。

[:en] These operations are atomic modify-write operations ([#atomics.order]).
[:zh_CN] 这些操作是原子性改-写操作（[#atomics.order]）。

[para:remarks]
[:en] If the result is not a representable value for its type ([#expr.pre]), the
result is unspecified, but the operations otherwise have no undefined behavior.
[:en] 如果结果不是其类型可以表示的值（[#expr.pre]），则结果未指明，但除此以外
这些操作并没有未定义的行为。

[:en] Atomic arithmetic operations on [`[^floating-point-type]] should conform
to the [`std::numeric_limits<[^floating-point-type]>] traits associated with the
floating-point type ([#limits.syn]).
[:zh_CN] 对 [`[^floating-point-type]] 进行的原子性算术运算应当遵循与该浮点类型所
关联的 [`std::numeric_limits<[^floating-point-type]>] 特征（[#limits.syn]）。

[:en] The floating-point environment ([#cfenv]) for atomic arithmetic operations
on [`[^floating-point-type]] may be different than the calling thread[=']s
floating-point environment.
[:zh_CN] 对 [`[^floating-point-type]] 进行原子性算术运算的浮点环境（[#cfenv]）
可能与调用方线程的浮点环境不同。

[:en] The arithmetic rules of floating-point atomic modify-write operations
may be different from operations on floating-point types or atomic floating-point types.
[:zh_CN] 浮点原子性改-写操作的算术规则可能与浮点类型或原子性浮点类型的操作有所不同。

[begin:note]
[:en] Tree reductions are permitted for atomic modify-write operations.
[:zh_CN] 允许对原子性改-写操作进行树简化。
[end:note]

[para]
[list]
[item]
[:en] For [`store_fmaximum] and [`store_fminimum], the maximum and minimum
computation is performed as if by [`fmaximum] and [`fminimum], respectively,
with [`*ptr] and the first parameter as the arguments.
[:zh_CN] [`store_fmaximum] 和 [`store_fminimum] 分别如同以 [*ptr] 和第一个形参
作为实参，通过 [`fmaximum] 和 [`fminimum] 实施最大值和最小值运算。

[item]
[:en] For [`store_fmaximum_num] and [`store_fminimum_num], the maximum and minimum
computation is performed as if by [`fmaximum_num] and [`fminimum_num], respectively,
with [`*ptr] and the first parameter as the arguments.
[:zh_CN] [`store_fmaximum_num] 和 [`store_fminimum_num] 分别如同以 [*ptr] 和第一个形参
作为实参，通过 [`fmaximum_num] 和 [`fminimum_num] 实施最大值和最小值运算。

[item]
[:en] For [`store_max] and [`store_min], the maximum and minimum computation is
performed as if by [`fmaximum_num] and [`fminimum_num], respectively,
with [`*ptr] and the first parameter as the arguments, except that:
[:zh_CN] [`store_max] 和 [`store_min] 分别如同以 [*ptr] 和第一个形参作为实参，
通过 [`fmaximum_num] 和 [`fminimum_num] 实施最大值和最小值运算，但：
 [list]
 [item]
[:en] If both arguments are NaN, an unspecified NaN value is stored at [`*ptr].
[:zh_CN] 如果两个实参均为 NaN，则将未指明的 NaN 值存入 [`*ptr]。
 [item]
[:en] If exactly one argument is a NaN, either the other argument or
an unspecified NaN value is stored at [`ptr]; it is unspecified which.
[:zh_CN] 如果恰有一个实参为 NaN，则将另一个实参或未指明的 NaN 值存储 [`*ptr]；未指明采用哪项。
 [item]
[:en] If the arguments are differently signed zeros,
which of these values is stored at [`*ptr] is unspecified.
[:zh_CN] 如果两个实参是带不同符号的零，则未指明将那个值存入 [`*ptr]。
 [list:end]
[list:end]

[para:recommended]
[:en] The implementation of [`store_max] and [`store_min]
should treat negative zero as smaller than positive zero.
[:zh_CN] [`store_max] 和 [`store_min] 的实现最好将负零当作小于正零。
[div:end]

[%@lib@member operator+=[!atomic_ref<[^floating-point-type]>]]
[%@lib@member operator-=[!atomic_ref<[^floating-point-type]>]]
[codeblock:declaration]
constexpr value_type operator [[redoc("^>")]]op=(value_type operand) const noexcept;
[codeblock:end]

[div:description]
[para:constraints]
[:en] [`is_const_v<[^floating-point-type]>] is [`false].
[:zh_CN] [`is_const_v<[^floating-point-type]>] 为 [`false]。

[para:effects]
[:en] Equivalent to: [`return fetch_[^key](operand) [^op] operand;]
[:zh_CN] 等价于：[`return fetch_[^key](operand) [^op] operand;]
[div:end]
