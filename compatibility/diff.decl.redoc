[section#diff.decl
    [:en] Clause [#dcl.decl]: declarators
    [:zh_CN] 第 [#dcl.decl] 章：声明符
]

[para:~] [#dcl.fct]
[=Change]
[:en] In [=Cpp], a function declared with an empty parameter list takes no
arguments.
[:zh_CN] 在 [=Cpp] 中，以空的形参列表声明的函数不接受任何形参。

[:en] In C, an empty parameter list means that the number and type of the
function arguments are unknown.
[:zh_CN] 在 C 中，空的形参列表的意思是函数实参的数量和类型未知。

[:en] Example:
[:zh_CN] 例：

[codeblock]
int f();            // [:en] means [`int f(void)] in [=Cpp]
                    // [|:zh_CN] 在 [=Cpp] 中的意思是 [`int f(void)]
                    // [:en] [`int f(] unknown [`)] in C
                    // [|:zh_CN] 在 C 中的意思是 [`int f(] 未知 [`)]
[codeblock:end]

[=Rationale]
[:en] This is to avoid erroneous function calls (i.e., function calls with the
wrong number or type of arguments).
[:zh_CN] 这样是为了避免错误的函数调用（亦即带有错误数量或类型的实参的函数调用）。

[=Effect]
[:en] Change to semantics of well-defined feature.
[:zh_CN] 改变了有良好定义的功能特性的语义。

[:en] This feature was marked as ["obsolescent] in C.
[:zh_CN] 这项功能特性在 C 中已被标记为“过时的”。

[=Difficulty]
[:en] Syntactic transformation.
[:zh_CN] 语法转换。

[:en] The function declarations using C incomplete declaration style must
be completed to become full prototype declarations.
[:zh_CN] 使用 C 的不完整声明风格的函数声明式，必须补充成为完整的原型声明式。

[:en] A program may need to be updated further if different calls to th same
(non-prototype) function have different numbers of arguments or if the type of
corresponding arguments differed.
[:zh_CN] 如果对同一个（非原型）函数的不同调用具有不同的实参数量或者各对应实参的
类型存在不同，则程序可能需要进一步进行更新。

[=HowWide]
[:en] Common.
[:zh_CN] 常见。

[para:~]
[:en] [#dcl.fct] [=`[]see [#expr.sizeof][=`]]
[:zh_CN] [#dcl.fct] [=`[]参见 [#expr.sizeof][=`]]

[=Change]
[:en] In [=Cpp], types may not be defined in return or parameter types.
[:zh_CN] 在 [=Cpp] 中，不能在返回或形参类型中定义类型。

[:en] In C, these type definitions are allowed.
[:zh_CN] 在 C 中，这种类型定义是受到允许的。

[:en] Example:
[:zh_CN] 例：

[codeblock]
void f( struct S { int a; } arg ) {}    // [:en] valid C, invalid [=Cpp]
                                        // [|:zh_CN] C 中有效，[=Cpp] 中无效
enum E { A, B, C } f() {}               // [:en] valid C, invalid [=Cpp]
                                        // [|:zh_CN] C 中有效，[=Cpp] 中无效
[codeblock:end]

[=Rationale]
[:en] When comparing types in different translation units, [=Cpp] relies on name
equivalence when C relies on structural equivalence.
[:zh_CN] 当比较不同翻译单元中的类型时，[=Cpp] 依赖于名字等价性，而 C 依赖于结构
等价性。

[:en] Regarding parameter types: since the type defined in a parameter list
would be in the scope of the function, the only legal calls in [=Cpp] would be
from within the function itself.
[:zh_CN] 有关形参类型：由于在形参列表中所定义的类型将会处于函数的作用域之中，
因而在 [=Cpp] 中唯一合法的调用就是在函数自身之中进行。

[=Effect]
[:en] Deletion of semantically well-defined feature.
[:zh_CN] 删除了有良好定义语义的功能特性。

[=Difficulty]
[:en] Semantic transformation.
[:zh_CN] 语义转换。

[:en] The type definitions must be moved to file scope, or in header files.
[:zh_CN] 必须将类型定义移动到文件作用域中，或者到头文件中。

[=HowWide]
[:en] Seldom.
[:zh_CN] 少见。

[:en] This style of type definition is seen as poor coding style.
[:zh_CN] 这种类型定义风格被认为是不良的编码风格。

[para:~] [#dcl.fct.def]
[=Change]
[:en] In [=Cpp], the syntax for function definition excludes the ["old-style] C
function.
[:zh_CN] 在 [=Cpp] 中，函数定义式的语法中排除了“老式”的 C 函数。

[:en] In C, ["old-style] syntax is allowed, but deprecated as ["obsolescent].
[:zh_CN] 在 C 中，“老式”语法是允许的，但作为“过时的”功能特性而被摒弃。

[=Rationale]
[:en] Prototypes are essential to type safety.
[:zh_CN] 原型对于类型安全是基本要求。

[=Effect]
[:en] Deletion of semantically well-defined feature.
[:zh_CN] 删除了有良好定义语义的功能特性。

[=Difficulty]
[:en] Syntactic transformation.
[:zh_CN] 语法转换。

[=HowWide]
[:en] Common in old programs, but already known to be obsolescent.
[:zh_CN] 在老旧程序中常见，但已经被认为是过时的。

[para:~] [#dcl.init.string]
[=Change]
[:en] In [=Cpp], when initializing an array of character with a string, the
number of characters in the string (including the terminating [`'\0']) must not
exceed the number of elements in the array.
[:zh_CN] 在 [=Cpp] 中，当用字符串来初始化字符数组时，字符串中的字符数量（包括
结尾的 [`'\0']）不能超过数组中的元素数量。

[:en] In C, an array can be initialized with a string even if the array is not
large enough to contain the string-terminating [`'\0'].
[:zh_CN] 在 C 中，即便数组并不足够包含字符串的末尾 [`'\0']，也可以用字符串来
初始化数组。

[:en] Example:
[:zh_CN] 例：

[codeblock]
char array[4] = "abcd";         // [:en] valid C, invalid [=Cpp]
                                // [|:zh_CN] C 中有效，[=Cpp] 中无效
[codeblock:end]

[=Rationale]
[:en] When these non-terminated arrays are manipulated by standard string
functions, there is potential for major catastrophe.
[:zh_CN] 当用标准字符串函数来处理这些无结尾的数组时，有发生大灾难的可能性。

[=Effect]
[:en] Deletion of semantically well-defined feature.
[:zh_CN] 删除了有良好定义语义的功能特性。

[=Difficulty]
[:en] Semantic transformation.
[:zh_CN] 语义转换。

[:en] The arrays must be declared one element bigger to contain the string
terminating [`'\0'].
[:zh_CN] 数组必须被声明为多出一个元素以容纳字符串的末尾 [`'\0']。

[=HowWide]
[:en] Seldom.
[:zh_CN] 少见。

[:en] This style of array initialization is seen as poor coding style.
[:zh_CN] 这种数组初始化风格已被认为是不良的编码风格。
