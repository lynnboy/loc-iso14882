[section#diff.dcl
    [:en] [#dcl.dcl]: declarations
    [:zh_CN] [#dcl.dcl]：声明式
]

[para:~] [#dcl.stc]
[=Change]
[:en] In [=Cpp], the [`static] or [`extern] specifiers can only be applied to
names of objects or functions. [br]
[:zh_CN] 在 [=Cpp] 中，[`static] 或 [`extern] 说明符只能应用到对象或函数的名字。
[br]

[:en] Using these specifiers with type declarations is illegal in [=Cpp].
[:zh_CN] 对类型声明式使用这些说明符在 [=Cpp] 中是非法的。

[:en] In C, these specifiers are ignored when used on type declarations.
[:zh_CN] 在 C 中，当在类型声明式上使用这些说明符时是将其忽略的。

[:en] Example:
[:zh_CN] 例：

[codeblock]
static struct S {               // [:en] valid C, invalid in [=Cpp]
                                // [|:zh_CN] C 中有效，[=Cpp] 中无效。
  int i;
};
[codeblock:end]

[=Rationale]
[:en] Storage class specifiers don[=']t have any meaning when associated with a
type.
[:zh_CN] 存储类说明符关联到类型上时没有任何意义。

[:en] In [=Cpp], class members can be declared with the [`static] storage class
specifier.
[:zh_CN] 在 [=Cpp] 中，类成员可以用 [`static] 存储类说明符来声明。

[:en] Allowing storage class specifiers on type declarations could render the
code confusing for users.
[:zh_CN] 而允许在类型声明上使用存储类说明符可能使代码让用户感觉混乱。

[=Effect]
[:en] Deletion of semantically well-defined feature.
[:zh_CN] 删除了有良好定义语义的功能特性。

[=Difficulty]
[:en] Syntactic transformation.
[:zh_CN] 语法转换。

[=HowWide]
[:en] Seldom.
[:zh_CN] 少见。

[para:~] [#dcl.stc]
[=Change]
[:en] In [=Cpp], [`register] is not a storage class specifier.
[:zh_CN] 在 [=Cpp] 中，[`register] 不是存储类说明符。

[=Rationale]
[:en] The storage class specifier had no effect in [=Cpp].
[:zh_CN] 这个存储类说明符在 [=Cpp] 中没有效果。

[=Effect]
[:en] Deletion of semantically well-defined feature.
[:zh_CN] 删除了有良好定义语义的功能特性。

[=Difficulty]
[:en] Syntactic transformation.
[:zh_CN] 语法转换。

[=HowWide]
[:en] Common.
[:zh_CN] 常见。

[para:~] [#dcl.typedef]

[=Change]
[:en] A [=Cpp] typedef name must be different from any class type name declared
in the same scope (except if the typedef is a synonym of the class name with the
same name).
[:zh_CN] [=Cpp] 的 typedef 名必须与声明于相同作用域的任何类类型的名字不同（除非
该 typedef 是带有相同名字的类名字的同义词）。

[:en] In C, a typedef name and a struct tag name declared in the same scope
can have the same name (because they have different name spaces).
[:zh_CN] 在 C 中，typedef 名和声明于相同作用域中的结构标签名可以具有相同的名字
（因为它们具有不同的名字空间）。

[:en] Example:
[:zh_CN] 例：

[codeblock]
typedef struct name1 { /* ... */ } name1;         // [:en] valid C and [=Cpp]
                                                  // [|:zh_CN] C 和 [=Cpp] 都有效
struct name { /* ... */ };
typedef int name;               // [:en] valid C, invalid [=Cpp]
                                // [|:zh_CN] C 中有效，[=Cpp] 中无效。
[codeblock:end]

[=Rationale]
[:en] For ease of use, [=Cpp] doesn[=']t require that a type name be prefixed
with the keywords [`class], [`struct] or [`union] when used in object
declarations or type casts.
[:zh_CN] 为便于使用，当在对象声明式中或者类型强制转换中使用时，[=Cpp] 并不要求给
类型名字加上前缀关键字 [`class]、[`struct] 或 [`union]。

[:en] Example:
[:zh_CN] 例：

[codeblock]
class name { /* ... */ };
name i;                         // [:en] [`i] has type [`class name]
                                // [|:zh_CN] [`i] 具有类型 [`class name]
[codeblock:end]

[=Effect]
[:en] Deletion of semantically well-defined feature.
[:zh_CN] 删除了有良好定义语义的功能特性。

[=Difficulty]
[:en] Semantic transformation.
[:zh_CN] 语义转换。

[:en] One of the 2 types has to be renamed.
[:zh_CN] 必须对两个类型之一重命名。

[=HowWide]
[:en] Seldom.
[:zh_CN] 少见。

[para:~]
[:en] [#dcl.type] [=`[]see also [#basic.link][=`]]
[:zh_CN] [#dcl.type] [=`[]另见 [#basic.link][=`]]

[=Change]
[:en] [`const] objects must be initialized in [=Cpp] but can be left
uninitialized in C.
[:zh_CN] [`const] 对象在 [=Cpp] 中必须初始化，但在 C 中可以遗留未初始化。

[=Rationale]
[:en] A const object cannot be assigned to so it must be initialized to hold a
useful value.
[:zh_CN] [`const] 对象无法被赋值，因此必须进行初始化以使其持有有用的值。

[=Effect]
[:en] Deletion of semantically well-defined feature.
[:zh_CN] 删除了有良好定义语义的功能特性。

[=Difficulty]
[:en] Semantic transformation.
[:zh_CN] 语义转换。

[=HowWide]
[:en] Seldom.
[:zh_CN] 少见。

[para:~] [#dcl.type]
[=Change]
[:en] Banning implicit [`int].
[:zh_CN] 禁止隐式 [`int]。

[:en] In [=Cpp] a [~decl-specifier-seq] must contain a [~type-specifier], unless
it is followed by a declarator for a constructor, a destructor, or a conversion
function.
[:zh_CN] 在 [=Cpp] 中，除非后面跟着构造函数、析构函数或转换函数的声明符，否则
[~声明说明符序列]中必须包含一个[~类型说明符]。

[:en] In the following example, the left-hand column presents valid C; the
right-hand column presents equivalent [=Cpp]:
[:zh_CN] 下面的例子中，左边一列展示有效的 C；右边一列展示等价的 [=Cpp]：

[codeblock]
void f(const parm);            void f(const int parm);
const n = 3;                   const int n = 3;
main()                         int main()
    /* ... */                      /* ... */
[codeblock:end]

[=Rationale]
[:en] In [=Cpp], implicit int creates several opportunities for ambiguity
between expressions involving function-like casts and declarations.
[:zh_CN] 在 [=Cpp] 中，隐式 [`int] 会造成几种涉及函数式强制转换和声明式的表达式
的歧义的机会。

[:en] Explicit declaration is increasingly considered to be proper style.
[:zh_CN] 显式声明越来越被认为是更恰当的编码风格。

[:en] Liaison with WG14 (C) indicated support for (at least) deprecating
implicit int in the next revision of C.
[:zh_CN] 与 WG14 （C）的联络中表明其支持在下个 C 的修订版本中（至少）摒弃隐式
[`int]。

[=Effect]
[:en] Deletion of semantically well-defined feature.
[:zh_CN] 删除了有良好定义语义的功能特性。

[=Difficulty]
[:en] Syntactic transformation.
[:zh_CN] 语法转换。

[:en] Could be automated.
[:zh_CN] 可以自动化。

[=HowWide]
[:en] Common.
[:zh_CN] 常见。

[para:~] [#dcl.spec.auto]

[=Change]
[:en] The keyword [`auto] cannot be used as a storage class specifier.
[:zh_CN] 关键字 [`auto] 不能被用作存储类说明符。

[codeblock]
void f() {
  auto int x;     // [:en] valid C, invalid [=Cpp]
                  // [|:zh_CN] C 中有效，[=Cpp] 中无效。
}
[codeblock:end]

[=Rationale]
[:en] Allowing the use of [`auto] to deduce the type of a variable from its
initializer results in undesired interpretations of [`auto] as a storage class
specifier in certain contexts.
[:zh_CN] 允许将 [`auto] 用于从变量的初始化式来推断其类型，导致在某些语境中会发生
不期望地将 [`auto] 作为存储类说明符来解释。

[=Effect]
[:en] Deletion of semantically well-defined feature.
[:zh_CN] 删除了有良好定义语义的功能特性。

[=Difficulty]
[:en] Syntactic transformation.
[:zh_CN] 语法转换。

[=HowWide]
[:en] Rare.
[:zh_CN] 罕见。

[para:~] [#dcl.enum]

[=Change]
[:en] [=Cpp] objects of enumeration type can only be assigned values of the same
enumeration type.
[:zh_CN] [=Cpp] 的枚举类型的对象只能被赋值为相同枚举类型的值。

[:en] In C, objects of enumeration type can be assigned values of any integral
type.
[:zh_CN] 在 C 中，枚举类型的对象可以被赋值以任何整型类型的值。

[:en] Example:
[:zh_CN] 例：

[codeblock]
enum color { red, blue, green };
enum color c = 1;               // [:en] valid C, invalid [=Cpp]
                                // [|:zh_CN] C 中有效，[=Cpp] 中无效。
[codeblock:end]

[=Rationale]
[:en] The type-safe nature of [=Cpp].
[:zh_CN] [=Cpp] 的类型安全。

[=Effect]
[:en] Deletion of semantically well-defined feature.
[:zh_CN] 删除了有良好定义语义的功能特性。

[=Difficulty]
[:en] Syntactic transformation.
[:zh_CN] 语法转换。

[:en] (The type error produced by the assignment can be automatically corrected
by applying an explicit cast.)
[:zh_CN] （这种赋值所产生的类型错误可以通过实施强制转换来自动改正。）

[=HowWide]
[:en] Common.
[:zh_CN] 常见。

[para:~] [#dcl.enum]

[=Change]
[:en] In [=Cpp], the type of an enumerator is its enumeration.
[:zh_CN] 在 [=Cpp] 中，枚举符的类型为其枚举。

[:en] In C, the type of an enumerator is [`int].
[:zh_CN] 在 C 中，枚举符的类型为 [`int]。

[:en] Example:
[:zh_CN] 例：

[codeblock]
enum e { A };
sizeof(A) == sizeof(int)        // [:en] in C
                                // [|:zh_CN] 在 C 中
sizeof(A) == sizeof(e)          // [:en] in [=Cpp]
                                // [|:zh_CN] 在 [=Cpp] 中
/* [:en] and [`sizeof(int)] is not necessarily equal to [`sizeof(e)] */
/* [|:zh_CN] 并且 [`sizeof(int)] 并不一定等于 [`sizeof(e)] */
[codeblock:end]

[=Rationale]
[:en] In [=Cpp], an enumeration is a distinct type.
[:zh_CN] 在 [=Cpp] 中，枚举是独立的类型。

[=Effect]
[:en] Change to semantics of well-defined feature.
[:zh_CN] 改变了有良好定义的功能特性的语义。

[=Difficulty]
[:en] Semantic transformation.
[:zh_CN] 语义转换。

[=HowWide]
[:en] Seldom.
[:zh_CN] 少见。

[:en] The only time this affects existing C code is when the size of an
enumerator is taken.
[:zh_CN] 这项改动唯一会对现存 C 代码产生影响的情况是获取枚举符的大小的时候。

[:en] Taking the size of an enumerator is not a common C coding practice.
[:zh_CN] 而获取枚举符的大小并不是一种常见的 C 编码实践。
