[section:chapter#class
    [:en] Classes
    [:zh_CN] 类

[%:begin#class
    [:en] class
    [:zh_CN] 类
]
]

[/
\gramSec[gram.class]{Classes}
/]

[%  [:en] class[!member function][%member function [!class]]
    [:zh_CN] 类[!成员函数][%成员函数[!类]] ]

[para]
[:en]
[%[`{}][!class declaration]]
[%[`{}][!class definition]]
[%type[!class and]]
[%object[!class][%class object]]
A class is a type.
[:zh_CN]
[%[`{}][!类声明式]]
[%[`{}][!类定义式]]
[%类型[!类和～]]
[%对象[!类～][%类对象]]
类是类型。

[:en]
[%name [!class][%class name]]
Its name becomes a [~class-name] ([#class.name]) within its scope.
[:zh_CN]
[%名字 [!类][%类名]]
它的名字在其作用域中称为一个[~类名]（[#class.name]）。

[syntax]
[rule class-name [:zh_CN] 类名 ]
    [| identifier ]
    [| simple-template-id ]
[rule:end]
[syntax:end]

[:en]
A [~class-specifier] or an [~elaborated-type-specifier]s ([#dcl.type.elab]) is
used to make a [~class-name].
[:zh_CN]
[~类名]是由[~类说明符]和[~详述类型说明符]（[#dcl.type.elab]）产生的。

[:en]
An object of a class consists of a (possibly empty) sequence of members and base
class objects.
[:zh_CN]
类的对象是由其成员和基类对象的（可能为空的）序列构成的。

[syntax]
[rule class-specifier [:zh_CN] 类说明符 ]
    [| class-head [`{] [~:opt member-specification] [`}] ]
[rule:end]

[rule class-head [:zh_CN] 类头 ]
    [| class-key [~:opt attribute-specifier-seq] class-head-name
        [~:opt class-virt-specifier] [~:opt base-clause] ]
    [| class-key [~:opt attribute-specifier-seq] [~:opt base-clause] ]
[rule:end]

[rule class-head-name [:zh_CN] 类头名 ]
    [| [~:opt nested-name-specifier] class-name ]
[rule:end]

[rule class-virt-specifier [:zh_CN] 类虚说明符 ]
    [| [`final] ]
[rule:end]

[rule class-key [:zh_CN] 类关键字 ]
    [| [`class] ]
    [| [`struct] ]
    [| [`union] ]
[rule:end]
[syntax:end]

[:en]
A class declaration where the [~class-name] in the [~class-head-name] is a
[~simple-template-id] shall be an explicit specialization ([#temp.expl.spec]) or
a partial specialization ([#temp.class.spec]).
[:zh_CN]
[~类头名]中的[~类名]是个[~简单模板标识]的类声明式，应当是显式特化式
（[#temp.expl.spec]）或者部分特化式（[#temp.class.spec]）。

[:en]
A [~class-specifier] whose [~class-head] omits the [~class-head-name] defines an
unnamed class.
[:zh_CN]
在[~类头]中省略了[~类头名]的[~类说明符]，定义无名类。

[enter:note]
[:en]
An unnamed class thus can[=']t be [`final].
[:zh_CN]
因此无名类不能为 [`final]。
[exit:note]

[para]
[:en]
A [~class-name] is inserted into the scope in which it is declared immediately
after the [~class-name] is seen.
[:zh_CN]
紧跟[~类名]出现之后，该[~类名]就被插入到声明它的作用域之中。

[:en]
The [~class-name] is also inserted into the scope of the class itself; this is
known as the [+injected-class-name].
[:zh_CN]
[~类名]也被插入到该类自身的作用域之中；这被称为[+注入类名]。

[:en]
For purposes of access checking, the injected-class-name is treated as if it
were a public member name.
[:zh_CN]
当进行访问检查时，注入类名被当作如同是个公用成员名。

[:en]
A [~class-specifier] is commonly referred to as a [+class definition[%definition
[!class]]].
[:zh_CN]
[~类说明符]通常称为[+类定义式[%定义式[!类～]]。

[:en]
[%definition[!class]]
A class is considered defined after the closing brace of its [~class-specifier]
has been seen even though its member functions are in general not yet defined.
[:zh_CN]
[%定义式[!类～]]
在一个类的[~类说明符]的闭花括号出现之后，即使其成员函数一般还未被定义，这个类也
被认为是已定义的。

[:en]
The optional [~attribute-specifier-seq] appertains to the class; the attributes
in the [~attribute-specifier-seq] are thereafter considered attributes of the
class whenever it is named.
[:zh_CN]
可选的[~特性说明符序列]属于该类；随即一旦指名该类，[~特性说明符序列]中的特性标注
就被当作是该类的特性。

[para]
[:en]
If a class is marked with the [~class-virt-specifier] [`final] and it appears
as a [~class-or-decltype] in a [~base-clause] ([#class.derived]), the program is
ill-formed.
[:zh_CN]
如果一个类标有[~类虚说明符] [`final]，而它被用作[~基子句]中的一个
[~类或-decltype]（[#class.derived]），则程序非良构。

[:en]
Whenever a [~class-key] is followed by a [~class-head-name], the [~identifier]
[`final], and a colon or left brace, [`final] is interpreted as a
[~class-virt-specifier].
[:zh_CN]
一旦一个[~类关键字]后面跟着一个[~类头名]，[~标识符] [`final]，和一个冒号或者
左花括号，则 [`final] 即被解释为[~类虚说明符]。

[enter:example]
[codeblock]
struct A;
struct A final {};      // [:en] OK: definition of [`struct A],
                        // [|:zh_CN] OK：[`struct A] 的定义式
                        // [:en@~] not value-initialization of variable [`final]
                        // [|:zh_CN@~] 而不是变量 [`final] 的值初始化

struct X {
 struct C { constexpr operator int() { return 5; } };
 struct B final : C{};  // [:en] OK: definition of nested class [`B],
                        // [|:zh_CN] OK：嵌套类 [`B] 的定义式，
                        // [:en@~] not declaration of a bit-field member [`final]
                        // [|:zh_CN@~] 而不是位字段成员 [`final] 的声明式
};
[codeblock:end]
[exit:example]

[para]
[enter:note]
[:en]
Complete objects of class type have nonzero size.
[:zh_CN]
类类型的完整对象具有非零大小。

[:en]
Base class subobjects and members declared with the [`no_unique_address]
attribute ([#dcl.attr.nouniqueaddr]) are not so constrained.
[:zh_CN]
基类子对象和以 [`no_unique_address] 特性标注（[#dcl.attr.nouniqueaddr]）声明的
成员则没有这种限制。
[exit:note]

[para]
[enter:note]
[:en]
Class objects can be assigned, passed as arguments to functions, and returned by
functions (except objects of classes for which copying or moving has been
restricted; see [#class.copy]).
[:zh_CN]
类对象可以被赋值，作为实参传递给函数，或者由函数返回（但不包括限制了复制或移动
操作的类对象；参见 [#class.copy]）。

[:en]
Other plausible operators, such as equality comparison, can be defined by the
user; see [#over.oper].
[:zh_CN]
其他貌似合理的运算符，如相等性比较，可以由用户进行定义；参见 [#over.oper]。
[exit:note]

[para]
[:en]
A [+union] is a class defined with the [~class-key] [`union]; it holds at most
one data member at a time ([#class.union]).
[:zh_CN]
[+联合]是用[~类关键字] [`union] 定义的类；它一次只能保持一个数据成员
（[#class.union]）。

[enter:note]
[:en]
Aggregates of class type are described in [#dcl.init.aggr].
[:zh_CN]
类类型的聚合在 [#dcl.init.aggr] 中说明。
[exit:note]

[para]
[:en]
[%trivial class[%class[!trivial]]]
A [+trivially copyable class[%class[!trivially copyable]]] is a class that:
[:zh_CN]
[%平凡类[%类[!平凡～]]]
[+可平凡复制的类[%类[!可平凡复制的]]]是如下的类：

[list]
[item]
[:en]
where each copy constructor, move constructor, copy assignment operator, and
move assignment operator ([#class.copy], [#over.ass]) is either deleted or
trivial,
[:zh_CN]
其复制构造函数，移动构造函数，复制赋值运算符，和移动赋值运算符（[#class.copy]，
[#over.ass]）的每一个要么为弃置的，要么为平凡的，

[item]
[:en]
that has at least one non-deleted copy constructor, move constructor, copy
assignment operator, or move assignment operator, and
[:zh_CN]
具有至少一个未被弃置的复制构造函数，移动构造函数，复制赋值运算符，或者移动赋值
运算符，并且

[item]
[:en]
that has a trivial, non-deleted destructor ([#class.dtor]).
[:zh_CN]
具有平凡且非弃置的析构函数（[#over.dtor]）。
[list:end]

[:en]
A [+trivial class[%class[!trivial]]] is a class that is trivially copyable and
has one or more default constructors ([#class.ctor]), all of which are either
trivial or deleted and at least one of which is not deleted.
[:zh_CN]
[+平凡类[%类[!平凡～]]]是可平凡复制的类，且具有一个或更多的默认构造函数
（[#class.ctor]），它们均要么为平凡的，要么为弃置的，并且至少有一个未被弃置。

[enter:note]
[:en]
In particular, a trivially copyable or trivial class does not have virtual
functions or virtual base classes.
[:zh_CN]
尤其是，可平凡复制的或平凡类不能有虚函数或虚基类。
[exit:note]

[para]
[:en]
[%standard-layout[%class[!standard-layout]]]
A class [`S] is a [+standard-layout class[%class[!standard-layout]]] if it:
[:zh_CN]
[%标准布局[%类[!标准布局～]]]
如果类 [`S] 满足如下条件，则它是[+标准布局类[%类[!标准布局～]]]：

[list]
[item]
[:en] has no non-static data members of type non-standard-layout class (or
array of such types) or reference,
[:zh_CN] 没有非标准布局类（或这种类型的数组）或引用类型的非静态数据成员，

[item]
[:en] has no virtual functions ([#class.virtual]) and no virtual base classes
([#class.mi]),
[:zh_CN] 没有虚函数（[#class.virtual]），且没有虚基类（[#class.mi]），

[item]
[:en] has the same access control ([#class.access]) for all non-static data
members,
[:zh_CN] 所有非静态数据成员具有相同的访问控制（[#class.access]），

[item]
[:en] has no non-standard-layout base classes,
[:zh_CN] 没有非标准布局的基类，

[item]
[:en] has at most one base class subobject of any given type,
[:zh_CN] 最多有一个任意给定类型的基类子对象

[item]
[:en] has all non-static data members and bit-fields in the class and its base
classes first declared in the same class, and
[:zh_CN] 其类中以及任何基类中的全部非静态数据成员和位字段都首先声明与相同的类中
，以及

[item]
[:en] has no element of the set [$M([`S])] of types (defined below) as a base
class.[#:note#fn:$section.2]
[:zh_CN] 没有基类是类型集合 [$M([`S])]（定义如下）的成员。[#:note#fn:$section.2]

[note:foot#fn:$section.2]
[:en]
This ensures that two subobjects that have the same class type and that belong
to the same most derived object are not allocated at the same address
([#expr.eq]).
[:zh_CN]
这保证了具有相同类型并属于相同的全派生对象的两个子对象，不会被分配到同一个地址上
（[#expr.eq]）。
[note:end]
[list:end]

[:en]
[$M([`X])] is defined as follows:
[:zh_CN]
[$M([`X])] 这样定义：

[list]
[item]
[:en]
If [`X] is a non-union class type with no (possibly inherited
([#class.derived])) non-static data members, the set [$M([`X])] is empty.
[:zh_CN]
若 [`X] 为没有（可能继承来的（[#class.derived]））非静态数据成员的非联合类类型，
则集合 [$M([`X])] 为空。

[item]
[:en]
If [`X] is a non-union class type with a non-static data member of type
[$[`X]_0] that is either of zero size or is the first non-static data member of
[`X] (where said member may be an anonymous union), the set [$M([`X])]
consists of [$[`X]_0] and the elements of [$M([`X]_0)].
[:zh_CN]
若 [`X] 为带有一个类型为 [$[`X]_0] 的非静态数据成员的非联合类类型，且该成员要么
大小为零要么为 [`X] 的第一个非静态数据成员的类型为 [$[`X]_0]（所述成员可能
是匿名联合），则集合 [$M([`X])] 由 [$[`X]_0] 和 [$M([`X]_0)] 的元素所构成。

[item]
[:en]
If [`X] is a union type, the set [$M([`X])] is the union of all [$M([`U]_i)] and
the set containing all [$[`U]_i], where each [$[`U]_i] is the type of the [$i]th
non-static data member of [`X].
[:zh_CN]
若 [`X] 为联合类型，则集合 [$M([`X])] 为所有 [$M([`U]_i)]，以及包含所有
[$[`U]_i] 的集合的并集，其中每个 [$[`U]_i] 为 [`X] 的第 [$i] 个非静态数据成员的
类型。

[item]
[:en]
If [`X] is an array type with element type [$[`X]_e], the set [$M([`X])]
consists of [$[`X]_e] and the elements of [$M([`X]_e)].
[:zh_CN]
若 [`X] 为元素类型为 [$[`X]_e] 的数组类型，则集合 [$M([`X])] 由 [$[`X]_e] 和
[$M([`X]_e)] 的元素所构成。

[item]
[:en]
If [`X] is a non-class, non-array type, the set [$M([`X])] is empty.
[:zh_CN]
若 [`X] 为非类非数组类型，则集合 [$M([`X])] 为空。
[list:end]

[enter:note]
[:en]
[$M([`X])] is the set of the types of all non-base-class subobjects that may be
at a zero offset in [`X].
[:zh_CN]
[$M([`X])] 是 [`X] 中的所有可以处于零偏移量的非基类子对象的类型的集合。
[exit:note]

[para:~]
[enter:example]
[codeblock]
   struct B { int i; };         // [:en] standard-layout class
                                // [|:zh_CN] 标准布局类
   struct C : B { };            // [:en] standard-layout class
                                // [|:zh_CN] 标准布局类
   struct D : C { };            // [:en] standard-layout class
                                // [|:zh_CN] 标准布局类
   struct E : D { char : 4; };  // [:en] not a standard-layout class
                                // [|:zh_CN] 不是标准布局类

   struct Q {};
   struct S : Q { };
   struct T : Q { };
   struct U : S, T { };         // [:en] not a standard-layout class
                                // [|:zh_CN] 不是标准布局类
[codeblock:end]
[exit:example]

[para]
[:en]
A [+standard-layout struct[%struct[!standard-layout]]] is a standard-layout
class defined with the [~class-key] [`struct] or the [~class-key] [`class].
[:zh_CN]
[+标准布局结构[%结构[!标准布局～]]]是以[~类关键字] [`struct] 或者[~类关键字]
[`class] 定义的标准布局类。

[:en]
A [+standard-layout union[%union[!standard-layout]]] is a standard-layout class
defined with the [~class-key] [`union].
[:zh_CN]
[+标准布局联合[%联合[!标准布局～]]]是以[~类关键字] [`union] 定义的标准布局类。

[para]
[enter:note]
[:en]
Standard-layout classes are useful for communicating with code written in other
programming languages.
[:zh_CN]
标准布局类可用于与其它程序设计语言所写的代码进行通信。

[:en]
Their layout is specified in [#class.mem].
[:zh_CN]
[#class.mem] 中指定了它们的布局。
[exit:note]

[para]
[enter:example]
[codeblock]
struct N {          // [:en] neither trivial nor standard-layout
                    // [|:zh_CN] 既不是平凡的也不是标准布局的
  int i;
  int j;
  virtual ~N();
};

struct T {          // [:en] trivial but not standard-layout
                    // [|:zh_CN] 平凡的但不是标准布局的
  int i;
private: 
  int j;
};

struct SL {         // [:en] standard-layout but not trivial
                    // [|:zh_CN] 标准布局的但不是平凡的
  int i;
  int j;
  ~SL();
};

struct POD {        // [:en] both trivial and standard-layout
                    // [|:zh_CN] 既是平凡的也是标准布局的
  int i;
  int j;
};
[codeblock:end]
[exit:example]

[para]
[:en]
If a [~class-head-name] contains a [~nested-name-specifier], the
[~class-specifier] shall refer to a class that was previously declared directly
in the class or namespace to which the [~nested-name-specifier] refers, or in an
element of the inline namespace set ([#namespace.def]) of that namespace (i.e.,
not merely inherited or introduced by a [~using-declaration]), and the
[~class-specifier] shall appear in a namespace enclosing the previous
declaration.
[:zh_CN]
若[~类头名]包含[~嵌套名说明符]，则该[~类说明符]应当涉指在由该[~嵌套名说明符]所
涉指的类或命名空间中，或者在这个命名空间的内联命名空间集合（[#namespace.def]）的
某个元素之中，某个曾经直接声明过的类（就是说，并非继承来的或通过 [~using-声明式]
所引入的），并且该[~类说明符]应当出现在一个包围这个先前的声明式的命名空间中。

[:en]
In such cases, the [~nested-name-specifier] of the [~class-head-name] of the
definition shall not begin with a [~decltype-specifier].
[:zh_CN]
这些情况中，该定义式的[~类头名]的[~嵌套名说明符]不能以 [~decltype-说明符]开始。

[include class.name]

[include class.mem]

[include class.union]

[include class.local]

[%:end#class]
