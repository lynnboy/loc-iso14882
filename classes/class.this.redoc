[section#class.this
    [:en] The [`this] pointer
    [:zh_CN] [`this] 指针
[:en]
[%[`this]]
[%member function[![`this]]]
[:zh_CN]
[%[`this]]
[%成员函数[![`this]]]
]

[para]
[:en]
[%[`this] pointer[%[`this]]]
In the body of a non-static ([#class.mfct]) member function, the keyword [`this]
is a prvalue whose value is a pointer to the object for which the function is
called.
[:zh_CN]
[%[`this] 指针[%[`this]]]
在非静态成员函数（[#class.mfct]）的函数体中，关键字 [`this] 是纯右值，其值为指向
被调用了函数的对象的指针。

[:en]
[%[`this][!type of]]
The type of [`this] in a member function whose type has a [~cv-qualifier-seq]
[=cv] and whose class is [`X] is [=lq]pointer to [=cv] [`X][=rq].
[:zh_CN]
[%[`this][!～的类型]]
在类型具有 [~cv-限定符序列] [=cv] 且其类为 [`X] 的成员函数中，[`this] 的类型为
“[=cv] [`X] 的指针”。

[begin:note]
[:en]
Thus in a const member function, the object for which the function is called
is accessed through a const access path.
[:zh_CN]
在 const 成员函数中，被调用了函数的对象是通过 const 访问路径访问的。
[end:note]

[begin:example]
[codeblock]
struct s {
  int a;
  int f() const;
  int g() { return a++; }
  int h() const { return a++; } // [:en] error \
                                   [:zh_CN] 错误
};

int s::f() const { return a; }
[codeblock:end]

[:en]
The [`a++] in the body of [`s::h] is ill-formed because it tries to modify (a
part of) the object for which [`s::h()] is called.
[:zh_CN]
[`s::h] 的函数体中的 [`a++] 由于其试图改动被调用了 [`s::h()] 的对象（的一部分）
因而是非良构的。

[:en]
This is not allowed in a const member function because [`this] is a pointer
to [`const]; that is, [`*this] has [`const] type.
[:zh_CN]
这在 const 成员函数中是不允许的，因为 [`this] 是指向 [`const] 的指针；就是说，
[`*this] 具有 [`const] 类型。
[end:example]

[para]
[begin:note]
[:en]
Similarly, [`volatile] semantics ([#dcl.type.cv]) apply in volatile member
functions when accessing the object and its non-static data members.
[:zh_CN]
相似地，当访问对象及其非静态数据成员时，[`volatile] 语义（[#dcl.type.cv]）适用于
volatile 成员函数。
[end:note]

在类型具有 [~cv-限定符序列] [=cv] 且其类为 [`X] 的成员函数中，[`this] 的类型为
“[=cv] [`X] 的指针”。

[para]
[:en]
A member function whose type has a [~cv-qualifier-seq] [=cv cv1] can be called
on an object expression ([#expr.ref]) of type [=cv cv2] [`T] only if [=cv cv1]
is the same as or more cv-qualified than [=cv cv2] ([#basic.type.qualifier]).
[:zh_CN]
对于类型具有 [~cv-限定符序列] [=cv cv1] 的成员函数在类型为 [=cv cv2] [`T] 的
对象表达式上的调用（[#expr.ref]），仅当 [=cv cv1] 与 [=cv cv2] 相同或比之更被
cv 限定（[#basic.type.qualifier]）时可以进行。

[begin:example]
[codeblock]
void k(s& x, const s& y) {
  x.f();
  x.g();
  y.f();
  y.g();                        // [:en] error \
                                   [:zh_CN] 错误
}
[codeblock:end]

[:en]
The call [`y.g()] is ill-formed because [`y] is [`const] and [`s::g()] is a
non-const member function, that is, [`s::g()] is less-qualified than the
object expression [`y].
[:zh_CN]
调用 [`y.g()] 是非良构的，因为 [`y] 为 [`const] 而 [`s::g()] 却为非 const
成员函数，就是说，[`s::g()] 比对象表达式 [`y] 的限定弱。
[end:example]

[para]
[:en]
[%[`const][!constructor and]] [%[`const][!destructor and]]
[%[`volatile][!constructor and]] [%[`volatile][!destructor and]]
[:zh_CN]
[%[`const][!构造函数与～]] [%[`const][!析构函数与～]]
[%[`volatile][!构造函数与～]] [%[`volatile][!析构函数与～]]
[begin:note]
[:en]
Constructors and destructors cannot be declared [`const], [`volatile] or
[`const volatile].
[:zh_CN]
构造函数和析构函数不能被声明为 [`const]、[`volatile] 或 [`const volatile]。

[:en]
However, these functions can be invoked to create and destroy objects with
cv-qualified types; see [#class.ctor] and [#class.dtor].
[:zh_CN]
然而，可以调用这些函数以创建和销毁被 cv 限定的类型的对象；参见 [#class.ctor] 和
[#class.dtor]。
[end:note]
