[section#class.copy
    [:en] Copying and moving class objects
    [:zh_CN] 类对象的复制与移动
]

[para]
[:en]
A class object can be copied or moved in two ways: by initialization
([#class.ctor], [#dcl.init]), including for function argument passing
([#expr.call]) and for function value return ([#stmt.return]); and by assignment
([#expr.ass]).
[:zh_CN]
类对象可用两种方式进行复制或移动：通过初始化（[#class.ctor]，[#dcl.init]），包括
传递函数实参（[#expr.call]）和函数返回值（[#stmt.return]）中的初始化，以及通过
赋值（[#expr.ass]）。

[:en]
Conceptually, these two operations are implemented by a copy/move constructor
([#class.ctor]) and copy/move assignment operator ([#over.ass]).
[:zh_CN]
概念上说，这两种操作是通过复制/移动构造函数（[#class.ctor]）和复制/移动赋值
运算符（[#over.ass]）来实现的。

[para]
[:en]
[%constructor[!copy[!inaccessible]]]
[%constructor[!move[!inaccessible]]]
[%assignment operator[!copy[!inaccessible]]]
[%assignment operator[!move[!inaccessible]]]
A program is ill-formed if the copy/move constructor or the copy/move assignment
operator for an object is implicitly odr-used and the special member function
is not accessible ([#class.access]).
[:zh_CN]
[%构造函数[!复制～[!不可访问的～]]]
[%构造函数[!移动～[!不可访问的～]]]
[%赋值运算符[!复制～[!不可访问的～]]]
[%赋值运算符[!移动～[!不可访问的～]]]
如果隐式 ODR 式使用了对象的复制/移动构造函数或复制/移动赋值运算符，但该特殊成员
函数不可访问（[#class.access]），则程序非良构。

[enter:note]
[:en]
Copying/moving one object into another using the copy/move constructor or
the copy/move assignment operator does not change the layout or size of either
object.
[:zh_CN]
使用复制/移动构造函数或复制/移动赋值运算符将一个对象复制/移动给另一个对象，并不
改变任何对象的布局或大小。
[exit:note]
