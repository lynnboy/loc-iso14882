[section#range.split.outer
    [:en] Class template [`split_view::[*outer-iterator]]
    [:zh_CN] 类模板 [`split_view::[*outer-iterator]]
]

[%@lib split_view::outer-iterator]
[codeblock:synopsis]
namespace std::ranges {
  template<class V, class Pattern>
  template<bool Const>
  struct split_view<V, Pattern>::[[redoc("*>")]]outer-iterator {
  private:
    using [[redoc("*>")]]Parent =                          // [=expos]
      conditional_t<Const, const split_view, split_view>;
    using [[redoc("*>")]]Base   =                          // [=expos]
      conditional_t<Const, const V, V>;
    [[redoc("*>")]]Parent* [[redoc("*>")]]parent_ = nullptr;              // [=expos]
    iterator_t<[[redoc("*>")]]Base> [[redoc("*>")]]current_ =             // [:en] [=expos], present only if [`V] models [`:c forward_range] \
                                                                             [:zh_CN] [=expos]，仅当 [`V] 构成 [`:c forward_range] 时提供
      iterator_t<[[redoc("*>")]]Base>();

  public:
    using iterator_concept  =
      conditional_t<forward_range<[[redoc("*>")]]Base>, forward_iterator_tag, input_iterator_tag>;
    using iterator_category = input_iterator_tag;
    // [:en] [#range.split.outer.value], class [`split_view::[*outer-iterator]::value_type] \
       [:zh_CN] [#range.split.outer.value]，类 [`split_view::[*outer-iterator]::value_type]
    struct value_type;
    using difference_type   = range_difference_t<[[redoc("*>")]]Base>;

    [[redoc("*>")]]outer-iterator() = default;
    constexpr explicit [[redoc("*>")]]outer-iterator([[redoc("*>")]]Parent& parent)
      requires (!forward_range<[[redoc("*>")]]Base>);
    constexpr [[redoc("*>")]]outer-iterator([[redoc("*>")]]Parent& parent, iterator_t<[[redoc("*>")]]Base> current)
      requires forward_range<[[redoc("*>")]]Base>;
    constexpr [[redoc("*>")]]outer-iterator([[redoc("*>")]]outer-iterator<!Const> i)
      requires Const && convertible_to<iterator_t<V>, iterator_t<const V>>;

    constexpr value_type operator*() const;

    constexpr [[redoc("*>")]]outer-iterator& operator++();
    constexpr decltype(auto) operator++(int) {
      if constexpr (forward_range<[[redoc("*>")]]Base>) {
        auto tmp = *this;
        ++*this;
        return tmp;
      } else
        ++*this;
    }

    friend constexpr bool operator==(const [[redoc("*>")]]outer-iterator& x, const [[redoc("*>")]]outer-iterator& y)
      requires forward_range<[[redoc("*>")]]Base>;

    friend constexpr bool operator==(const [[redoc("*>")]]outer-iterator& x, default_sentinel_t);
  };
}
[codeblock:end]

[para]
[:en] Many of the following specifications refer to the notional member
[^current] of [*outer-iterator].
[:zh_CN] 下文的许多规范说明都涉指了 [*outer-iterator] 的概念上的成员 [^current]。
[:en] [^current] is equivalent to [*current_] if [`V] models [`:c forward_range],
and [`[*parent_]->[*current_]] otherwise.
[:zh_CN] [^current] 在 [`V] 构成 [`:c forward_range] 时等价于 [*current_]， 否则
等价于 [`[*parent_]->[*current_]]。

[%@lib@ctor split_view::outer-iterator]
[codeblock:declaration]
constexpr explicit [[redoc("*>")]]outer-iterator([[redoc("*>")]]Parent& parent)
  requires (!forward_range<[[redoc("*>")]]Base>);
[codeblock:end]

[div:description]
[para:effects]
[:en] Initializes [*parent_] with [`addressof(parent)].
[:zh_CN] 以 [`addressof(parent)] 初始化 [*parent_]。
[div:end]

[%@lib@ctor split_view::outer-iterator]
[codeblock:declaration]
constexpr [[redoc("*>")]]outer-iterator([[redoc("*>")]]Parent& parent, iterator_t<[[redoc("*>")]]Base> current)
  requires forward_range<[[redoc("*>")]]Base>;
[codeblock:end]

[div:description]
[para:effects]
[:en] Initializes [*parent_] with [`addressof(parent)] and [*current_] with
[`std::move(current)].
[:zh_CN] 以 [`addressof(parent)] 初始化 [*parent_] 并以 [`std::move(current)]
初始化 [*current_]。
[div:end]

[%@lib@ctor split_view::outer-iterator]
[codeblock:declaration]
constexpr [[redoc("*>")]]outer-iterator([[redoc("*>")]]outer-iterator<!Const> i)
  requires Const && convertible_to<iterator_t<V>, iterator_t<const V>>;
[codeblock:end]

[div:description]
[para:effects]
[:en] Initializes [*parent_] with [`i.[*parent_]] and [*current_] with
[`std::move(i.[*current_])].
[:zh_CN] 以 [`i.[*parent_]] 初始化 [*parent_] 并以 [`std::move(i.[*current_])]
初始化 [*current_]。
[div:end]

[%@lib@member operator*[!split_view::outer-iterator]]
[codeblock:declaration]
constexpr value_type operator*() const;
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to [`return value_type{*this};]
[:zh_CN] 等价于 [`return value_type{*this};]
[div:end]

[%@lib@member operator++[!split_view::outer-iterator]]
[codeblock:declaration]
constexpr [[redoc("*>")]]outer-iterator& operator++();
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to:
[:zh_CN] 等价于：
[codeblock]
const auto end = ranges::end([[redoc("*>")]]parent_->[[redoc("*>")]]base_);
if ([[redoc("*>")]]current_ == end) return *this;
const auto [pbegin, pend] = subrange{[[redoc("*>")]]parent_->[[redoc("*>")]]pattern_};
if (pbegin == pend) ++[[redoc("*>")]]current_;
else {
  do {
    auto [b, p] = ranges::mismatch(std::move([[redoc("*>")]]current_), end, pbegin, pend);
    [[redoc("*>")]]current_ = std::move(b);
    if (p == pend) {
      break;            // [:en] The pattern matched; skip it \
                        [:zh_CN] 模式已匹配；将之跳过
    }
  } while (++[[redoc("*>")]]current_ != end);
}
return *this;
[codeblock:end]
[div:end]

[%@lib@member operator==[!split_view::outer-iterator]]
[codeblock:declaration]
friend constexpr bool operator==(const [[redoc("*>")]]outer-iterator& x, const [[redoc("*>")]]outer-iterator& y)
  requires forward_range<[[redoc("*>")]]Base>;
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to: [`return x.[*current_] == y.[*current_];]
[:zh_CN] 等价于：[`return x.[*current_] == y.[*current_];]
[div:end]

[%@lib@member operator==[!split_view::outer-iterator]]
[codeblock:declaration]
friend constexpr bool operator==(const [[redoc("*>")]]outer-iterator& x, default_sentinel_t);
[codeblock:end]

[div:description]
[para:effects]
[:en] Equivalent to: [`return x.[*current_] == ranges::end(x.[*parent_]->[*base_]);]
[:zh_CN] 等价于：[`return x.[*current_] == ranges::end(x.[*parent_]->[*base_]);]
[div:end]
