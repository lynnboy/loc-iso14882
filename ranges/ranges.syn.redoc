[section#ranges.syn
    [:en] Header [`<ranges>] synopsis
    [:zh_CN] 头文件 [`<ranges>] 纲要
]

[%@hdr@def ranges]
[codeblock:synopsis]
#include <compare>              // [:en] see [#compare.syn] \
                                   [:zh_CN] 参见 [#compare.syn]
#include <initializer_list>     // [:en] see [#initializer.list.syn] \
                                   [:zh_CN] 参见 [#initializer.list.syn]
#include <iterator>             // [:en] see [#iterator.synopsis] \
                                   [:zh_CN] 参见 [#iterator.synopsis]

namespace std::ranges {
  inline namespace [[redoc("[=unspec]")]] {
    // [:en] [#range.access], range access \
       [:zh_CN] [#range.access]，范围访问
    inline constexpr [[redoc("[=unspec]")]] begin = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] end = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] cbegin = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] cend = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] rbegin = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] rend = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] crbegin = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] crend = [[redoc("[=unspec]")]];

    inline constexpr [[redoc("[=unspec]")]] size = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] ssize = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] empty = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] data = [[redoc("[=unspec]")]];
    inline constexpr [[redoc("[=unspec]")]] cdata = [[redoc("[=unspec]")]];
  }

  // [:en] [#range.range], ranges \
     [:zh_CN] [#range.range]，范围
  template<class T>
    concept range = [[redoc("[=seebelow]")]];

  template<class T>
    inline constexpr bool enable_borrowed_range = false;

  template<class T>
    concept borrowed_range = @\seebelow@;

  template<class T>
    using iterator_t = decltype(ranges::begin(declval<T&>()));
  template<[[redoc("`:c>")]]range R>
    using sentinel_t = decltype(ranges::end(declval<R&>()));
  template<[[redoc("`:c>")]]range R>
    using range_difference_t = iter_difference_t<iterator_t<R>>;
  template<[[redoc("`:c>")]]sized_range R>
    using range_size_t = decltype(ranges::size(declval<R&>()));
  template<[[redoc("`:c>")]]range R>
    using range_value_t = iter_value_t<iterator_t<R>>;
  template<[[redoc("`:c>")]]range R>
    using range_reference_t = iter_reference_t<iterator_t<R>>;
  template<[[redoc("`:c>")]]range R>
    using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<R>>;

  // [:en] [#range.sized], sized ranges \
     [:zh_CN] [#range.sized]，有大小范围
  template<class>
    inline constexpr bool disable_sized_range = false;

  template<class T>
    concept sized_range = [[redoc("[=seebelow]")]];

  // [:en] [#range.view], views \
     [:zh_CN] [#range.view]，视图
  template<class T>
    inline constexpr bool enable_view = [[redoc("[=seebelow]")]];

  struct view_base { };

  template<class T>
    concept view = [[redoc("[=seebelow]")]];

  // [:en] [#range.refinements], other range refinements \
     [:zh_CN] [#range.refinements]，其他范围精炼概念
  template<class R, class T>
    concept output_range = [[redoc("[=seebelow]")]];

  template<class T>
    concept InputRange = [[redoc("[=seebelow]")]];

  template<class T>
    concept forward_range = [[redoc("[=seebelow]")]];

  template<class T>
    concept bidirectional_range = [[redoc("[=seebelow]")]];

  template<class T>
    concept randomAccess_range = [[redoc("[=seebelow]")]];

  template<class T>
    concept contiguous_range = [[redoc("[=seebelow]")]];

  template<class T>
    concept common_range = [[redoc("[=seebelow]")]];

  template<class T>
    concept viewable_range = [[redoc("[=seebelow]")]];

  // [:en] [#view.interface], class template [`view_interface] \
     [:zh_CN] [#view.interface]，类模板 [`view_interface]
  template<class D>
    requires is_class_v<D> && [[redoc("`:c>")]]same_as<D, remove_cv_t<D>>
  class view_interface;

  // [:en] [#range.subrange], sub-ranges \
     [:zh_CN] [#range.subrange]，子范围
  enum class subrange_kind : bool { unsized, sized };

  template<[[redoc("`:c>")]]input_or_output_iterator I, [[redoc("`:c>")]]sentinel_for<I> S = I, subrange_kind K = [[redoc("[=seebelow]")]]>
    requires (K == subrange_kind::sized || ![[redoc("`:c>")]]sized_sentinel_for<S, I>)
  class subrange;

  template<input_or_output_iterator I, sentinel_for<I> S, subrange_kind K>
    inline constexpr bool enable_borrowed_range<subrange<I, S, K>> = true;

  // [:en] [#range.dangling], dangling iterator handling \
     [:zh_CN] [#range.dangling]，悬挂迭代器处理
  struct dangling;

  template<[[redoc("`:c>")]]range R>
    using borrowed_iterator_t = conditional_t<[[redoc("`:c>")]]borrowed_range<R>, iterator_t<R>, dangling>;

  template<[[redoc("`:c>")]]range R>
    using safe_subrange_t =
      conditional_t<[[redoc("`:c>")]]borrowed_range<R>, subrange<iterator_t<R>>, dangling>;

  // [:en] [#range.empty], empty view \
     [:zh_CN] [#range.empty]，空视图
  template<class T>
    requires is_object_v<T>
  class empty_view;

  template<class T>
    inline constexpr bool enable_borrowed_range<empty_view<T>> = true;

  namespace views {
    template<class T>
      inline constexpr empty_view<T> empty{};
  }

  // [:en] [#range.single], single view \
     [:zh_CN] [#range.single]，单对象视图
  template<[[redoc("`:c>")]]copy_constructible T>
    requires is_object_v<T>
  class single_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] single = [[redoc("[=unspec]")]]; }

  // [:en] [#range.iota], iota view \
     [:zh_CN] [#range.iota]，iota 视图
  template<[[redoc("`:c>")]]weakly_incrementable W, [[redoc("`:c>")]]semiregular Bound = unreachable_sentinel_t>
    requires [[redoc("*:c>")]]weakly-equality-comparable-with<W, Bound> && semiregular<W>
  class iota_view;

  template<weakly_incrementable W, semiregular Bound>
    inline constexpr bool enable_borrowed_range<iota_view<W, Bound>> = true;

  namespace views { inline constexpr [[redoc("[=unspec]")]] iota = [[redoc("[=unspec]")]]; }

  // [:en] [#range.istream], istream view \
     [:zh_CN] [#range.istream]，istream 视图
  template<movable Val, class CharT, class Traits = char_traits<CharT>>
    requires [[redoc("[=seebelow]")]]
  class basic_istream_view;
  template<class Val, class CharT, class Traits>
    basic_istream_view<Val, CharT, Traits> istream_view(basic_istream<CharT, Traits>& s);

  // [:en] [#range.all], all view \
     [:zh_CN] [#range.all]，全视图
  namespace views {
    inline constexpr [[redoc("[=unspec]")]] all = [[redoc("[=unspec]")]];

    template<[[redoc("`:c>")]]viewable_range R>
      using all_t = decltype(all(declval<R>()));
  }

  template<[[redoc("`:c>")]]range R>
    requires is_object_v<R>
  class ref_view;

  template<class T>
    inline constexpr bool enable_borrowed_range<ref_view<T>> = true;

  // [:en] [#range.filter], filter view \
     [:zh_CN] [#range.filter]，过滤视图
  template<[[redoc("`:c>")]]input_range V, [[redoc("`:c>")]]indirect_unary_predicate<iterator_t<V>> Pred>
    requires view<V> && is_object_v<Pred>
  class filter_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] filter = [[redoc("[=unspec]")]]; }

  // [:en] [#range.transform], transform view \
     [:zh_CN] [#range.transform]，变换视图
  template<[[redoc("`:c>")]]input_range V, [[redoc("`:c>")]]copy_constructible F>
    requires view<V> && is_object_v<F> &&
             regular_invocable<F&, range_reference_t<V>> &&
             [[redoc("*:c>")]]can-reference<invoke_result_t<F&, range_reference_t<V>>>
  class transform_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] transform = [[redoc("[=unspec]")]]; }

  // [:en] [#range.take], take view \
     [:zh_CN] [#range.take]，采取视图
  template<[[redoc("`:c>")]]view> class take_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] take = [[redoc("[=unspec]")]]; }

  // [:en] [#range.take.while], take while view \
     [:zh_CN] [#range.take.while]，条件采取视图
  template<[[redoc("`:c>")]]view V, class Pred>
    requires [[redoc("`:c>")]]input_range<V> && is_object_v<Pred> &&
             [[redoc("`:c>")]]indirect_unary_predicate<const Pred, iterator_t<V>>
    class take_while_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] take_while = [[redoc("[=unspec]")]]; }

  // [:en] [#range.drop], drop view \
     [:zh_CN] [#range.drop]，丢弃视图
  template<[[redoc("`:c>")]]view V>
    class drop_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] drop = [[redoc("[=unspec]")]]; }

  // [:en] [#range.drop.while], drop while view \
     [:zh_CN] [#range.drop.while]，条件丢弃视图
  template<[[redoc("`:c>")]]view V, class Pred>
    requires [[redoc("`:c>")]]input_range<V> && is_object_v<Pred> &&
             [[redoc("`:c>")]]indirect_unary_predicate<const Pred, iterator_t<V>>
    class drop_while_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] drop_while = [[redoc("[=unspec]")]]; }

  // [:en] [#range.join], join view \
     [:zh_CN] [#range.join]，联接视图
  template<[[redoc("`:c>")]]input_range V>
    requires view<V> && [[redoc("`:c>")]]input_range<range_reference_t<V>> &&
             (is_reference_v<range_reference_t<V>> ||
              view<range_value_t<V>>)
  class join_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] join = [[redoc("[=unspec]")]]; }

  // [:en] [#range.split], split view \
     [:zh_CN] [#range.split]，分割视图
  template<class R>
    concept [[redoc("*:c>")]]tiny-range = [[redoc("[=seebelow]")]];   // [=expos]

  template<[[redoc("`:c>")]]input_range V, [[redoc("`:c>")]]forward_range Pattern>
    requires view<V> && view<Pattern> &&
             [[redoc("`:c>")]]indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
             ([[redoc("`:c>")]]forward_range<V> || [[redoc("*:c>")]]tiny-range<Pattern>)
  class split_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] split = [[redoc("[=unspec]")]]; }

  // [:en] [#range.counted], counted view \
     [:zh_CN] [#range.counted]，计数视图
  namespace views { inline constexpr [[redoc("[=unspec]")]] counted = [[redoc("[=unspec]")]]; }

  // [:en] [#range.common], common view \
     [:zh_CN] [#range.common]，公共视图
  template<[[redoc("`:c>")]]view V>
    requires (!common_range<V> && copyable<iterator_t<V>>)
  class common_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] common = [[redoc("[=unspec]")]]; }

  // [:en] [#range.reverse], reverse view \
     [:zh_CN] [#range.reverse]，逆向视图
  template<[[redoc("`:c>")]]view V>
    requires [[redoc("`:c>")]]bidirectional_range<V>
  class reverse_view;

  namespace views { inline constexpr [[redoc("[=unspec]")]] reverse = [[redoc("[=unspec]")]]; }

  // [:en] [#range.elements], elements view \
     [:zh_CN] [#range.elements]，元素视图
  template<[[redoc("`:c>")]]input_range V, size_t N>
    requires [[redoc("[=seebelow]")]]
  class elements_view;

  template<class R>
    using keys_view = elements_view<views::all_t<R>, 0>;
  template<class R>
    using values_view = elements_view<views::all_t<R>, 1>;

  namespace views {
    template<size_t N>
      inline constexpr [[redoc("[=unspec]")]] elements = [[redoc("[=unspec]")]] ;
    inline constexpr auto keys = elements<0>;
    inline constexpr auto values = elements<1>;
  }
}

namespace std {
  namespace views = ranges::views;

  template<class I, class S, ranges::subrange_kind K>
  struct tuple_size<ranges::subrange<I, S, K>>
    : integral_constant<size_t, 2> {};
  template<class I, class S, ranges::subrange_kind K>
  struct tuple_element<0, ranges::subrange<I, S, K>> {
    using type = I;
  };
  template<class I, class S, ranges::subrange_kind K>
  struct tuple_element<1, ranges::subrange<I, S, K>> {
    using type = S;
  };
  template<class I, class S, ranges::subrange_kind K>
  struct tuple_element<0, const ranges::subrange<I, S, K>> {
    using type = I;
  };
  template<class I, class S, ranges::subrange_kind K>
  struct tuple_element<1, const ranges::subrange<I, S, K>> {
    using type = S;
  };
}
[codeblock:end]

[para]
[%[*to-unsigned-like]]
[%[*make-unsigned-like-t]]
[:en] Within this Clause, for an integer-like type [`X] ([#iterator.concept.winc]),
[`[^make-unsigned-like-t]<X>] denotes [`make_unsigned_t<X>] if [`X] is an
integer type; otherwise, it denotes a corresponding unspecified
unsigned-integer-like type of the same width as [`X].
[:zh_CN] 本章中，对于整数式类型 [`X]（[#iterator.concept.winc]），当 [`X] 为整数
类型时，[`[^make-unsigned-like-t]<X>] 代表 [`make_unsigned_t<X>]；否则代表与
[`X] 具有相同宽度的某个未指明的对应无符号整数式类型。

[:en] For an expression [`x] of type [`X], [`[^to-unsigned-like](x)] is [`x]
explicitly converted to [`[^make-unsigned-like-t]<X>].
[:zh_CN] 对于 [`X] 类型的表达式 [`x]，[`[^to-unsigned-like](x)] 为 [`x] 显式转换
到 [`[^make-unsigned-like-t]<X>]。
