[section#range.subrange
    [:en] Sub-ranges
    [:zh_CN] 子视图
]

[para]
[:en] The [`subrange] class template combines together an iterator and
a sentinel into a single object that models the [`:c view] concept.
[:zh_CN] 类模板 [`subrange] 将迭代器和哨位的接口组合为一个构成了 [`:c view] 概念
的单个对象。

[:en] Additionally, it models the [`:c sized_range] concept when the final
template parameter is [`subrange_kind::sized].
[:zh_CN] 此外，当最后一个模板形参为 [`subrange_kind::sized] 时，它还构成
[`:c sized_range] 概念。

[%@lib subrange]
[codeblock:synopsis]
namespace std::ranges {
  template<class T>
    concept [[redoc("*:c@def>")]]pair-like =                                    // [=expos]
      !is_reference_v<T> && requires(T t) {
        typename tuple_size<T>::type;   // [:en] ensures [`tuple_size<T>] is complete \
                                           [:zh_CN] 确保 [`tuple_size<T>] 是完整的
        requires derived_from<tuple_size<T>, integral_constant<size_t, 2>>;
        typename tuple_element_t<0, remove_const_t<T>>;
        typename tuple_element_t<1, remove_const_t<T>>;
        { get<0>(t) } -> convertible_to<const tuple_element_t<0, T>&>;
        { get<1>(t) } -> convertible_to<const tuple_element_t<1, T>&>;
      };

  template<class T, class U, class V>
    concept [[redoc("*:c@def>")]]pair-like-convertible-to =                     // [=expos]
      !range<T> && [*pair-like]<remove_reference_t<T>> &&
      requires(T&& t) {
        { get<0>(std::forward<T>(t)) } -> convertible_to<U>;
        { get<1>(std::forward<T>(t)) } -> convertible_to<V>;
      };

  template<class T, class U, class V>
    concept [[redoc("*:c@def>")]]pair-like-convertible-from =                   // [=expos]
      !range<T> && [*pair-like]<T> && constructible_from<T, U, V>;

  template<class T>
    concept [[redoc("*:c@def>")]]iterator-sentinel-pair =                       // [=expos]
      !range<T> && [[redoc("*:c>")]]pair-like<T> &&
      sentinel_for<tuple_element_t<1, T>, tuple_element_t<0, T>>;

  template<input_or_output_iterator I, sentinel_for<I> S = I, subrange_kind K =
      sized_sentinel_for<S, I> ? subrange_kind::sized : subrange_kind::unsized>
    requires (K == subrange_kind::sized || !sized_sentinel_for<S, I>)
  class subrange : public view_interface<subrange<I, S, K>> {
  private:
    static constexpr bool StoreSize =                           // [=expos]
      K == subrange_kind::sized && !sized_sentinel_for<S, I>;
    I begin_ = I();                                             // [=expos]
    S end_ = S();                                               // [=expos]
    [[redoc("^>")]]make-unsigned-like-t(iter_difference_t<I>) size_ = 0;  // [:en] [=expos]; present only \
                                                                                  [:zh_CN] [=expos]；仅当 [`StoreSize] 为
                                                                // [:en@~] when [`StoreSize] is [`true] \
                                                                   [:zh_CN@~] [`true] 时提供
  public:
    subrange() = default;

    constexpr subrange(I i, S s) requires (!StoreSize);

    constexpr subrange(I i, S s, [[redoc("^>")]]make-unsigned-like-t(iter_difference_t<I>) n)
      requires (K == subrange_kind::sized);

    template<[[redoc("*:c>")]]not-same-as<subrange> R>
      requires [[redoc("*:c>")]]forwarding-range<R> &&
        convertible_to<iterator_t<R>, I> && convertible_to<sentinel_t<R>, S>
    constexpr subrange(R&& r) requires (!StoreSize || sized_range<R>);

    template<[[redoc("*:c>")]]forwarding-range R>
      requires convertible_to<iterator_t<R>, I> && convertible_to<sentinel_t<R>, S>
    constexpr subrange(R&& r, [[redoc("^>")]]make-unsigned-like-t(iter_difference_t<I>) n)
      requires (K == subrange_kind::sized)
        : subrange{ranges::begin(r), ranges::end(r), n}
    {}

    template<[[redoc("*:c>")]]not-same-as<subrange> PairLike>
      requires [[redoc("*:c>")]]pair-like-convertible-to<PairLike, I, S>
    constexpr subrange(PairLike&& r) requires (!StoreSize)
      : subrange{std::get<0>(std::forward<PairLike>(r)),
                 std::get<1>(std::forward<PairLike>(r))}
    {}

    template<[[redoc("*:c>")]]pair-like-convertible-to<I, S> PairLike>
    constexpr subrange(PairLike&& r, [[redoc("^>")]]make-unsigned-like-t(iter_difference_t<I>) n)
      requires (K == subrange_kind::sized)
      : subrange{std::get<0>(std::forward<PairLike>(r)),
                 std::get<1>(std::forward<PairLike>(r)), n}
    {}

    template<[[redoc("*:c>")]]not-same-as<subrange> PairLike>
      requires [[redoc("*:c>")]]pair-like-convertible-from<PairLike, const I&, const S&>
    constexpr operator PairLike() const;

    constexpr I begin() const;
    constexpr S end() const;

    constexpr bool empty() const;
    constexpr [[redoc("^>")]]make-unsigned-like-t(iter_difference_t<I>) size() const
      requires (K == subrange_kind::sized);

    [[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) const;
    [[nodiscard]] constexpr subrange prev(iter_difference_t<I> n = 1) const
      requires bidirectional_iterator<I>;
    constexpr subrange& advance(iter_difference_t<I> n);

    friend constexpr I begin(subrange&& r) { return r.begin(); }
    friend constexpr S end(subrange&& r) { return r.end(); }
  };

  template<input_or_output_iterator I, sentinel_for<I> S>
    subrange(I, S, [[redoc("^>")]]make-unsigned-like-t(iter_difference_t<I>)) ->
      subrange<I, S, subrange_kind::sized>;

  template<[[redoc("^>")]]iterator-sentinel-pair P>
    subrange(P) -> subrange<tuple_element_t<0, P>, tuple_element_t<1, P>>;

  template<[[redoc("^>")]]iterator-sentinel-pair P>
    subrange(P, [[redoc("^>")]]make-unsigned-like-t(iter_difference_t<tuple_element_t<0, P>>)) ->
      subrange<tuple_element_t<0, P>, tuple_element_t<1, P>, subrange_kind::sized>;

  template<[[redoc("^>")]]forwarding-range R>
    subrange(R&&) ->
      subrange<iterator_t<R>, sentinel_t<R>,
               (sized_range<R> || sized_sentinel_for<sentinel_t<R>, iterator_t<R>>)
                 ? subrange_kind::sized : subrange_kind::unsized>;

  template<[[redoc("^>")]]forwarding-range R>
    subrange(R&&, [[redoc("^>")]]make-unsigned-like-t(range_difference_t<R>)) ->
      subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized>;

  template<size_t N, class I, class S, subrange_kind K>
    requires (N < 2)
  constexpr auto get(const subrange<I, S, K>& r);
}

namespace std {
  using ranges::get;
}
[codeblock:end]

[include range.subrange.ctor]

[include range.subrange.access]
