[section#range.split.view
    [:en] Class template [`split_view]
    [:zh_CN] 类模板 [`split_view]
]

[%@lib split_view]
[%@lib@member base[!split_view]]
[%@lib@member begin[!split_view]]
[%@lib@member end[!split_view]]
[codeblock:synopsis]
namespace std::ranges {
  template<auto> struct [[redoc("*>")]]require-constant;       // [=expos]

  template<class R>
  concept [[redoc("*:c@def>")]]tiny-range =                          // [=expos]
    sized_range<R> &&
    requires { typename [[redoc("*>")]]require-constant<remove_reference_t<R>::size()>; } &&
    (remove_reference_t<R>::size() <= 1);

  template<input_range V, forward_range Pattern>
    requires view<V> && view<Pattern> &&
             indirectly_comparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to> &&
             (forward_range<V> || [[redoc("*:c>")]]tiny-range<Pattern>)
  class split_view : public view_interface<split_view<V, Pattern>> {
  private:
    V [[redoc("*>")]]base_ = V();                              // [=expos]
    Pattern [[redoc("*>")]]pattern_ = Pattern();               // [=expos]
    iterator_t<V> [[redoc("*>")]]current_ = iterator_t<V>();   // [:en] [=expos], present only if [`!forward_range<V>] \
                                                               [:zh_CN] [=expos]，仅当 [`!forward_range<V>] 时给出
    // [:en] [#range.split.outer], class template [`split_view::[*outer-iterator]] \
       [:zh_CN] [#range.split.outer]，类模板 [`split_view::[*outer-iterator]]
    template<bool> struct [[redoc("*>")]]outer-iterator;       // [=expos]
    // [:en] [#range.split.inner], class template [`split_view::[*inner-iterator]] \
       [:zh_CN] [#range.split.inner]，类模板 [`split_view::[*inner-iterator]]
    template<bool> struct [[redoc("*>")]]inner-iterator;       // [=expos]
  public:
    split_view() = default;
    constexpr split_view(V base, Pattern pattern);

    template<input_range R, forward_range P>
      requires constructible_from<V, all_view<R>> &&
               constructible_from<Pattern, all_view<P>>
    constexpr split_view(R&& r, P&& p);

    template<input_range R>
      requires constructible_from<V, all_view<R>> &&
               constructible_from<Pattern, single_view<range_value_t<R>>>
    constexpr split_view(R&& r, range_value_t<R> e);

    constexpr V base() const& requires copy_constructible<V> { return [[redoc("*>")]]base_; }
    constexpr V base() && { return std::move([[redoc("*>")]]base_); }

    constexpr auto begin() {
      if constexpr (forward_range<V>)
        return [[redoc("*>")]]outer-iterator<[[redoc("^>")]]simple-view<V>>{*this, ranges::begin([[redoc("*>")]]base_)};
      else {
        [[redoc("*>")]]current_ = ranges::begin([[redoc("*>")]]base_);
        return [[redoc("*>")]]outer-iterator<false>{*this};
      }
    }

    constexpr auto begin() const requires forward_range<V> && forward_range<const V> {
      return [[redoc("*>")]]outer-iterator<true>{*this, ranges::begin([[redoc("*>")]]base_)};
    }

    constexpr auto end() requires forward_range<V> && common_range<V> {
      return [[redoc("*>")]]outer-iterator<[[redoc("^>")]]simple-view<V>>{*this, ranges::end([[redoc("*>")]]base_)};
    }

    constexpr auto end() const {
      if constexpr (forward_range<V> && forward_range<const V> && common_range<const V>)
        return [[redoc("*>")]]outer-iterator<true>{*this, ranges::end([[redoc("*>")]]base_)};
      else
        return default_sentinel;
    }
  };

  template<class R, class P>
    split_view(R&&, P&&) -> split_view<all_view<R>, all_view<P>>;

  template<input_range R>
    split_view(R&&, range_value_t<R>)
      -> split_view<all_view<R>, single_view<range_value_t<R>>>;
}
[codeblock:end]

[%@lib@ctor split_view]
[codeblock:declaration]
constexpr split_view(V base, Pattern pattern);
[codeblock:end]

[div:description]
[para:effects]
[:en] Initializes [*base_] with [`std::move(base)], and [*pattern_] with
[`std::move(pattern)].
[:zh_CN] 以 [`std::move(base)] 初始化 [*base_] 并以 [`std::move(pattern)] 初始化
[*pattern_]。
[div:end]

[%@lib@ctor split_view]
[codeblock:declaration]
template<input_range R, forward_range P>
  requires constructible_from<V, all_view<R>> &&
           constructible_from<Pattern, all_view<P>>
constexpr split_view(R&& r, P&& p);
[codeblock:end]

[div:description]
[para:effects]
[:en] Initializes [*base_] with [`views::all(std::forward<R>(r))] and [*pattern_]
with [`views::all(std::forward<P>(p))].
[:zh_CN] 以 [`views::all(std::forward<R>(r))] 初始化 [*base_] 并以
[`views::all(std::forward<P>(p))] 初始化 [*pattern_]。
[div:end]

[%@lib@ctor split_view]
[codeblock:declaration]
template<input_range R>
  requires constructible_from<V, all_view<R>> &&
           constructible_from<Pattern, single_view<range_value_t<R>>>
constexpr split_view(R&& r, range_value_t<R> e);
[codeblock:end]

[div:description]
[para:effects]
[:en] Initializes [*base_] with [`views::all(std::forward<R>(r))] and [*pattern_]
with [`single_view{std::move(e)}].
[:zh_CN] 以 [`views::all(std::forward<R>(r))] 初始化 [*base_] 并以
[`single_view{std::move(e)}] 初始化 [*pattern_]。
[div:end]
