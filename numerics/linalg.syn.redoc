[section#linalg
    [:en] Header [`<linalg>] synopsis
    [:zh_CN] 头文件 [`<linalg>] 纲要
]

[codeblock:synopsis]
namespace std::linalg {
  // [:en] [#linalg.tags.order], storage order tags \
  [:zh_CN] [#linalg.tags.order]，存储顺序标签
  struct column_major_t;
  inline constexpr column_major_t column_major;
  struct row_major_t;
  inline constexpr row_major_t row_major;

  // [:en] [#linalg.tags.triangle], triangle tags \
  [:zh_CN] [#linalg.tags.triangle]，三角形标签
  struct upper_triangle_t;
  inline constexpr upper_triangle_t upper_triangle;
  struct lower_triangle_t;
  inline constexpr lower_triangle_t lower_triangle;

  // [:en] [#linalg.tags.diagonal], diagonal tags \
  [:zh_CN] [#linalg.tags.diagonal]，对角线标签
  struct implicit_unit_diagonal_t;
  inline constexpr implicit_unit_diagonal_t implicit_unit_diagonal;
  struct explicit_diagonal_t;
  inline constexpr explicit_diagonal_t explicit_diagonal;

  // [:en] [#linalg.layout.packed], class template [`layout_blas_packed] \
  [:zh_CN] [#linalg.layout.packed]，类模板 [`layout_blas_packed]
  template<class Triangle, class StorageOrder>
    class layout_blas_packed;

  // [:en] [#linalg.helpers], exposition-only helpers \
  [:zh_CN] [#linalg.helpers]，仅用于阐释的辅助项

  // [:en] [#linalg.helpers.concepts], linear algebra argument concepts \
  [:zh_CN] [#linalg.helpers.concepts]，线性代数实参概念
  template<class T>
    constexpr bool [[redoc("*>")]]is-mdspan = [[redoc("[=seebelow]")]];               // [=expos]

  template<class T>
    concept [[redoc("*:c>")]]in-vector = [[redoc("[=seebelow]")]];                      // [=expos]

  template<class T>
    concept [[redoc("*:c>")]]out-vector = [[redoc("[=seebelow]")]];                     // [=expos]

  template<class T>
    concept [[redoc("*:c>")]]inout-vector = [[redoc("[=seebelow]")]];                   // [=expos]

  template<class T>
    concept [[redoc("*:c>")]]in-matrix = [[redoc("[=seebelow]")]];                      // [=expos]

  template<class T>
    concept [[redoc("*:c>")]]out-matrix = [[redoc("[=seebelow]")]];                     // [=expos]

  template<class T>
    concept [[redoc("*:c>")]]inout-matrix = [[redoc("[=seebelow]")]];                   // [=expos]

  template<class T>
    concept [[redoc("*:c>")]]possibly-packed-inout-matrix = [[redoc("[=seebelow]")]];   // [=expos]

  template<class T>
    concept [[redoc("*:c>")]]in-object = [[redoc("[=seebelow]")]];                      // [=expos]

  template<class T>
    concept [[redoc("*:c>")]]out-object = [[redoc("[=seebelow]")]];                     // [=expos]

  template<class T>
    concept [[redoc("*:c>")]]inout-object = [[redoc("[=seebelow]")]];                   // [=expos]

  // [:en] [#linalg.scaled], scaled in-place transformation \
  [:zh_CN] [#linalg.scaled]，缩放原位变换

  // [:en] [#linalg.scaled.scaledaccessor], class template [`scaled_accessor] \
  [:zh_CN] [#linalg.scaled.scaledaccessor]，类模板 [`scaled_accessor]
  template<class ScalingFactor, class NestedAccessor>
    class scaled_accessor;

  // [:en] [#linalg.scaled.scaled], function template [`scaled] \
  [:zh_CN] [#linalg.scaled.scaled]，函数模板 [`scaled]
  template<class ScalingFactor,
           class ElementType, class Extents, class Layout, class Accessor>
    constexpr auto scaled(ScalingFactor alpha, mdspan<ElementType, Extents, Layout, Accessor> x);

  // [:en] [#linalg.conj], conjugated in-place transformation \
  [:zh_CN] [#linalg.conj]，共轭原位变换

  // [:en] [#linalg.conj.conjugatedaccessor], class template [`conjugated_accessor] \
  [:zh_CN] [#linalg.conj.conjugatedaccessor]，类模板 [`conjugated_accessor]
  template<class NestedAccessor>
    class conjugated_accessor;

  // [:en] [#linalg.conj.conjugated], function template [`conjugated] \
  [:zh_CN] [#linalg.conj.conjugated]，函数模板 [`conjugated]
  template<class ElementType, class Extents, class Layout, class Accessor>
    constexpr auto conjugated(mdspan<ElementType, Extents, Layout, Accessor> a);

  // [:en] [#linalg.transp], transpose in-place transformation \
  [:zh_CN] [#linalg.transp]，转置原位变换

  // [:en] [#linalg.transp.layout.transpose], class template [`layout_transpose] \
  [:zh_CN] [#linalg.transp.layout.transpose]，类模板 [`layout_transpose]
  template<class Layout>
    class layout_transpose;

  // [:en] [#linalg.transp.transposed], function template [`transposed] \
  [:zh_CN] [#linalg.transp.transposed]，函数模板 [`transposed]
  template<class ElementType, class Extents, class Layout, class Accessor>
    constexpr auto transposed(mdspan<ElementType, Extents, Layout, Accessor> a);

  // [:en] [#linalg.conjtransposed], conjugated transpose in-place transformation \
  [:zh_CN] [#linalg.conjtransposed]，共轭转置原位变换
  template<class ElementType, class Extents, class Layout, class Accessor>
    constexpr auto conjugate_transposed(mdspan<ElementType, Extents, Layout, Accessor> a);

  // [:en] [#linalg.algs.blas1], BLAS 1 algorithms \
  [:zh_CN] [#linalg.algs.blas1]，BLAS 1 算法

  // [:en] [#linalg.algs.blas1.givens], Givens rotations \
  [:zh_CN] [#linalg.algs.blas1.givens]，吉文斯旋转

  // [:en] [#linalg.algs.blas1.givens.lartg], compute Givens rotation \
  [:zh_CN] [#linalg.algs.blas1.givens.lartg]，计算吉文斯旋转

  template<class Real>
    struct setup_givens_rotation_result {
      Real c;
      Real s;
      Real r;
    };
  template<class Real>
    struct setup_givens_rotation_result<complex<Real>> {
      Real c;
      complex<Real> s;
      complex<Real> r;
    };

  template<class Real>
    setup_givens_rotation_result<Real> setup_givens_rotation(Real a, Real b) noexcept;

  template<class Real>
    setup_givens_rotation_result<complex<Real>>
      setup_givens_rotation(complex<Real> a, complex<Real> b) noexcept;

  // [:en] [#linalg.algs.blas1.givens.rot], apply computed Givens rotation \
  [:zh_CN] [#linalg.algs.blas1.givens.rot]，运用计算的吉文斯旋转
  template<[[redoc("*:c>")]]inout-vector InOutVec1, [[redoc("*:c>")]]inout-vector InOutVec2, class Real>
    void apply_givens_rotation(InOutVec1 x, InOutVec2 y, Real c, Real s);
  template<class ExecutionPolicy, [[redoc("*:c>")]]inout-vector InOutVec1, [[redoc("*:c>")]]inout-vector InOutVec2, class Real>
    void apply_givens_rotation(ExecutionPolicy&& exec,
                               InOutVec1 x, InOutVec2 y, Real c, Real s);
  template<[[redoc("*:c>")]]inout-vector InOutVec1, [[redoc("*:c>")]]inout-vector InOutVec2, class Real>
    void apply_givens_rotation(InOutVec1 x, InOutVec2 y, Real c, complex<Real> s);
  template<class ExecutionPolicy, [[redoc("*:c>")]]inout-vector InOutVec1, [[redoc("*:c>")]]inout-vector InOutVec2, class Real>
    void apply_givens_rotation(ExecutionPolicy&& exec,
                               InOutVec1 x, InOutVec2 y, Real c, complex<Real> s);

  // [:en] [#linalg.algs.blas1.swap], swap elements \
  [:zh_CN] [#linalg.algs.blas1.swap]，交换元素
  template<[[redoc("*:c>")]]inout-object InOutObj1, [[redoc("*:c>")]]inout-object InOutObj2>
    void swap_elements(InOutObj1 x, InOutObj2 y);
  template<class ExecutionPolicy, [[redoc("*:c>")]]inout-object InOutObj1, [[redoc("*:c>")]]inout-object InOutObj2>
    void swap_elements(ExecutionPolicy&& exec,
                       InOutObj1 x, InOutObj2 y);

  // [:en] [#linalg.algs.blas1.scal], multiply elements by scalar \
  [:zh_CN] [#linalg.algs.blas1.scal]，元素乘以标量
  template<class Scalar, [[redoc("*:c>")]]inout-object InOutObj>
    void scale(Scalar alpha, InOutObj x);
  template<class ExecutionPolicy, class Scalar, [[redoc("*:c>")]]inout-object InOutObj>
    void scale(ExecutionPolicy&& exec,
               Scalar alpha, InOutObj x);

  // [:en] [#linalg.algs.blas1.copy], copy elements \
  [:zh_CN] [#linalg.algs.blas1.copy]，复制元素
  template<[[redoc("*:c>")]]in-object InObj, [[redoc("*:c>")]]out-object OutObj>
    void copy(InObj x, OutObj y);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-object InObj, [[redoc("*:c>")]]out-object OutObj>
    void copy(ExecutionPolicy&& exec,
              InObj x, OutObj y);

  // [:en] [#linalg.algs.blas1.add], add elementwise \
  [:zh_CN] [#linalg.algs.blas1.add]，逐元素加法
  template<[[redoc("*:c>")]]in-object InObj1, [[redoc("*:c>")]]in-object InObj2, [[redoc("*:c>")]]out-object OutObj>
    void add(InObj1 x, InObj2 y, OutObj z);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-object InObj1, [[redoc("*:c>")]]in-object InObj2, [[redoc("*:c>")]]out-object OutObj>
    void add(ExecutionPolicy&& exec,
             InObj1 x, InObj2 y, OutObj z);

  // [:en] [#linalg.algs.blas1.dot], dot product of two vectors \
  [:zh_CN] [#linalg.algs.blas1.dot]，两个向量的点积
  template<[[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, class Scalar>
    Scalar dot(InVec1 v1, InVec2 v2, Scalar init);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, class Scalar>
    Scalar dot(ExecutionPolicy&& exec,
               InVec1 v1, InVec2 v2, Scalar init);
  template<[[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2>
    auto dot(InVec1 v1, InVec2 v2);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2>
    auto dot(ExecutionPolicy&& exec,
             InVec1 v1, InVec2 v2);

  template<[[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, class Scalar>
    Scalar dotc(InVec1 v1, InVec2 v2, Scalar init);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, class Scalar>
    Scalar dotc(ExecutionPolicy&& exec,
                InVec1 v1, InVec2 v2, Scalar init);
  template<[[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2>
    auto dotc(InVec1 v1, InVec2 v2);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2>
    auto dotc(ExecutionPolicy&& exec,
              InVec1 v1, InVec2 v2);

  // [:en] [#linalg.algs.blas1.ssq], scaled sum of squares of a vector[=']s elements \
  [:zh_CN] [#linalg.algs.blas1.ssq]，缩放的向量元素平方和
  template<class Scalar>
    struct sum_of_squares_result {
      Scalar scaling_factor;
      Scalar scaled_sum_of_squares;
    };
  template<[[redoc("*:c>")]]in-vector InVec, class Scalar>
    sum_of_squares_result<Scalar>
      vector_sum_of_squares(InVec v, sum_of_squares_result<Scalar> init);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec, class Scalar>
    sum_of_squares_result<Scalar>
      vector_sum_of_squares(ExecutionPolicy&& exec,
                            InVec v, sum_of_squares_result<Scalar> init);

  // [:en] [#linalg.algs.blas1.nrm2], Euclidean norm of a vector \
  [:zh_CN] [#linalg.algs.blas1.nrm2]，向量的欧式范数
  template<[[redoc("*:c>")]]in-vector InVec, class Scalar>
    Scalar vector_two_norm(InVec v, Scalar init);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec, class Scalar>
    Scalar vector_two_norm(ExecutionPolicy&& exec, InVec v, Scalar init);
  template<[[redoc("*:c>")]]in-vector InVec>
    auto vector_two_norm(InVec v);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec>
    auto vector_two_norm(ExecutionPolicy&& exec, InVec v);

  // [:en] [#linalg.algs.blas1.asum], sum of absolute values of vector elements \
  [:zh_CN] [#linalg.algs.blas1.asum]，向量元素的绝对值和
  template<[[redoc("*:c>")]]in-vector InVec, class Scalar>
    Scalar vector_abs_sum(InVec v, Scalar init);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec, class Scalar>
    Scalar vector_abs_sum(ExecutionPolicy&& exec, InVec v, Scalar init);
  template<[[redoc("*:c>")]]in-vector InVec>
    auto vector_abs_sum(InVec v);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec>
    auto vector_abs_sum(ExecutionPolicy&& exec, InVec v);

  // [:en] [#linalg.algs.blas1.iamax], index of maximum absolute value of vector elements \
  [:zh_CN] [#linalg.algs.blas1.iamax]，向量元素中最大绝对值的索引
  template<[[redoc("*:c>")]]in-vector InVec>
    typename InVec::extents_type vector_idx_abs_max(InVec v);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec>
    typename InVec::extents_type vector_idx_abs_max(ExecutionPolicy&& exec, InVec v);

  // [:en] [#linalg.algs.blas1.matfrobnorm], Frobenius norm of a matrix \
  [:zh_CN] [#linalg.algs.blas1.matfrobnorm]，矩阵的弗罗贝尼乌斯范数
  template<[[redoc("*:c>")]]in-matrix InMat, class Scalar>
    Scalar matrix_frob_norm(InMat A, Scalar init);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat, class Scalar>
    Scalar matrix_frob_norm(ExecutionPolicy&& exec, InMat A, Scalar init);
  template<[[redoc("*:c>")]]in-matrix InMat>
    auto matrix_frob_norm(InMat A);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat>
    auto matrix_frob_norm(ExecutionPolicy&& exec, InMat A);

  // [:en] [#linalg.algs.blas1.matonenorm], one norm of a matrix \
  [:zh_CN] [#linalg.algs.blas1.matonenorm]，矩阵的 1-范数
  template<[[redoc("*:c>")]]in-matrix InMat, class Scalar>
    Scalar matrix_one_norm(InMat A, Scalar init);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat, class Scalar>
    Scalar matrix_one_norm(ExecutionPolicy&& exec, InMat A, Scalar init);
  template<[[redoc("*:c>")]]in-matrix InMat>
    auto matrix_one_norm(InMat A);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat>
    auto matrix_one_norm(ExecutionPolicy&& exec, InMat A);

  // [:en] [#linalg.algs.blas1.matinfnorm], infinity norm of a matrix \
  [:zh_CN] [#linalg.algs.blas1.matinfnorm]，矩阵的 ∞-范数
  template<[[redoc("*:c>")]]in-matrix InMat, class Scalar>
    Scalar matrix_inf_norm(InMat A, Scalar init);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat, class Scalar>
    Scalar matrix_inf_norm(ExecutionPolicy&& exec, InMat A, Scalar init);
  template<[[redoc("*:c>")]]in-matrix InMat>
    auto matrix_inf_norm(InMat A);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat>
    auto matrix_inf_norm(ExecutionPolicy&& exec, InMat A);

  // [:en] [#linalg.algs.blas2], BLAS 2 algorithms \
  [:zh_CN] [#linalg.algs.blas2]，BLAS 2 算法

  // [:en] [#linalg.algs.blas2.gemv], general matrix-vector product \
  [:zh_CN] [#linalg.algs.blas2.gemv]，一般矩阵-向量相乘
  template<[[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]out-vector OutVec>
    void matrix_vector_product(InMat A, InVec x, OutVec y);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]out-vector OutVec>
    void matrix_vector_product(ExecutionPolicy&& exec,
                               InMat A, InVec x, OutVec y);
  template<[[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, [[redoc("*:c>")]]out-vector OutVec>
    void matrix_vector_product(InMat A, InVec1 x, InVec2 y, OutVec z);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, [[redoc("*:c>")]]out-vector OutVec>
    void matrix_vector_product(ExecutionPolicy&& exec,
                               InMat A, InVec1 x, InVec2 y, OutVec z);

  // [:en] [#linalg.algs.blas2.symv], symmetric matrix-vector product \
  [:zh_CN] [#linalg.algs.blas2.symv]，对称矩阵-向量相乘
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]out-vector OutVec>
    void symmetric_matrix_vector_product(InMat A, Triangle t, InVec x, OutVec y);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]out-vector OutVec>
    void symmetric_matrix_vector_product(ExecutionPolicy&& exec,
                                         InMat A, Triangle t, InVec x, OutVec y);
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2,
           [[redoc("*:c>")]]out-vector OutVec>
    void symmetric_matrix_vector_product(InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2,
           [[redoc("*:c>")]]out-vector OutVec>
    void symmetric_matrix_vector_product(ExecutionPolicy&& exec,
                                         InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);

  // [:en] [#linalg.algs.blas2.hemv], Hermitian matrix-vector product \
  [:zh_CN] [#linalg.algs.blas2.hemv]，厄米共轭矩阵-向量相乘
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]out-vector OutVec>
    void hermitian_matrix_vector_product(InMat A, Triangle t, InVec x, OutVec y);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]out-vector OutVec>
    void hermitian_matrix_vector_product(ExecutionPolicy&& exec,
                                         InMat A, Triangle t, InVec x, OutVec y);
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2,
           [[redoc("*:c>")]]out-vector OutVec>
    void hermitian_matrix_vector_product(InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2,
           [[redoc("*:c>")]]out-vector OutVec>
    void hermitian_matrix_vector_product(ExecutionPolicy&& exec,
                                         InMat A, Triangle t, InVec1 x, InVec2 y, OutVec z);

  // [:en] [#linalg.algs.blas2.trmv], triangular matrix-vector product \
  [:zh_CN] [#linalg.algs.blas2.trmv]，三角矩阵-向量相乘

  // [:en] Overwriting triangular matrix-vector product \
  [:zh_CN] 覆写的三角矩阵-向量相乘
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]in-vector InVec,
           [[redoc("*:c>")]]out-vector OutVec>
    void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d, InVec x,
                                          OutVec y);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]in-vector InVec,
           [[redoc("*:c>")]]out-vector OutVec>
    void triangular_matrix_vector_product(ExecutionPolicy&& exec,
                                          InMat A, Triangle t, DiagonalStorage d, InVec x,
                                          OutVec y);

  // [:en] In-place triangular matrix-vector product \
  [:zh_CN] 原位的三角矩阵-向量相乘
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-vector InOutVec>
    void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d, InOutVec y);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-vector InOutVec>
    void triangular_matrix_vector_product(ExecutionPolicy&& exec,
                                          InMat A, Triangle t, DiagonalStorage d, InOutVec y);

  // [:en] Updating triangular matrix-vector product \
  [:zh_CN] 更新的三角矩阵-向量相乘
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, [[redoc("*:c>")]]out-vector OutVec>
    void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d,
                                          InVec1 x, InVec2 y, OutVec z);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, [[redoc("*:c>")]]out-vector OutVec>
    void triangular_matrix_vector_product(ExecutionPolicy&& exec,
                                          InMat A, Triangle t, DiagonalStorage d,
                                          InVec1 x, InVec2 y, OutVec z);

  // [:en] [#linalg.algs.blas2.trsv], solve a triangular linear system \
  [:zh_CN] [#linalg.algs.blas2.trsv]，求解三角线性系统

  // [:en] Solve a triangular linear system, not in place \
  [:zh_CN] 求解三角线性系统，非原位
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]out-vector OutVec, class BinaryDivideOp>
    void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
                                        InVec b, OutVec x, BinaryDivideOp divide);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]out-vector OutVec, class BinaryDivideOp>
    void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
                                        InMat A, Triangle t, DiagonalStorage d,
                                        InVec b, OutVec x, BinaryDivideOp divide);
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]out-vector OutVec>
    void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
                                        InVec b, OutVec x);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]out-vector OutVec>
    void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
                                        InMat A, Triangle t, DiagonalStorage d,
                                        InVec b, OutVec x);

  // [:en] Solve a triangular linear system, in place \
  [:zh_CN] 求解三角线性系统，原位
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]inout-vector InOutVec, class BinaryDivideOp>
    void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
                                        InOutVec b, BinaryDivideOp divide);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]inout-vector InOutVec, class BinaryDivideOp>
    void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
                                        InMat A, Triangle t, DiagonalStorage d,
                                        InOutVec b, BinaryDivideOp divide);
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-vector InOutVec>
    void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d, InOutVec b);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-vector InOutVec>
    void triangular_matrix_vector_solve(ExecutionPolicy&& exec,
                                        InMat A, Triangle t, DiagonalStorage d, InOutVec b);

  // [:en] [#linalg.algs.blas2.rank1], nonsymmetric rank-1 matrix update \
  [:zh_CN] [#linalg.algs.blas2.rank1]，非对称秩-1 矩阵更新
  template<[[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, [[redoc("*:c>")]]inout-matrix InOutMat>
    void matrix_rank_1_update(InVec1 x, InVec2 y, InOutMat A);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, [[redoc("*:c>")]]inout-matrix InOutMat>
    void matrix_rank_1_update(ExecutionPolicy&& exec,
                              InVec1 x, InVec2 y, InOutMat A);

  template<[[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, [[redoc("*:c>")]]inout-matrix InOutMat>
    void matrix_rank_1_update_c(InVec1 x, InVec2 y, InOutMat A);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2, [[redoc("*:c>")]]inout-matrix InOutMat>
    void matrix_rank_1_update_c(ExecutionPolicy&& exec,
                                InVec1 x, InVec2 y, InOutMat A);

  // [:en] [#linalg.algs.blas2.symherrank1], symmetric or Hermitian rank-1 matrix update \
  [:zh_CN] [#linalg.algs.blas2.symherrank1]，对称或厄米共轭秩-1 矩阵更新
  template<class Scalar, [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_1_update(Scalar alpha, InVec x, InOutMat A, Triangle t);
  template<class ExecutionPolicy,
           class Scalar, [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_1_update(ExecutionPolicy&& exec,
                                        Scalar alpha, InVec x, InOutMat A, Triangle t);
  template<[[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_1_update(InVec x, InOutMat A, Triangle t);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_1_update(ExecutionPolicy&& exec,
                                        InVec x, InOutMat A, Triangle t);

  template<class Scalar, [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_1_update(Scalar alpha, InVec x, InOutMat A, Triangle t);
  template<class ExecutionPolicy,
           class Scalar, [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_1_update(ExecutionPolicy&& exec,
                                        Scalar alpha, InVec x, InOutMat A, Triangle t);
  template<[[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_1_update(InVec x, InOutMat A, Triangle t);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-vector InVec, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_1_update(ExecutionPolicy&& exec,
                                        InVec x, InOutMat A, Triangle t);

  // [:en] [#linalg.algs.blas2.rank2], symmetric and Hermitian rank-2 matrix updates \
  [:zh_CN] [#linalg.algs.blas2.rank2]，对称和厄米共轭秩-2 矩阵更新

  // [:en] symmetric rank-2 matrix update \
  [:zh_CN] 对称秩-2 矩阵更新
  template<[[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2,
           [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_2_update(InVec1 x, InVec2 y, InOutMat A, Triangle t);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2,
           [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_2_update(ExecutionPolicy&& exec,
                                        InVec1 x, InVec2 y, InOutMat A, Triangle t);

  // [:en] Hermitian rank-2 matrix update \
  [:zh_CN] 厄米共轭秩-2 矩阵更新
  template<[[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2,
           [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_2_update(InVec1 x, InVec2 y, InOutMat A, Triangle t);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-vector InVec1, [[redoc("*:c>")]]in-vector InVec2,
           [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_2_update(ExecutionPolicy&& exec,
                                        InVec1 x, InVec2 y, InOutMat A, Triangle t);

  // [:en] [#linalg.algs.blas3], BLAS 3 algorithms \
  [:zh_CN] [#linalg.algs.blas3]，BLAS 3 算法

  // [:en] [#linalg.algs.blas3.gemm], general matrix-matrix product \
  [:zh_CN] [#linalg.algs.blas3.gemm]，一般矩阵-矩阵相乘
  template<[[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void matrix_product(InMat1 A, InMat2 B, OutMat C);
  template<class ExecutionPolicy, [[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void matrix_product(ExecutionPolicy&& exec,
                        InMat1 A, InMat2 B, OutMat C);
  template<[[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]in-matrix InMat3, [[redoc("*:c>")]]out-matrix OutMat>
    void matrix_product(InMat1 A, InMat2 B, InMat3 E, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]in-matrix InMat3, [[redoc("*:c>")]]out-matrix OutMat>
    void matrix_product(ExecutionPolicy&& exec,
                        InMat1 A, InMat2 B, InMat3 E, OutMat C);

  // [:en] [#linalg.algs.blas3.xxmm], symmetric, Hermitian, and triangular matrix-matrix product \
  [:zh_CN] [#linalg.algs.blas3.xxmm]，对称，厄米共轭和三角矩阵-矩阵相乘

  template<[[redoc("*:c>")]]in-matrix InMat1, class Triangle, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void symmetric_matrix_product(InMat1 A, Triangle t, InMat2 B, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, class Triangle, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void symmetric_matrix_product(ExecutionPolicy&& exec,
                                  InMat1 A, Triangle t, InMat2 B, OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, class Triangle, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void hermitian_matrix_product(InMat1 A, Triangle t, InMat2 B, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, class Triangle, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void hermitian_matrix_product(ExecutionPolicy&& exec,
                                  InMat1 A, Triangle t, InMat2 B, OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_product(InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_product(ExecutionPolicy&& exec,
                                   InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, [[redoc("*:c>")]]out-matrix OutMat>
    void symmetric_matrix_product(InMat1 A, InMat2 B, Triangle t, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, [[redoc("*:c>")]]out-matrix OutMat>
    void symmetric_matrix_product(ExecutionPolicy&& exec,
                                  InMat1 A, InMat2 B, Triangle t, OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, [[redoc("*:c>")]]out-matrix OutMat>
    void hermitian_matrix_product(InMat1 A, InMat2 B, Triangle t, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, [[redoc("*:c>")]]out-matrix OutMat>
    void hermitian_matrix_product(ExecutionPolicy&& exec,
                                  InMat1 A, InMat2 B, Triangle t, OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_product(InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_product(ExecutionPolicy&& exec,
                                   InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, class Triangle, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]in-matrix InMat3,
           [[redoc("*:c>")]]out-matrix OutMat>
    void symmetric_matrix_product(InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, class Triangle, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]in-matrix InMat3,
           [[redoc("*:c>")]]out-matrix OutMat>
    void symmetric_matrix_product(ExecutionPolicy&& exec,
                                  InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, class Triangle, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]in-matrix InMat3,
           [[redoc("*:c>")]]out-matrix OutMat>
    void hermitian_matrix_product(InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, class Triangle, [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]in-matrix InMat3,
           [[redoc("*:c>")]]out-matrix OutMat>
    void hermitian_matrix_product(ExecutionPolicy&& exec,
                                  InMat1 A, Triangle t, InMat2 B, InMat3 E, OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]in-matrix InMat3, [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_product(InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, InMat3 E,
                                   OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]in-matrix InMat3, [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_product(ExecutionPolicy&& exec,
                                   InMat1 A, Triangle t, DiagonalStorage d, InMat2 B, InMat3 E,
                                   OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, [[redoc("*:c>")]]in-matrix InMat3,
           [[redoc("*:c>")]]out-matrix OutMat>
    void symmetric_matrix_product(InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, [[redoc("*:c>")]]in-matrix InMat3,
           [[redoc("*:c>")]]out-matrix OutMat>
    void symmetric_matrix_product(ExecutionPolicy&& exec,
                                  InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, [[redoc("*:c>")]]in-matrix InMat3,
           [[redoc("*:c>")]]out-matrix OutMat>
    void hermitian_matrix_product(InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, [[redoc("*:c>")]]in-matrix InMat3,
           [[redoc("*:c>")]]out-matrix OutMat>
    void hermitian_matrix_product(ExecutionPolicy&& exec,
                                  InMat1 A, InMat2 B, Triangle t, InMat3 E, OutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat3, [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_product(InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, InMat3 E,
                                   OutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat3, [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_product(ExecutionPolicy&& exec,
                                   InMat1 A, InMat2 B, Triangle t, DiagonalStorage d, InMat3 E,
                                   OutMat C);

  // [:en] [#linalg.algs.blas3.trmm], in-place triangular matrix-matrix product \
  [:zh_CN] [#linalg.algs.blas3.trmm]，原位三角矩阵-矩阵相乘

  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-matrix InOutMat>
    void triangular_matrix_left_product(InMat A, Triangle t, DiagonalStorage d, InOutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-matrix InOutMat>
    void triangular_matrix_left_product(ExecutionPolicy&& exec,
                                        InMat A, Triangle t, DiagonalStorage d, InOutMat C);

  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-matrix InOutMat>
    void triangular_matrix_right_product(InMat A, Triangle t, DiagonalStorage d, InOutMat C);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-matrix InOutMat>
    void triangular_matrix_right_product(ExecutionPolicy&& exec,
                                         InMat A, Triangle t, DiagonalStorage d, InOutMat C);

  // [:en] [#linalg.algs.blas3.rankk], rank-k update of a symmetric or Hermitian matrix \
  [:zh_CN] [#linalg.algs.blas3.rankk]，对称或厄米共轭矩阵的秩-k 更新

  // [:en] rank-k symmetric matrix update \
  [:zh_CN] 秩-k 对称矩阵更新
  template<class Scalar, [[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_k_update(Scalar alpha, InMat A, InOutMat C, Triangle t);
  template<class ExecutionPolicy, class Scalar,
           [[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_k_update(ExecutionPolicy&& exec,
                                        Scalar alpha, InMat A, InOutMat C, Triangle t);

  template<[[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_k_update(InMat A, InOutMat C, Triangle t);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_k_update(ExecutionPolicy&& exec,
                                        InMat A, InOutMat C, Triangle t);

  // [:en] rank-k Hermitian matrix update \
  [:zh_CN] 秩-k 厄米共轭矩阵更新
  template<class Scalar, [[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_k_update(Scalar alpha, InMat A, InOutMat C, Triangle t);
  template<class ExecutionPolicy,
           class Scalar, [[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_k_update(ExecutionPolicy&& exec,
                                        Scalar alpha, InMat A, InOutMat C, Triangle t);

  template<[[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_k_update(InMat A, InOutMat C, Triangle t);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_k_update(ExecutionPolicy&& exec,
                                        InMat A, InOutMat C, Triangle t);

  // [:en] [#linalg.algs.blas3.rank2k], rank-2k update of a symmetric or Hermitian matrix \
  [:zh_CN] [#linalg.algs.blas3.rank2k]，对称或厄米共轭矩阵的秩-2k 更新

  // [:en] rank-2k symmetric matrix update \
  [:zh_CN] 秩-2k 对称矩阵更新
  template<[[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2,
           [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_2k_update(InMat1 A, InMat2 B, InOutMat C, Triangle t);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2,
           [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void symmetric_matrix_rank_2k_update(ExecutionPolicy&& exec,
                                         InMat1 A, InMat2 B, InOutMat C, Triangle t);

  // [:en] rank-2k Hermitian matrix update \
  [:zh_CN] 秩-2k 厄米共轭矩阵更新
  template<[[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2,
           [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_2k_update(InMat1 A, InMat2 B, InOutMat C, Triangle t);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, [[redoc("*:c>")]]in-matrix InMat2,
           [[redoc("*:c>")]]possibly-packed-inout-matrix InOutMat, class Triangle>
    void hermitian_matrix_rank_2k_update(ExecutionPolicy&& exec,
                                         InMat1 A, InMat2 B, InOutMat C, Triangle t);

  // [:en] [#linalg.algs.blas3.trsm], solve multiple triangular linear systems \
  [:zh_CN] [#linalg.algs.blas3.trsm]，求解多重三角线性系统

  // [:en] solve multiple triangular systems on the left, not-in-place \
  [:zh_CN] 左侧求解多重三角系统，非原位
  template<[[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat, class BinaryDivideOp>
    void triangular_matrix_matrix_left_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                             InMat2 B, OutMat X, BinaryDivideOp divide);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat, class BinaryDivideOp>
    void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
                                             InMat1 A, Triangle t, DiagonalStorage d,
                                             InMat2 B, OutMat X, BinaryDivideOp divide);
  template<[[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_matrix_left_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                             InMat2 B, OutMat X);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
                                             InMat1 A, Triangle t, DiagonalStorage d,
                                             InMat2 B, OutMat X);

  // [:en] solve multiple triangular systems on the right, not-in-place \
  [:zh_CN] 右侧求解多重三角系统，非原位
  template<[[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat, class BinaryDivideOp>
    void triangular_matrix_matrix_right_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                              InMat2 B, OutMat X, BinaryDivideOp divide);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat, class BinaryDivideOp>
    void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
                                              InMat1 A, Triangle t, DiagonalStorage d,
                                              InMat2 B, OutMat X, BinaryDivideOp divide);
  template<[[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_matrix_right_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                              InMat2 B, OutMat X);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat1, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]in-matrix InMat2, [[redoc("*:c>")]]out-matrix OutMat>
    void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
                                              InMat1 A, Triangle t, DiagonalStorage d,
                                              InMat2 B, OutMat X);

  // [:en] solve multiple triangular systems on the left, in-place \
  [:zh_CN] 左侧求解多重三角系统，原位
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]inout-matrix InOutMat, class BinaryDivideOp>
    void triangular_matrix_matrix_left_solve(InMat A, Triangle t, DiagonalStorage d,
                                             InOutMat B, BinaryDivideOp divide);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]inout-matrix InOutMat, class BinaryDivideOp>
    void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
                                             InMat A, Triangle t, DiagonalStorage d,
                                             InOutMat B, BinaryDivideOp divide);
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-matrix InOutMat>
    void triangular_matrix_matrix_left_solve(InMat A, Triangle t, DiagonalStorage d,
                                             InOutMat B);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-matrix InOutMat>
    void triangular_matrix_matrix_left_solve(ExecutionPolicy&& exec,
                                             InMat A, Triangle t, DiagonalStorage d,
                                             InOutMat B);

  // [:en] solve multiple triangular systems on the right, in-place \
  [:zh_CN] 右侧求解多重三角系统，原位
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]inout-matrix InOutMat, class BinaryDivideOp>
    void triangular_matrix_matrix_right_solve(InMat A, Triangle t, DiagonalStorage d,
                                              InOutMat B, BinaryDivideOp divide);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage,
           [[redoc("*:c>")]]inout-matrix InOutMat, class BinaryDivideOp>
    void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
                                              InMat A, Triangle t, DiagonalStorage d,
                                              InOutMat B, BinaryDivideOp divide);
  template<[[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-matrix InOutMat>
    void triangular_matrix_matrix_right_solve(InMat A, Triangle t, DiagonalStorage d,
                                              InOutMat B);
  template<class ExecutionPolicy,
           [[redoc("*:c>")]]in-matrix InMat, class Triangle, class DiagonalStorage, [[redoc("*:c>")]]inout-matrix InOutMat>
    void triangular_matrix_matrix_right_solve(ExecutionPolicy&& exec,
                                              InMat A, Triangle t, DiagonalStorage d,
                                              InOutMat B);
}
[codeblock:end]
