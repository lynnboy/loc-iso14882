[section#simd.syn
    [:en] Header [`<simd>] synopsis
    [:zh_CN] 头文件 [`simd] 纲要
]

[%@hdr@def simd]
[codeblock:synopsis]
namespace std::simd {
  // [:en] [#simd.traits], [`simd] type traits \
  [:zh_CN] [#simd.traits]，[`simd] 类型特征
  template<class T, class U = typename T::value_type> struct alignment;
  template<class T, class U = typename T::value_type>
    constexpr size_t [[redoc("[%@lib@member alignment_v[!simd]]")]]alignment_v = alignment<T, U>::value;

  template<class T, class V> struct rebind { using type = [[redoc("[=seebelow]", "_")]]_; };
  template<class T, class V> using [[redoc("[%@lib@member rebind_t[!simd]]")]]rebind_t = typename rebind<T, V>::type;
  template<[[redoc("*>")]]simd-size-type N, class V> struct rebind { using type = [[redoc("[=seebelow]", "_")]]_; };
  template<[[redoc("*>")]]simd-size-type N, class V> using [[redoc("[%@lib@member resize_t[!simd]]")]]rebind_t = typename resize_simd<N, V>::type;

  // [:en] [#simd.flags], load and store flags \
  [:zh_CN] [#simd.flags]，加载与存储标志
  template<class... Flags> struct flags;
  inline constexpr flags<> [[redoc("[%@lib@member flag_default[!simd]]")]]flag_default{};
  inline constexpr flags<[[redoc("*>")]]convert-flag> [[redoc("[%@lib@member flag_convert[!simd]]")]]flag_convert{};
  inline constexpr flags<[[redoc("*>")]]aligned-flag> [[redoc("[%@lib@member flag_aligned[!simd]]")]]flag_aligned{};
  template<size_t N> requires (has_single_bit(N))
    constexpr flags<[[redoc("*>")]]overaligned-flag<N>> [[redoc("[%@lib@member flag_overaligned[!simd]]")]]flag_overaligned{};

  // [:en] [#simd.iterator], class template [*simd-iterator] \
  [:zh_CN] [#simd.iterator]，类模板 [*simd-iterator]
  template<class V>
    class [[redoc("*>")]]simd-iterator;                // [=expos]

  // [:en] [#simd.class], class template [`basic_vec] \
  [:zh_CN] [#simd.class]，类模板 [`basic_vec]
  template<class T, class Abi = [[redoc("*>")]]native-abi<T>> class basic_vec;
  template<class T, [[redoc("*>")]]simd-size-type N = [[redoc("*>")]]simd-size-v<T, [[redoc("*>")]]native-abi<T>>>
    using [[redoc("[%@lib@member vec[!simd]]")]]vec = basic_vec<T, [[redoc("*>")]]deduce-abi-t<T, N>>;

  // [:en] [#simd.mask.class], class template [`basic_mask] \
  [:zh_CN] [#simd.mask.class]，类模板 [`basic_mask]
  template<size_t Bytes, class Abi = [[redoc("*>")]]native-abi<[[redoc("*>")]]integer-from<Bytes>>> class basic_mask;
  template<class T, [[redoc("*>")]]simd-size-type N = [[redoc("*>")]]simd-size-v<T, [[redoc("*>")]]native-abi<T>>>
    using [[redoc("[%@lib@member mask[!simd]]")]]mask = basic_mask<sizeof(T), [[redoc("*>")]]deduce-abi-t<T, N>>;

  // [:en] [#simd.loadstore], [`basic_vec] load and store functions \
  [:zh_CN] [#simd.loadstore]，[`basic_vec] 加载与存储函数
  template<class V = [[redoc("[=seebelow]")]], ranges::[[redoc("`:c>")]]contiguous_range R, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr V unchecked_load(R&& r, flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]], ranges::[[redoc("`:c>")]]contiguous_range R, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr V unchecked_load(R&& r, const typename V::mask_type& k,
                               flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]], [[redoc("`:c>")]]contiguous_iterator I, class... Flags>
    constexpr V unchecked_load(I first, iter_difference_t<I> n,
                               _flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]], [[redoc("`:c>")]]contiguous_iterator I, class... Flags>
    constexpr V unchecked_load(I first, iter_difference_t<I> n,
                               const typename V::mask_type& k, flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]], [[redoc("`:c>")]]contiguous_iterator I, [[redoc("`:c>")]]sized_sentinel_for<I> S, class... Flags>
    constexpr V unchecked_load(I first, S last, flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]], [[redoc("`:c>")]]contiguous_iterator I, [[redoc("`:c>")]]sized_sentinel_for<I> S, class... Flags>
    constexpr V unchecked_load(I first, S last, const typename V::mask_type& k,
                               flags<Flags...> f = {});

  template<class V = [[redoc("[=seebelow]")]], ranges::[[redoc("`:c>")]]contiguous_range R, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr V partial_load(R&& r, flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]], ranges::[[redoc("`:c>")]]contiguous_range R, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr V partial_load(R&& r, const typename V::mask_type& k,
                             flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]], [[redoc("`:c>")]]contiguous_iterator I, class... Flags>
    constexpr V partial_load(I first, iter_difference_t<I> n, flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]], [[redoc("`:c>")]]contiguous_iterator I, class... Flags>
    constexpr V partial_load(I first, iter_difference_t<I> n,
                             const typename V::mask_type& k, flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]], [[redoc("`:c>")]]contiguous_iterator I, [[redoc("`:c>")]]sized_sentinel_for<I> S, class... Flags>
    constexpr V partial_load(I first, S last, flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]], [[redoc("`:c>")]]contiguous_iterator I, [[redoc("`:c>")]]sized_sentinel_for<I> S, class... Flags>
    constexpr V partial_load(I first, S last, const typename V::mask_type& k,
                             flags<Flags...> f = {});

  template<class T, class Abi, ranges::[[redoc("`:c>")]]contiguous_range R, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R> && [[redoc("`:c>")]]indirectly_writable<ranges::iterator_t<R>, T>
    constexpr void unchecked_store(const basic_vec<T, Abi>& v, R&& r,
                                   flags<Flags...> f = {});
  template<class T, class Abi, ranges::[[redoc("`:c>")]]contiguous_range R, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R> && [[redoc("`:c>")]]indirectly_writable<ranges::iterator_t<R>, T>
    constexpr void _unchecked_store(const basic_vec<T, Abi>& v, R&& r,
      const typename basic_vec<T, Abi>::mask_type& mask, flags<Flags...> f = {});
  template<class T, class Abi, [[redoc("`:c>")]]contiguous_iterator I, class... Flags>
    requires [[redoc("`:c>")]]indirectly_writable<I, T>
    constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first,
                                   iter_difference_t<I> n, flags<Flags...> f = {});
  template<class T, class Abi, [[redoc("`:c>")]]contiguous_iterator I, class... Flags>
    requires [[redoc("`:c>")]]indirectly_writable<I, T>
    constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first,
      iter_difference_t<I> n, const typename basic_vec<T, Abi>::mask_type& mask,
      flags<Flags...> f = {});
  template<class T, class Abi, [[redoc("`:c>")]]contiguous_iterator I, [[redoc("`:c>")]]sized_sentinel_for<I> S, class... Flags>
    requires [[redoc("`:c>")]]indirectly_writable<I, T>
    constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first, S last,
                                   flags<Flags...> f = {});
  template<class T, class Abi, [[redoc("`:c>")]]contiguous_iterator I, [[redoc("`:c>")]]sized_sentinel_for<I> S, class... Flags>
    requires [[redoc("`:c>")]]indirectly_writable<I, T>
    constexpr void unchecked_store(const basic_vec<T, Abi>& v, I first, S last,
      const typename basic_vec<T, Abi>::mask_type& mask, flags<Flags...> f = {});

  template<class T, class Abi, ranges::[[redoc("`:c>")]]contiguous_range R, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R> && [[redoc("`:c>")]]indirectly_writable<ranges::iterator_t<R>, T>
    constexpr void partial_store(const basic_vec<T, Abi>& v, R&& r,
                                 flags<Flags...> f = {});
  template<class T, class Abi, ranges::[[redoc("`:c>")]]contiguous_range R, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R> && [[redoc("`:c>")]]indirectly_writable<ranges::iterator_t<R>, T>
    constexpr void partial_store(const basic_vec<T, Abi>& v, R&& r,
      const typename basic_vec<T, Abi>::mask_type& mask, flags<Flags...> f = {});
  template<class T, class Abi, [[redoc("`:c>")]]contiguous_iterator I, class... Flags>
    requires [[redoc("`:c>")]]indirectly_writable<I, T>
    constexpr void partial_store(
      const basic_vec<T, Abi>& v, I first, iter_difference_t<I> n, flags<Flags...> f = {});
  template<class T, class Abi, [[redoc("`:c>")]]contiguous_iterator I, class... Flags>
    requires [[redoc("`:c>")]]indirectly_writable<I, T>
    constexpr void partial_store(
      const basic_vec<T, Abi>& v, I first, iter_difference_t<I> n,
      const typename basic_vec<T, Abi>::mask_type& mask, flags<Flags...> f = {});
  template<class T, class Abi, [[redoc("`:c>")]]contiguous_iterator I, [[redoc("`:c>")]]sized_sentinel_for<I> S, class... Flags>
    requires [[redoc("`:c>")]]indirectly_writable<I, T>
    constexpr void partial_store(const basic_vec<T, Abi>& v, I first, S last,
                                 flags<Flags...> f = {});
  template<class T, class Abi, [[redoc("`:c>")]]contiguous_iterator I, [[redoc("`:c>")]]sized_sentinel_for<I> S, class... Flags>
    requires [[redoc("`:c>")]]indirectly_writable<I, T>
    constexpr void partial_store(const basic_vec<T, Abi>& v, I first, S last,
      const typename basic_vec<T, Abi>::mask_type& mask, flags<Flags...> f = {});

  // [:en] [#simd.permute.static], permute by static index generator \
  [:zh_CN] [#simd.permute.static]，以静态索引生成器排列
  static constexpr [[redoc("*>")]]simd-size-type [[redoc("[%@lib@member zero_element[!simd]]")]]zero_element   = [[redoc("[?impdefx [:en] value of [`simd::zero_element] [:zh_CN] [`simd::zero_element] 的值]")]];
  static constexpr [[redoc("*>")]]simd-size-type [[redoc("[%@lib@member uninit_element[!simd]]")]]uninit_element = [[redoc("[?impdefx [:en] value of [`simd::uninit_element] [:zh_CN] [`simd::uninit_element] 的值]")]];

  template<[[redoc("*>")]]simd-size-type N = [[redoc("[=seebelow]")]], [[redoc("*:c>")]]simd-vec-type V, class IdxMap>
    constexpr resize_t<N, V> permute(const V& v, IdxMap&& idxmap);
  template<[[redoc("*>")]]simd-size-type N = [[redoc("[=seebelow]")]], [[redoc("*:c>")]]simd-mask-type M, class IdxMap>
    constexpr resize_t<N, M> permute(const M& v, IdxMap&& idxmap);

  // [:en] [#simd.permute.dynamic], permute by dynamic index \
  [:zh_CN] [#simd.permute.dynamic]，以动态索引排列
  template<[[redoc("*:c>")]]simd-vec-type V, [[redoc("*:c>")]]simd-integral I>
    constexpr resize_t<I::size(), V> permute(const V& v, const I& indices);
  template<[[redoc("*:c>")]]simd-mask-type M, [[redoc("*:c>")]]simd-integral I>
    constexpr resize_t<I::size(), M> permute(const M& v, const I& indices);

  // [:en] [#simd.permute.mask], permute by active mask bits \
  [:zh_CN] [#simd.permute.mask]，以活跃掩模位排列
  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr V compress(const V& v, const typename V::mask_type& selector);
  template<[[redoc("*:c>")]]simd-mask-type M>
    constexpr M compress(const M& v, const type_identity_t<M>& selector);
  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr V compress(const V& v, const typename V::mask_type& selector,
                         const typename V::value_type& fill_value);
  template<[[redoc("*:c>")]]simd-mask-type M>
    constexpr M compress(const M& v, const type_identity_t<M>& selector,
                         const typename V::value_type& fill_value);

  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr V expand(const V& v, const typename V::mask_type& selector,
                       const V& original = {});
  template<[[redoc("*:c>")]]simd-mask-type M>
    constexpr M expand(const M& v, const type_identity_t<M>& selector,
                       const M& original = {});

  // [:en] [#simd.permute.memory], permute to and from memory \
  [:zh_CN] [#simd.permute.memory]，与内存之间的排列
  template<class V = [[redoc("[=seebelow]")]],
           ranges::[[redoc("`:c>")]]contiguous_range R, [[redoc("*:c>")]]simd-integral I, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr V
      unchecked_gather_from(R&& in,
                            const I& indices, flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]],
           ranges::[[redoc("`:c>")]]contiguous_range R, [[redoc("*:c>")]]simd-integral I, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr V
      unchecked_gather_from(R&& in, const typename I::mask_type& mask,
                            const I& indices, flags<Flags...> f = {});

  template<class V = [[redoc("[=seebelow]")]],
     ranges::[[redoc("`:c>")]]contiguous_range R, [[redoc("*:c>")]]simd-integral I, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr V
      partial_gather_from(R&& in,
                          const I& indices, flags<Flags...> f = {});
  template<class V = [[redoc("[=seebelow]")]],
             ranges::[[redoc("`:c>")]]contiguous_range R, [[redoc("*:c>")]]simd-integral I, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr V
      partial_gather_from(R&& in, const typename I::mask_type& mask,
                          const I& indices, flags<Flags...> f = {});

  template<[[redoc("*:c>")]]simd-vec-type V, ranges::[[redoc("`:c>")]]contiguous_range R, [[redoc("*:c>")]]simd-integral I, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr void
      unchecked_scatter_to(const V& v, R&& out,
                           const I& indices, flags<Flags...> f = {});
  template<[[redoc("*:c>")]]simd-vec-type V, ranges::[[redoc("`:c>")]]contiguous_range R, [[redoc("*:c>")]]simd-integral I, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr void
      unchecked_scatter_to(const V& v, R&& out, const typename I::mask_type& mask,
                           const I& indices, flags<Flags...> f = {});

  template<[[redoc("*:c>")]]simd-vec-type V, ranges::[[redoc("`:c>")]]contiguous_range R, [[redoc("*:c>")]]simd-integral I, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr void
      partial_scatter_to(const V& v, R&& out,
                         const I& indices, flags<Flags...> f = {});
  template<[[redoc("*:c>")]]simd-vec-type V, ranges::[[redoc("`:c>")]]contiguous_range R, [[redoc("*:c>")]]simd-integral I, class... Flags>
    requires ranges::[[redoc("`:c>")]]sized_range<R>
    constexpr void
      partial_scatter_to(const V& v, R&& out, const typename I::mask_type& mask,
                         const I& indices, flags<Flags...> f = {});

  // [:en] [#simd.creation], [`basic_vec] and [`basic_mask] creation \
  [:zh_CN] [#simd.creation]，[`basic_vec] 与 [`basic_mask] 的创建
  template<class T, class Abi>
    constexpr auto chunk(const basic_vec<typename T::value_type, Abi>& x) noexcept;
  template<class T, class Abi>
    constexpr auto chunk(const basic_mask<[[redoc("*>")]]mask-element-size<T>, Abi>& x) noexcept;

  template<[[redoc("*>")]]simd-size-type N, class T, class Abi>
    constexpr auto chunk(const basic_vec<T, Abi>& x) noexcept;
  template<[[redoc("*>")]]simd-size-type N, size_t Bytes, class Abi>
    constexpr auto chunk(const basic_mask<Bytes, Abi>& x) noexcept;

  template<class T, class... Abis>
    constexpr basic_vec<T, [[redoc("*>")]]deduce-abi-t<T, (basic_vec<T, Abis>::size() + ...)>>
      cat(const basic_vec<T, Abis>&...) noexcept;
  template<size_t Bytes, class... Abis>
    constexpr basic_mask<Bytes, [[redoc("*>")]]deduce-abi-t<[[redoc("*>")]]integer-from<Bytes>,
                              (basic_mask<Bytes, Abis>::size() + ...)>>
      cat(const basic_mask<Bytes, Abis>&...) noexcept;

  // [:en] [#simd.mask.reductions], [`basic_mask] reductions \
  [:zh_CN] [#simd.mask.reductions]，[`basic_mask] 归约
  template<size_t Bytes, class Abi>
    constexpr bool all_of(const basic_mask<Bytes, Abi>&) noexcept;
  template<size_t Bytes, class Abi>
    constexpr bool any_of(const basic_mask<Bytes, Abi>&) noexcept;
  template<size_t Bytes, class Abi>
    constexpr bool none_of(const basic_mask<Bytes, Abi>&) noexcept;
  template<size_t Bytes, class Abi>
    constexpr [[redoc("*>")]]simd-size-type reduce_count(const basic_mask<Bytes, Abi>&) noexcept;
  template<size_t Bytes, class Abi>
    constexpr [[redoc("*>")]]simd-size-type reduce_min_index(const basic_mask<Bytes, Abi>&);
  template<size_t Bytes, class Abi>
    constexpr [[redoc("*>")]]simd-size-type reduce_max_index(const basic_mask<Bytes, Abi>&);

  constexpr bool all_of([[redoc("`:c>")]]same_as<bool> auto) noexcept;
  constexpr bool any_of([[redoc("`:c>")]]same_as<bool> auto) noexcept;
  constexpr bool none_of([[redoc("`:c>")]]same_as<bool> auto) noexcept;
  constexpr [[redoc("*>")]]simd-size-type reduce_count([[redoc("`:c>")]]same_as<bool> auto) noexcept;
  constexpr [[redoc("*>")]]simd-size-type reduce_min_index([[redoc("`:c>")]]same_as<bool> auto);
  constexpr [[redoc("*>")]]simd-size-type reduce_max_index([[redoc("`:c>")]]same_as<bool> auto);

  // [:en] [#simd.reductions], [`basic_vec] reductions \
  [:zh_CN] [#simd.reductions]，[`basic_vec] 归约
  template<class T, class Abi, class BinaryOperation = plus<>>
    constexpr T reduce(const basic_vec<T, Abi>&, BinaryOperation = {});
  template<class T, class Abi, class BinaryOperation = plus<>>
    constexpr T reduce(
      const basic_vec<T, Abi>& x, const typename basic_vec<T, Abi>::mask_type& mask,
      BinaryOperation binary_op = {}, type_identity_t<T> identity_element = [[redoc("[=seebelow]")]]);

  template<class T, class Abi>
    constexpr T reduce_min(const basic_vec<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_min(const basic_vec<T, Abi>&,
                           const typename basic_vec<T, Abi>::mask_type&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_max(const basic_vec<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_max(const basic_vec<T, Abi>&,
                           const typename basic_vec<T, Abi>::mask_type&) noexcept;

  // [:en] [#simd.alg], algorithms \
  [:zh_CN] [#simd.alg]，算法
  template<class T, class Abi>
    constexpr basic_vec<T, Abi>
      min(const basic_vec<T, Abi>& a, const basic_vec<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr basic_vec<T, Abi>
      max(const basic_vec<T, Abi>& a, const basic_vec<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr pair<basic_vc<T, Abi>, basic_vec<T, Abi>>
      minmax(const basic_vc<T, Abi>& a, const basic_vec<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr basic_vec<T, Abi>
      clamp(const basic_vec<T, Abi>& v, const basic_vec<T, Abi>& lo,
            const basic_vec<T, Abi>& hi);

  template<class T, class U>
    constexpr auto select(bool c, const T& a, const U& b)
    -> remove_cvref_t<decltype(c ? a : b)>;
  template<size_t Bytes, class Abi, class T, class U>
    constexpr auto select(const basic_mask<Bytes, Abi>& c, const T& a, const U& b)
    noexcept -> decltype([[redoc("*>")]]simd-select-impl(c, a, b));

  // [:en] [#simd.math], mathematical functions \
  [:zh_CN] [#simd.math]，数学函数
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> acos(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> asin(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> atan(const V& x);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1> atan2(const V0& y, const V1& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> cos(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> sin(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> tan(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> acosh(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> asinh(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> atanh(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> cosh(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> sinh(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> tanh(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> exp(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> exp2(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> expm1(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr [[redoc("*>")]]deduced-vec-t<V>
      frexp(const V& value, rebind_t<int, [[redoc("*>")]]deduced-vec-t<V>>* exp);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr rebind_t<int, [[redoc("*>")]]deduced-vec-t<V>> ilogb(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr [[redoc("*>")]]deduced-vec-t<V> ldexp(const V& x, const rebind_t<int, [[redoc("*>")]]deduced-vec-t<V>>& exp);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> log(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> log10(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> log1p(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> log2(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> logb(const V& x);
  template<class T, class Abi>
    constexpr basic_vec<T, Abi>
      modf(const type_identity_t<basic_vec<T, Abi>>& value, basic_vec<T, Abi>* iptr);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr [[redoc("*>")]]deduced-vec-t<V> scalbn(const V& x, const rebind_t<int, [[redoc("*>")]]deduced-vec-t<V>>& n);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr [[redoc("*>")]]deduced-vec-t<V> scalbln(
      const V& x, const rebind_t<long int, [[redoc("*>")]]deduced-vec-t<V>>& n);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> cbrt(const V& x);
  template<[[redoc("`:c>")]]signed_integral T, class Abi>
    constexpr basic_vec<T, Abi> abs(const basic_vec<T, Abi>& j);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> abs(const V& j);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> fabs(const V& x);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1> hypot(const V0& x, const V1& y);
  template<class V0, class V1, class V2>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1, V2> hypot(const V0& x, const V1& y, const V2& z);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1> pow(const V0& x, const V1& y);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> sqrt(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> erf(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> erfc(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> lgamma(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> tgamma(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> ceil(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> constexpr [[redoc("*>")]]deduced-vec-t<V> floor(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> [[redoc("*>")]]deduced-vec-t<V> nearbyint(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V> [[redoc("*>")]]deduced-vec-t<V> rint(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    rebind_t<long int, [[redoc("*>")]]deduced-vec-t<V>> lrint(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    rebind_t<long long int, V> llrint(const [[redoc("*>")]]deduced-vec-t<V>& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr [[redoc("*>")]]deduced-vec-t<V> round(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr rebind_t<long int, [[redoc("*>")]]deduced-vec-t<V>> lround(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr rebind_t<long long int, [[redoc("*>")]]deduced-vec-t<V>> llround(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr [[redoc("*>")]]deduced-vec-t<V> trunc(const V& x);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1> fmod(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1> remainder(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1>
      remquo(const V0& x, const V1& y, rebind_t<int, [[redoc("*>")]]math-common-simd-t<V0, V1>>* quo);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1> copysign(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1> nextafter(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1> fdim(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1> fmax(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1> fmin(const V0& x, const V1& y);
  template<class V0, class V1, class V2>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1, V2> fma(const V0& x, const V1& y, const V2& z);
  template<class V0, class V1, class V2>
    constexpr [[redoc("*>")]]math-common-simd-t<V0, V1, V2>
      lerp(const V0& a, const V1& b, const V2& t) noexcept;
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr rebind_t<int, [[redoc("*>")]]deduced-vec-t<V>> fpclassify(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr typename [[redoc("*>")]]deduced-vec-t<V>::mask_type isfinite(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr typename [[redoc("*>")]]deduced-vec-t<V>::mask_type isinf(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr typename [[redoc("*>")]]deduced-vec-t<V>::mask_type isnan(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr typename [[redoc("*>")]]deduced-vec-t<V>::mask_type isnormal(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    constexpr typename [[redoc("*>")]]deduced-vec-t<V>::mask_type signbit(const V& x);
  template<class V0, class V1>
    constexpr typename [[redoc("*>")]]math-common-simd-t<V0, V1>::mask_type
      isgreater(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr typename [[redoc("*>")]]math-common-simd-t<V0, V1>::mask_type
      isgreaterequal(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr typename [[redoc("*>")]]math-common-simd-t<V0, V1>::mask_type
      isless(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr typename [[redoc("*>")]]math-common-simd-t<V0, V1>::mask_type
      islessequal(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr typename [[redoc("*>")]]math-common-simd-t<V0, V1>::mask_type
      islessgreater(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr typename [[redoc("*>")]]math-common-simd-t<V0, V1>::mask_type
      isunordered(const V0& x, const V1& y);
  template<[[redoc("*:c>")]]math-floating-point V>
    [[redoc("*>")]]deduced-vec-t<V> assoc_laguerre(const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& n,
                                    const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& m, const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    [[redoc("*>")]]deduced-vec-t<V> assoc_legendre(const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& l,
                                    const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& m, const V& x);
  template<class V0, class V1>
    [[redoc("*>")]]math-common-simd-t<V0, V1> beta(const V0& x, const V1& y);
  template<[[redoc("*:c>")]]math-floating-point V> [[redoc("*>")]]deduced-vec-t<V> comp_ellint_1(const V& k);
  template<[[redoc("*:c>")]]math-floating-point V> [[redoc("*>")]]deduced-vec-t<V> comp_ellint_2(const V& k);
  template<class V0, class V1>
    [[redoc("*>")]]math-common-simd-t<V0, V1> comp_ellint_3(const V0& k, const V1& nu);
  template<class V0, class V1>
    [[redoc("*>")]]math-common-simd-t<V0, V1> cyl_bessel_i(const V0& nu, const V1& x);
  template<class V0, class V1>
    [[redoc("*>")]]math-common-simd-t<V0, V1> cyl_bessel_j(const V0& nu, const V1& x);
  template<class V0, class V1>
    [[redoc("*>")]]math-common-simd-t<V0, V1> cyl_bessel_k(const V0& nu, const V1& x);
  template<class V0, class V1>
    [[redoc("*>")]]math-common-simd-t<V0, V1> cyl_neumann(const V0& nu, const V1& x);
  template<class V0, class V1>
    [[redoc("*>")]]math-common-simd-t<V0, V1> ellint_1(const V0& k, const V1& phi);
  template<class V0, class V1>
    [[redoc("*>")]]math-common-simd-t<V0, V1> ellint_2(const V0& k, const V1& phi);
  template<class V0, class V1, class V2>
    [[redoc("*>")]]math-common-simd-t<V0, V1, V2> ellint_3(const V0& k, const V1& nu, const V2& phi);
  template<[[redoc("*:c>")]]math-floating-point V> [[redoc("*>")]]deduced-vec-t<V> expint(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    [[redoc("*>")]]deduced-vec-t<V> hermite(const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& n, const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    [[redoc("*>")]]deduced-vec-t<V> laguerre(const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& n, const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    [[redoc("*>")]]deduced-vec-t<V> legendre(const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& l, const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    [[redoc("*>")]]deduced-vec-t<V> riemann_zeta(const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    [[redoc("*>")]]deduced-vec-t<V> sph_bessel(
      const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& n, const V& x);
  template<[[redoc("*:c>")]]math-floating-point V>
    [[redoc("*>")]]deduced-vec-t<V> sph_legendre(const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& l,
      const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& m, const V& theta);
  template<[[redoc("*:c>")]]math-floating-point V>
    [[redoc("*>")]]deduced-vec-t<V>
      sph_neumann(const rebind_t<unsigned, [[redoc("*>")]]deduced-vec-t<V>>& n, const V& x);

  // [:en] [#simd.bit], bit manipulation \
  [:zh_CN] [#simd.bit]，位操纵
  template<[[redoc("*:c>")]]simd-vec-type V> constexpr V byteswap(const V& v) noexcept;
  template<[[redoc("*:c>")]]simd-vec-type V> constexpr V bit_ceil(const V& v) noexcept;
  template<[[redoc("*:c>")]]simd-vec-type V> constexpr V bit_floor(const V& v) noexcept;

  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr typename V::mask_type has_single_bit(const V& v) noexcept;

  template<[[redoc("*:c>")]]simd-vec-type V0, [[redoc("*:c>")]]simd-vec-type V1>
    constexpr V0 rotl(const V0& v, const V1& s) noexcept;
  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr V  rotl(const V& v, int s) noexcept;

  template<[[redoc("*:c>")]]simd-vec-type V0, [[redoc("*:c>")]]simd-vec-type V1>
    constexpr V0 rotr(const V0& v, const V1& s) noexcept;
  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr V  rotr(const V& v, int s) noexcept;

  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      bit_width(const V& v) noexcept;
  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      countl_zero(const V& v) noexcept;
  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      countl_one(const V& v) noexcept;
  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      countr_zero(const V& v) noexcept;
  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      countr_one(const V& v) noexcept;
  template<[[redoc("*:c>")]]simd-vec-type V>
    constexpr rebind_t<make_signed_t<typename V::value_type>, V>
      popcount(const V& v) noexcept;

  // [:en] [#simd.complex.math], [`vec] complex math \
  [:zh_CN] [#simd.complex.math]，[`vec] 复数数学函数
  template<[[redoc("*:c>")]]simd-complex V>
    constexpr rebind_t<[[redoc("*>")]]simd-complex-value-type<V>, V> real(const V&) noexcept;

  template<[[redoc("*:c>")]]simd-complex V>
    constexpr rebind_t<[[redoc("*>")]]simd-complex-value-type<V>, V> imag(const V&) noexcept;

  template<[[redoc("*:c>")]]simd-complex V>
    constexpr rebind_t<[[redoc("*>")]]simd-complex-value-type<V>, V> abs(const V&);

  template<[[redoc("*:c>")]]simd-complex V>
    constexpr rebind_t<[[redoc("*>")]]simd-complex-value-type<V>, V> arg(const V&);

  template<[[redoc("*:c>")]]simd-complex V>
    constexpr rebind_t<[[redoc("*>")]]simd-complex-value-type<V>, V> norm(const V&);

  template<[[redoc("*:c>")]]simd-complex V> constexpr V conj(const V&);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V proj(const V&);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V exp(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V log(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V log10(const V& v);

  template<[[redoc("*:c>")]]simd-complex V> constexpr V sqrt(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V sin(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V asin(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V cos(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V acos(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V tan(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V atan(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V sinh(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V asinh(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V cosh(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V acosh(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V tanh(const V& v);
  template<[[redoc("*:c>")]]simd-complex V> constexpr V atanh(const V& v);

  template<[[redoc("*:c>")]]simd-floating-point V>
    rebind_t<complex<typename V::value_type>, V> polar(const V& x, const V& y = {});

  template<[[redoc("*:c>")]]simd-complex V> constexpr V pow(const V& x, const V& y);
}

namespace std {
  // [:en] See [#simd.alg], algorithms [:zh_CN] 参见 [#simd.alg]，算法
  using simd::min;
  using simd::max;
  using simd::minmax;
  using simd::clamp;

  // [:en] See [#simd.math], mathematical functions [:zh_CN] 参见 [#simd.math]，数学函数
  using simd::acos;
  using simd::asin;
  using simd::atan;
  using simd::atan2;
  using simd::cos;
  using simd::sin;
  using simd::tan;
  using simd::acosh;
  using simd::asinh;
  using simd::atanh;
  using simd::cosh;
  using simd::sinh;
  using simd::tanh;
  using simd::exp;
  using simd::exp2;
  using simd::expm1;
  using simd::frexp;
  using simd::ilogb;
  using simd::ldexp;
  using simd::log;
  using simd::log10;
  using simd::log1p;
  using simd::log2;
  using simd::logb;
  using simd::modf;
  using simd::scalbn;
  using simd::scalbln;
  using simd::cbrt;
  using simd::abs;
  using simd::abs;
  using simd::fabs;
  using simd::hypot;
  using simd::pow;
  using simd::sqrt;
  using simd::erf;
  using simd::erfc;
  using simd::lgamma;
  using simd::tgamma;
  using simd::ceil;
  using simd::floor;
  using simd::nearbyint;
  using simd::rint;
  using simd::lrint;
  using simd::llrint;
  using simd::round;
  using simd::lround;
  using simd::llround;
  using simd::trunc;
  using simd::fmod;
  using simd::remainder;
  using simd::remquo;
  using simd::copysign;
  using simd::nextafter;
  using simd::fdim;
  using simd::fmax;
  using simd::fmin;
  using simd::fma;
  using simd::lerp;
  using simd::fpclassify;
  using simd::isfinite;
  using simd::isinf;
  using simd::isnan;
  using simd::isnormal;
  using simd::signbit;
  using simd::isgreater;
  using simd::isgreaterequal;
  using simd::isless;
  using simd::islessequal;
  using simd::islessgreater;
  using simd::isunordered;
  using simd::assoc_laguerre;
  using simd::assoc_legendre;
  using simd::beta;
  using simd::comp_ellint_1;
  using simd::comp_ellint_2;
  using simd::comp_ellint_3;
  using simd::cyl_bessel_i;
  using simd::cyl_bessel_j;
  using simd::cyl_bessel_k;
  using simd::cyl_neumann;
  using simd::ellint_1;
  using simd::ellint_2;
  using simd::ellint_3;
  using simd::expint;
  using simd::hermite;
  using simd::laguerre;
  using simd::legendre;
  using simd::riemann_zeta;
  using simd::sph_bessel;
  using simd::sph_legendre;
  using simd::sph_neumann;

  // [:en] See [#simd.bit], bit manipulation [:zh_CN] 参见 [#simd.bit]，位操纵
  using simd::byteswap;
  using simd::bit_ceil;
  using simd::bit_floor;
  using simd::has_single_bit;
  using simd::rotl;
  using simd::rotr;
  using simd::bit_width;
  using simd::countl_zero;
  using simd::countl_one;
  using simd::countr_zero;
  using simd::countr_one;
  using simd::popcount;

  // [:en] See [#simd.complex.math], [`vec] complex math [:zh_CN] 参见 [#simd.complex.math]，[`vec] 复数数学函数
  using simd::real;
  using simd::imag;
  using simd::arg;
  using simd::norm;
  using simd::conj;
  using simd::proj;
  using simd::polar;
}
[codeblock:end]
