[section#cmath.syn
    [:en] Header [`<cmath>] synopsis
    [:zh_CN] 头文件 [`<cmath>] 纲要
]

[%@hdr@def cmath]
[%@lib FP_FAST_FMA]
[%@lib FP_FAST_FMAF]
[%@lib FP_FAST_FMAL]
[%@lib FP_ILOGB0]
[%@lib FP_ILOGBNAN]
[%@lib FP_INFINITE]
[%@lib FP_NAN]
[%@lib FP_NORMAL]
[%@lib FP_SUBNORMAL]
[%@lib FP_ZERO]
[%@lib HUGE_VAL]
[%@lib HUGE_VALF]
[%@lib HUGE_VALL]
[%@lib INFINITY]
[%@lib MATH_ERREXCEPT]
[%@lib MATH_ERRNO]
[%@lib NAN]
[%@lib abs]
[%@lib acos]
[%@lib acosf]
[%@lib acosh]
[%@lib acoshf]
[%@lib acoshl]
[%@lib acosl]
[%@lib asin]
[%@lib asinf]
[%@lib asinh]
[%@lib asinhf]
[%@lib asinhl]
[%@lib asinl]
[%@lib atan]
[%@lib atan2]
[%@lib atan2f]
[%@lib atan2l]
[%@lib atanf]
[%@lib atanh]
[%@lib atanhf]
[%@lib atanhl]
[%@lib atanl]
[%@lib cbrt]
[%@lib cbrtf]
[%@lib cbrtl]
[%@lib ceil]
[%@lib ceilf]
[%@lib ceill]
[%@lib copysign]
[%@lib copysignf]
[%@lib copysignl]
[%@lib cos]
[%@lib cosf]
[%@lib cosh]
[%@lib coshf]
[%@lib coshl]
[%@lib cosl]
[%@lib double_t]
[%@lib erf]
[%@lib erfc]
[%@lib erfcf]
[%@lib erfcl]
[%@lib erff]
[%@lib erfl]
[%@lib exp]
[%@lib exp2]
[%@lib exp2f]
[%@lib exp2l]
[%@lib expf]
[%@lib expl]
[%@lib expm1]
[%@lib expm1f]
[%@lib expm1l]
[%@lib fabs]
[%@lib fabsf]
[%@lib fabsl]
[%@lib fdim]
[%@lib fdimf]
[%@lib fdiml]
[%@lib float_t]
[%@lib floor]
[%@lib floorf]
[%@lib floorl]
[%@lib fma]
[%@lib fmaf]
[%@lib fmal]
[%@lib fmax]
[%@lib fmaxf]
[%@lib fmaxl]
[%@lib fmin]
[%@lib fminf]
[%@lib fminl]
[%@lib fmod]
[%@lib fmodf]
[%@lib fmodl]
[%@lib fpclassify]
[%@lib frexp]
[%@lib frexpf]
[%@lib frexpl]
[%@lib hypot]
[%@lib hypotf]
[%@lib hypotl]
[%@lib ilogb]
[%@lib ilogbf]
[%@lib ilogbl]
[%@lib isfinite]
[%@lib isgreater]
[%@lib isgreaterequal]
[%@lib isinf]
[%@lib isless]
[%@lib islessequal]
[%@lib islessgreater]
[%@lib isnan]
[%@lib isnormal]
[%@lib isunordered]
[%@lib ldexp]
[%@lib ldexpf]
[%@lib ldexpl]
[%@lib lgamma]
[%@lib lgammaf]
[%@lib lgammal]
[%@lib llrint]
[%@lib llrintf]
[%@lib llrintl]
[%@lib llround]
[%@lib llroundf]
[%@lib llroundl]
[%@lib log]
[%@lib log10]
[%@lib log10f]
[%@lib log10l]
[%@lib log1p]
[%@lib log1pf]
[%@lib log1pl]
[%@lib log2]
[%@lib log2f]
[%@lib log2l]
[%@lib logb]
[%@lib logbf]
[%@lib logbl]
[%@lib logf]
[%@lib logl]
[%@lib lrint]
[%@lib lrintf]
[%@lib lrintl]
[%@lib lround]
[%@lib lroundf]
[%@lib lroundl]
[%@lib math_errhandling]
[%@lib modf]
[%@lib modff]
[%@lib modfl]
[%@lib nan]
[%@lib nanf]
[%@lib nanl]
[%@lib nearbyint]
[%@lib nearbyintf]
[%@lib nearbyintl]
[%@lib nextafter]
[%@lib nextafterf]
[%@lib nextafterl]
[%@lib nexttoward]
[%@lib nexttowardf]
[%@lib nexttowardl]
[%@lib pow]
[%@lib powf]
[%@lib powl]
[%@lib remainder]
[%@lib remainderf]
[%@lib remainderl]
[%@lib remquo]
[%@lib remquof]
[%@lib remquol]
[%@lib rint]
[%@lib rintf]
[%@lib rintl]
[%@lib round]
[%@lib roundf]
[%@lib roundl]
[%@lib scalbin]
[%@lib scalbinf]
[%@lib scalbinl]
[%@lib scalbn]
[%@lib scalbnf]
[%@lib scalbnl]
[%@lib signbit]
[%@lib sin]
[%@lib sinf]
[%@lib sinh]
[%@lib sinhf]
[%@lib sinhl]
[%@lib sinl]
[%@lib sqrt]
[%@lib sqrtf]
[%@lib sqrtl]
[%@lib tan]
[%@lib tanf]
[%@lib tanh]
[%@lib tanhf]
[%@lib tanhl]
[%@lib tanl]
[%@lib tgamma]
[%@lib tgammaf]
[%@lib tgammal]
[%@lib trunc]
[%@lib truncf]
[%@lib truncl]
[codeblock:synopsis]
namespace std {
  using float_t = [[redoc("[=seebelow]")]];
  using double_t = [[redoc("[=seebelow]")]];
}

#define HUGE_VAL [[redoc("[=seebelow]")]]
#define HUGE_VALF [[redoc("[=seebelow]")]]
#define HUGE_VALL [[redoc("[=seebelow]")]]
#define INFINITY [[redoc("[=seebelow]")]]
#define NAN [[redoc("[=seebelow]")]]
#define FP_INFINITE [[redoc("[=seebelow]")]]
#define FP_NAN [[redoc("[=seebelow]")]]
#define FP_NORMAL [[redoc("[=seebelow]")]]
#define FP_SUBNORMAL [[redoc("[=seebelow]")]]
#define FP_ZERO [[redoc("[=seebelow]")]]
#define FP_FAST_FMA [[redoc("[=seebelow]")]]
#define FP_FAST_FMAF [[redoc("[=seebelow]")]]
#define FP_FAST_FMAL [[redoc("[=seebelow]")]]
#define FP_ILOGB0 [[redoc("[=seebelow]")]]
#define FP_ILOGBNAN [[redoc("[=seebelow]")]]
#define MATH_ERRNO [[redoc("[=seebelow]")]]
#define MATH_ERREXCEPT [[redoc("[=seebelow]")]]

#define math_errhandling [[redoc("[=seebelow]")]]

namespace std {
  constexpr [[redoc("^>")]]floating-point-type acos([[redoc("^>")]]floating-point-type x);
  constexpr float acosf(float x);
  constexpr long double acosl(long double x);

  constexpr [[redoc("^>")]]floating-point-type asin([[redoc("^>")]]floating-point-type x);
  constexpr float asinf(float x);
  constexpr long double asinl(long double x);

  constexpr [[redoc("^>")]]floating-point-type atan([[redoc("^>")]]floating-point-type x);
  constexpr float atanf(float x);
  constexpr long double atanl(long double x);

  constexpr [[redoc("^>")]]floating-point-type atan2([[redoc("^>")]]floating-point-type x);
  constexpr float atan2f(float y, float x);
  constexpr long double atan2l(long double y, long double x);

  constexpr [[redoc("^>")]]floating-point-type cos([[redoc("^>")]]floating-point-type x);
  constexpr float cosf(float x);
  constexpr long double cosl(long double x);

  constexpr [[redoc("^>")]]floating-point-type sin([[redoc("^>")]]floating-point-type x);
  constexpr float sinf(float x);
  constexpr long double sinl(long double x);

  constexpr [[redoc("^>")]]floating-point-type tan([[redoc("^>")]]floating-point-type x);
  constexpr float tanf(float x);
  constexpr long double tanl(long double x);

  constexpr [[redoc("^>")]]floating-point-type acosh([[redoc("^>")]]floating-point-type x);
  constexpr float acoshf(float x);
  constexpr long double acoshl(long double x);

  constexpr [[redoc("^>")]]floating-point-type asinh([[redoc("^>")]]floating-point-type x);
  constexpr float asinhf(float x);
  constexpr long double asinhl(long double x);

  constexpr [[redoc("^>")]]floating-point-type atanh([[redoc("^>")]]floating-point-type x);
  constexpr float atanhf(float x);
  constexpr long double atanhl(long double x);

  constexpr [[redoc("^>")]]floating-point-type cosh([[redoc("^>")]]floating-point-type x);
  constexpr float coshf(float x);
  constexpr long double coshl(long double x);

  constexpr [[redoc("^>")]]floating-point-type sinh([[redoc("^>")]]floating-point-type x);
  constexpr float sinhf(float x);
  constexpr long double sinhl(long double x);

  constexpr [[redoc("^>")]]floating-point-type tanh([[redoc("^>")]]floating-point-type x);
  constexpr float tanhf(float x);
  constexpr long double tanhl(long double x);

  constexpr [[redoc("^>")]]floating-point-type exp([[redoc("^>")]]floating-point-type x);
  constexpr float expf(float x);
  constexpr long double expl(long double x);

  constexpr [[redoc("^>")]]floating-point-type exp2([[redoc("^>")]]floating-point-type x);
  constexpr float exp2f(float x);
  constexpr long double exp2l(long double x);

  constexpr [[redoc("^>")]]floating-point-type expm1([[redoc("^>")]]floating-point-type x);
  constexpr float expm1f(float x);
  constexpr long double expm1l(long double x);

  constexpr [[redoc("^>")]]floating-point-type frexp([[redoc("^>")]]floating-point-type value, int* exp);
  constexpr float frexpf(float value, int* exp);
  constexpr long double frexpl(long double value, int* exp);

  constexpr int ilogb([[redoc("^>")]]floating-point-type x);
  constexpr int ilogbf(float x);
  constexpr int ilogbl(long double x);

  constexpr [[redoc("^>")]]floating-point-type ldexp([[redoc("^>")]]floating-point-type x, int exp);
  constexpr float ldexpf(float x, int exp);
  constexpr long double ldexpl(long double x, int exp);

  constexpr [[redoc("^>")]]floating-point-type log([[redoc("^>")]]floating-point-type x);
  constexpr float logf(float x);
  constexpr long double logl(long double x);

  constexpr [[redoc("^>")]]floating-point-type log10([[redoc("^>")]]floating-point-type x);
  constexpr float log10f(float x);
  constexpr long double log10l(long double x);

  constexpr [[redoc("^>")]]floating-point-type log1p([[redoc("^>")]]floating-point-type x);
  constexpr float log1pf(float x);
  constexpr long double log1pl(long double x);

  constexpr [[redoc("^>")]]floating-point-type log2([[redoc("^>")]]floating-point-type x);
  constexpr float log2f(float x);
  constexpr long double log2l(long double x);

  constexpr [[redoc("^>")]]floating-point-type logb([[redoc("^>")]]floating-point-type x);
  constexpr float logbf(float x);
  constexpr long double logbl(long double x);

  constexpr [[redoc("^>")]]floating-point-type modf([[redoc("^>")]]floating-point-type value, [[redoc("^>")]]floating-point-type* iptr);
  constexpr float modff(float value, float* iptr);
  constexpr long double modfl(long double value, long double* iptr);

  constexpr [[redoc("^>")]]floating-point-type scalbn([[redoc("^>")]]floating-point-type x, int n);
  constexpr float scalbnf(float x, int n);
  constexpr long double scalbnl(long double x, int n);

  constexpr [[redoc("^>")]]floating-point-type scalbln([[redoc("^>")]]floating-point-type x, long int n);
  constexpr float scalblnf(float x, long int n);
  constexpr long double scalblnl(long double x, long int n);

  constexpr [[redoc("^>")]]floating-point-type cbrt([[redoc("^>")]]floating-point-type x);
  constexpr float cbrtf(float x);
  constexpr long double cbrtl(long double x);

  // [:en] [#c.math.abs], absolute values \
  [:zh_CN] [#c.math.abs]，绝对值
  constexpr int abs(int j);                                             // [=freestanding]
  constexpr long int abs(long int j);                                   // [=freestanding]
  constexpr long long int abs(long long int j);                         // [=freestanding]
  constexpr [[redoc("^>")]]floating-point-type abs([[redoc("^>")]]floating-point-type j);            // [=freestanding-deleted]

  constexpr [[redoc("^>")]]floating-point-type fabs([[redoc("^>")]]floating-point-type x);
  constexpr float fabsf(float x);
  constexpr long double fabsl(long double x);

  constexpr [[redoc("^>")]]floating-point-type hypot([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr float hypotf(float x, float y);
  constexpr long double hypotl(long double x, long double y);

  // [:en] [#c.math.hypot3], three-dimensional hypotenuse \
  [:zh_CN] [#c.math.hypot3]，三维斜边长
  constexpr [[redoc("^>")]]floating-point-type hypot([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y,
                                      [[redoc("^>")]]floating-point-type z);

  constexpr [[redoc("^>")]]floating-point-type pow([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr float powf(float x, float y);
  constexpr long double powl(long double x, long double y);

  constexpr [[redoc("^>")]]floating-point-type sqrt([[redoc("^>")]]floating-point-type x);
  constexpr float sqrtf(float x);
  constexpr long double sqrtl(long double x);

  constexpr [[redoc("^>")]]floating-point-type erf([[redoc("^>")]]floating-point-type x);
  constexpr float erff(float x);
  constexpr long double erfl(long double x);

  constexpr [[redoc("^>")]]floating-point-type erfc([[redoc("^>")]]floating-point-type x);
  constexpr float erfcf(float x);
  constexpr long double erfcl(long double x);

  constexpr [[redoc("^>")]]floating-point-type lgamma([[redoc("^>")]]floating-point-type x);
  constexpr float lgammaf(float x);
  constexpr long double lgammal(long double x);

  constexpr [[redoc("^>")]]floating-point-type tgamma([[redoc("^>")]]floating-point-type x);
  constexpr float tgammaf(float x);
  constexpr long double tgammal(long double x);

  constexpr double[[redoc("^>")]]floating-point-type ceil([[redoc("^>")]]floating-point-type x);
  constexpr float ceilf(float x);
  constexpr long double ceill(long double x);

  constexpr [[redoc("^>")]]floating-point-type floor([[redoc("^>")]]floating-point-type x);
  constexpr float floorf(float x);
  constexpr long double floorl(long double x);

  [[redoc("^>")]]floating-point-type nearbyint([[redoc("^>")]]floating-point-type x);
  float nearbyintf(float x);
  long double nearbyintl(long double x);

  [[redoc("^>")]]floating-point-type rint([[redoc("^>")]]floating-point-type x);
  float rintf(float x);
  long double rintl(long double x);

  long int lrint([[redoc("^>")]]floating-point-type x);
  long int lrintf(float x);
  long int lrintl(long double x);

  long long int llrint([[redoc("^>")]]floating-point-type x);
  long long int llrintf(float x);
  long long int llrintl(long double x);

  constexpr [[redoc("^>")]]floating-point-type round([[redoc("^>")]]floating-point-type x);
  constexpr float roundf(float x);
  constexpr long double roundl(long double x);

  constexpr long int lround([[redoc("^>")]]floating-point-type x);
  constexpr long int lroundf(float x);
  constexpr long int lroundl(long double x);

  constexpr long long int llround([[redoc("^>")]]floating-point-type x);
  constexpr long long int llroundf(float x);
  constexpr long long int llroundl(long double x);

  constexpr [[redoc("^>")]]floating-point-type trunc([[redoc("^>")]]floating-point-type x);
  constexpr float truncf(float x);
  constexpr long double truncl(long double x);

  constexpr [[redoc("^>")]]floating-point-type fmod([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr float fmodf(float x, float y);
  constexpr long double fmodl(long double x, long double y);

  constexpr [[redoc("^>")]]floating-point-type remainder([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr float remainderf(float x, float y);
  constexpr long double remainderl(long double x, long double y);

  constexpr [[redoc("^>")]]floating-point-type remquo([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y, int* quo);
  constexpr float remquof(float x, float y, int* quo);
  constexpr long double remquol(long double x, long double y, int* quo);

  constexpr [[redoc("^>")]]floating-point-type copysign([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr float copysignf(float x, float y);
  constexpr long double copysignl(long double x, long double y);

  double nan(const char* tagp);
  float nanf(const char* tagp);
  long double nanl(const char* tagp);

  constexpr [[redoc("^>")]]floating-point-type nextafter([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr float nextafterf(float x, float y);
  constexpr long double nextafterl(long double x, long double y);

  constexpr [[redoc("^>")]]floating-point-type nexttoward([[redoc("^>")]]floating-point-type x, long double y);
  constexpr float nexttowardf(float x, long double y);
  constexpr long double nexttowardl(long double x, long double y);

  constexpr [[redoc("^>")]]floating-point-type fdim([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr float fdimf(float x, float y);
  constexpr long double fdiml(long double x, long double y);

  constexpr [[redoc("^>")]]floating-point-type fmax([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr float fmaxf(float x, float y);
  constexpr long double fmaxl(long double x, long double y);

  constexpr [[redoc("^>")]]floating-point-type fmin([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr float fminf(float x, float y);
  constexpr long double fminl(long double x, long double y);

  constexpr [[redoc("^>")]]floating-point-type fma([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y,
                                    [[redoc("^>")]]floating-point-type z);
  constexpr float fmaf(float x, float y, float z);
  constexpr long double fmal(long double x, long double y, long double z);

  // [:en] [#c.math.lerp], linear interpolation \
  [:zh_CN] [#c.math.lerp]，线性插值
  constexpr [[redoc("^>")]]floating-point-type lerp([[redoc("^>")]]floating-point-type a, [[redoc("^>")]]floating-point-type b,
                                     [[redoc("^>")]]floating-point-type t) noexcept;

  // [:en] [#c.math.fpclass], classification / comparison functions \
  [:zh_CN] [#c.math.fpclass]，分类/比较函数
  constexpr int fpclassify([[redoc("^>")]]floating-point-type x);
  constexpr bool isfinite([[redoc("^>")]]floating-point-type x);
  constexpr bool isinf([[redoc("^>")]]floating-point-type x);
  constexpr bool isnan([[redoc("^>")]]floating-point-type x);
  constexpr bool isnormal([[redoc("^>")]]floating-point-type x);
  constexpr bool signbit([[redoc("^>")]]floating-point-type x);
  constexpr bool isgreater([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr bool isgreaterequal([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr bool isless([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr bool islessequal([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr bool islessgreater([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  constexpr bool isunordered([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);

  // [:en] [#sf.cmath], mathematical special functions \
  [:zh_CN] [#sf.cmath]，数学特殊函数

  // [:en] [#sf.cmath.assoc.laguerre], associated Laguerre polynomials \
  [:zh_CN] [#sf.cmath.assoc.laguerre]，连带拉盖尔多项式
  [[redoc("^>")]]floating-point-type assoc_laguerre(unsigned n, unsigned m, [[redoc("^>")]]floating-point-type x);
  float        assoc_laguerref(unsigned n, unsigned m, float x);
  long double  assoc_laguerrel(unsigned n, unsigned m, long double x);

  // [:en] [#sf.cmath.assoc.legendre], associated Legendre functions \
  [:zh_CN] [#sf.cmath.assoc.legendre]，连带勒让德函数
  [[redoc("^>")]]floating-point-type assoc_legendre(unsigned l, unsigned m, [[redoc("^>")]]floating-point-type x);
  float        assoc_legendref(unsigned l, unsigned m, float x);
  long double  assoc_legendrel(unsigned l, unsigned m, long double x);

  // [:en] [#sf.cmath.beta], beta function \
  [:zh_CN] [#sf.cmath.beta]，贝塔函数
  [[redoc("^>")]]floating-point-type beta([[redoc("^>")]]floating-point-type x, [[redoc("^>")]]floating-point-type y);
  float        betaf(float x, float y);
  long double  betal(long double x, long double y);

  // [:en] [#sf.cmath.comp.ellint.1], complete elliptic integral of the first kind \
  [:zh_CN] [#sf.cmath.comp.ellint.1]，第一类完全椭圆积分
  [[redoc("^>")]]floating-point-type comp_ellint_1([[redoc("^>")]]floating-point-type k);
  float        comp_ellint_1f(float k);
  long double  comp_ellint_1l(long double k);

  // [:en] [#sf.cmath.comp.ellint.2], complete elliptic integral of the second kind \
  [:zh_CN] [#sf.cmath.comp.ellint.2]，第二类完全椭圆积分
  [[redoc("^>")]]floating-point-type comp_ellint_2([[redoc("^>")]]floating-point-type k);
  float        comp_ellint_2f(float k);
  long double  comp_ellint_2l(long double k);

  // [:en] [#sf.cmath.comp.ellint.3], complete elliptic integral of the third kind \
  [:zh_CN] [#sf.cmath.comp.ellint.3]，第三类完全椭圆积分
  [[redoc("^>")]]floating-point-type comp_ellint_3([[redoc("^>")]]floating-point-type k, [[redoc("^>")]]floating-point-type nu);
  float        comp_ellint_3f(float k, float nu);
  long double  comp_ellint_3l(long double k, long double nu);

  // [:en] [#sf.cmath.cyl.bessel.i], regular modified cylindrical Bessel functions \
  [:zh_CN] [#sf.cmath.cyl.bessel.i]，规则变形圆柱贝塞尔函数
  [[redoc("^>")]]floating-point-type cyl_bessel_i([[redoc("^>")]]floating-point-type nu, [[redoc("^>")]]floating-point-type x);
  float        cyl_bessel_if(float nu, float x);
  long double  cyl_bessel_il(long double nu, long double x);

  // [:en] [#sf.cmath.cyl.bessel.j], cylindrical Bessel functions of the first kind \
  [:zh_CN] [#sf.cmath.cyl.bessel.j]，第一类圆柱贝塞尔函数
  [[redoc("^>")]]floating-point-type cyl_bessel_j([[redoc("^>")]]floating-point-type nu, [[redoc("^>")]]floating-point-type x);
  float        cyl_bessel_jf(float nu, float x);
  long double  cyl_bessel_jl(long double nu, long double x);

  // [:en] [#sf.cmath.cyl.bessel.k], irregular modified cylindrical Bessel functions \
  [:zh_CN] [#sf.cmath.cyl.bessel.k]，不规则变形圆柱贝塞尔函数
  [[redoc("^>")]]floating-point-type cyl_bessel_k([[redoc("^>")]]floating-point-type nu, [[redoc("^>")]]floating-point-type x);
  float        cyl_bessel_kf(float nu, float x);
  long double  cyl_bessel_kl(long double nu, long double x);

  // [:en] [#sf.cmath.cyl.neumann], cylindrical Neumann functions; \
  [:zh_CN] [#sf.cmath.cyl.neumann]，圆柱诺依曼函数；
  // [:en@~] cylindrical Bessel functions of the second kind \
  [:zh_CN@~] 第二类圆柱贝塞尔函数
  [[redoc("^>")]]floating-point-type cyl_neumann([[redoc("^>")]]floating-point-type nu, [[redoc("^>")]]floating-point-type x);
  float        cyl_neumannf(float nu, float x);
  long double  cyl_neumannl(long double nu, long double x);

  // [:en] [#sf.cmath.ellint.1], incomplete elliptic integral of the first kind \
  [:zh_CN] [#sf.cmath.ellint.1]，第一类不完全椭圆积分
  [[redoc("^>")]]floating-point-type ellint_1([[redoc("^>")]]floating-point-type k, [[redoc("^>")]]floating-point-type phi);
  float        ellint_1f(float k, float phi);
  long double  ellint_1l(long double k, long double phi);

  // [:en] [#sf.cmath.ellint.2], incomplete elliptic integral of the second kind \
  [:zh_CN] [#sf.cmath.ellint.2]，第二类不完全椭圆积分
  [[redoc("^>")]]floating-point-type ellint_2([[redoc("^>")]]floating-point-type k, [[redoc("^>")]]floating-point-type phi);
  float        ellint_2f(float k, float phi);
  long double  ellint_2l(long double k, long double phi);

  // [:en] [#sf.cmath.ellint.3], incomplete elliptic integral of the third kind \
  [:zh_CN] [#sf.cmath.ellint.3]，第三类不完全椭圆积分
  [[redoc("^>")]]floating-point-type ellint_3([[redoc("^>")]]floating-point-type k, [[redoc("^>")]]floating-point-type nu,
                                 [[redoc("^>")]]floating-point-type phi);
  float        ellint_3f(float k, float nu, float phi);
  long double  ellint_3l(long double k, long double nu, long double phi);

  // [:en] [#sf.cmath.expint], exponential integral \
  [:zh_CN] [#sf.cmath.expint]，指数积分
  [[redoc("^>")]]floating-point-type expint([[redoc("^>")]]floating-point-type x);
  float        expintf(float x);
  long double  expintl(long double x);

  // [:en] [#sf.cmath.hermite], Hermite polynomials \
  [:zh_CN] [#sf.cmath.hermite]，埃尔米特多项式
  [[redoc("^>")]]floating-point-type hermite(unsigned n, [[redoc("^>")]]floating-point-type x);
  float        hermitef(unsigned n, float x);
  long double  hermitel(unsigned n, long double x);

  // [:en] [#sf.cmath.laguerre], Laguerre polynomials \
  [:zh_CN] [#sf.cmath.laguerre]，拉盖尔多项式
  [[redoc("^>")]]floating-point-type laguerre(unsigned n, [[redoc("^>")]]floating-point-type x);
  float        laguerref(unsigned n, float x);
  long double  laguerrel(unsigned n, long double x);

  // [:en] [#sf.cmath.legendre], Legendre polynomials \
  [:zh_CN] [#sf.cmath.legendre]，勒让德多项式
  [[redoc("^>")]]floating-point-type legendre(unsigned l, [[redoc("^>")]]floating-point-type x);
  float        legendref(unsigned l, float x);
  long double  legendrel(unsigned l, long double x);

  // [:en] [#sf.cmath.riemann.zeta], Riemann zeta function \
  [:zh_CN] [#sf.cmath.riemann.zeta]，黎曼 zeta 函数
  [[redoc("^>")]]floating-point-type riemann_zeta([[redoc("^>")]]floating-point-type x);
  float        riemann_zetaf(float x);
  long double  riemann_zetal(long double x);

  // [:en] [#sf.cmath.sph.bessel], spherical Bessel functions of the first kind \
  [:zh_CN] [#sf.cmath.sph.bessel]，第一类球面贝塞尔函数
  [[redoc("^>")]]floating-point-type sph_bessel(unsigned n, [[redoc("^>")]]floating-point-type x);
  float        sph_besself(unsigned n, float x);
  long double  sph_bessell(unsigned n, long double x);

  // [:en] [#sf.cmath.sph.legendre], spherical associated Legendre functions \
  [:zh_CN] [#sf.cmath.sph.legendre]，球面连带勒让德函数
  [[redoc("^>")]]floating-point-type sph_legendre(unsigned l, unsigned m, [[redoc("^>")]]floating-point-type theta);
  float        sph_legendref(unsigned l, unsigned m, float theta);
  long double  sph_legendrel(unsigned l, unsigned m, long double theta);

  // [:en] [#sf.cmath.sph.neumann], spherical Neumann functions; \
  [:zh_CN] [#sf.cmath.sph.neumann]，球面诺依曼函数；
  // [:en@~] spherical Bessel functions of the second kind \
  [:zh_CN@~] 第二类球面贝塞尔函数
  [[redoc("^>")]]floating-point-type sph_neumann(unsigned n, [[redoc("^>")]]floating-point-type x);
  float        sph_neumannf(unsigned n, float x);
  long double  sph_neumannl(unsigned n, long double x);
}
[codeblock:end]

[para]
[:en] The contents and meaning of the header [?libheader cmath] are the same as
the C standard library header [?libheader math.h], with the addition of a
three-dimensional hypotenuse function ([#c.math.hypot3]), a linear interpolation
function ([#c.math.lerp]), and the mathematical special functions described in
[#sf.cmath].
[:zh_CN] 头文件 [?libheader cmath] 的内容和含义与 C 标准程序库头文件
[?libheader math.h] 相同，但添加了三维斜边函数（[#c.math.hypot3]），线性插值函数
（[#c.math.lerp]），和 [#sf.cmath] 中所述的各数学特殊函数。

[begin:note]
[:en] Several functions have additional overloads in this document, but they
have the same behavior as in the C standard library ([#library.c]).
[:zh_CN] 一些函数在本文档中有额外的重载，但它们的行为与 C 标准程序库中的相同
（[#library.c]）。
[end:note]

[para]
[:en] For each function with at least one parameter of type [^floating-point-type],
the implementation provides an overload for each cv-unqualified floating-point
type ([#basic.fundamental]) where all uses of [^floating-point-type] in the
function signature are replaced with that floating-point type.
[:zh_CN] 对每个具有至少一个 [^floating-point-type] 类型形参的函数，实现应当为
每个 cv 未限定的浮点类型（[#basic.fundamental]）提供一个重载，其函数签名中的每个
[^floating-point-type] 均被替换为这个浮点类型。

[para]
[:en] For each function with at least one parameter of type [^floating-point-type]
other than [`abs], the implementation also provides additional overloads
sufficient to ensure that, if every argument corresponding to a
[^floating-point-type] parameter has arithmetic type, then every such argument
is effectively cast to the floating-point type with the greatest floating-point
conversion rank and greatest floating-point conversion subrank among the types
of all such arguments, where arguments of integer type are considered to have
the same floating-point conversion rank as [`double].
[:zh_CN] 除 [`abs] 之外，对每个具有至少一个 [^floating-point-type] 类型形参的
函数，实现还提供额外的重载使得足以确保，如果对应于 [^floating-point-type] 形参的
每个实参均为算术类型，则每个这样的实参均实际被转换为所有这些实参的类型中具有最大
浮点转换等级和最大浮点转换子等级的浮点类型，其中整数类型的实参被当做具有与
[`double] 相同的浮点转换等级。

[:en] If no such floating-point type with the greatest rank and subrank exists,
then overload resolution does not result in a usable candidate
([#over.match.general]) from the overloads provided by the implementation.
[:zh_CN] 如果不存在具有最大等级和子等级的浮点类型，则重载决议从实现提供的重载中
无法找到可用的候选（[#over.match.general]）。

[para]
[:en] An invocation of [`nexttoward] is ill-formed if the argument corresponding
to the [^floating-point-type] parameter has extended floating-point type.
[:zh_CN] 如果对应于 [^floating-point-type] 形参的实参具有扩充浮点类型，则对
[`nexttoward] 的调用非良构。
