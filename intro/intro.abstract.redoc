[section#intro.abstract
    [:en] Abstract machine
    [:zh_CN] 抽象机器
]
[para]
[:en]
[% program execution [!abstract machine]]
The semantic descriptions in this document define a parameterized
nondeterministic abstract machine.
[:zh_CN]
[% 程序的执行 [!抽象机器]]
本文档中的语义说明，定义了一个参数化的非确定性的抽象机器。

[:en]
This document places no requirement on the structure of conforming
implementations.
[:zh_CN]
本文档对符合标准的实现的内部结构不施以任何规定。

[:en]
In particular, they need not copy or emulate the structure of the abstract
machine.
[:zh_CN]
尤其是，它们并不需要复制或模拟这个抽象机器的结构。

[:en]
[%as-if rule][%behavior [!observable]]
Rather, conforming implementations are required to emulate (only) the observable
behavior of the abstract machine as explained below.[#:note#fn:$section.1]
[:zh_CN]
[%“如同”规则 [@如同规则]] [%行为 [!可观察～]]
更确切地说，符合标准的实现需要模拟的（仅仅）是下文阐明的抽象机器的可观察行为。
[#:note#fn:$section.1]

[note:foot#fn:$section.1]
[:en]
This provision is sometimes called the ["as-if] rule, because an implementation
is free to disregard any requirement of this document as long as the result is
[em as if] the requirement had been obeyed, as far as can be determined from the
observable behavior of the program.
[:zh_CN]
这条往往被称作“如同”规则，因为实现可以自由忽略本文档中的任何规定，只要从程序的
可观察行为能够确定，其结果[em 如同]该规定已经被遵守即可。

[:en]
For instance, an actual implementation need not evaluate part of an expression
if it can deduce that its value is not used and that no [%side effects] side
effects affecting the observable behavior of the program are produced.
[:zh_CN]
例如，如果实现可以推导出一个表达式中的某部分的值不会被用到，并且不会造成影响
程序的可观察行为的[%副作用]副作用，这个实现就不必对其求值。
[note:end]

[para]
[:en]
[%behavior [!implementation-defined]]
Certain aspects and operations of the abstract machine are described in this
document as implementation-defined (for example, [`sizeof(int)]).
[:zh_CN]
[%行为 [!由实现定义的～]]
本文档将抽象机器的某些特定方面和操作描述为由实现定义的（如 [`sizeof(int)]）。

[:en]
These constitute the parameters of the abstract machine.
[:zh_CN]
它们构成了抽象机器的参数。

[:en]
Each implementation shall include documentation describing its characteristics
and behavior in these respects.[#:note#fn:$section.2]
[:zh_CN]
每个实现都应包含文档以说明其在这些方面的具体特性和行为。[#:note#fn:$section.2]

[note:foot#fn:$section.2]
[:en]
This documentation also includes conditionally-supported constructs and
locale-specific behavior.
[:zh_CN]
此文档中还包括有条件支持的构造和特定于地域的行为。

[:en]
See [#intro.compliance].
[:zh_CN]
参见 [#intro.compliance]。
[note:end]

[:en]
Such documentation shall define the instance of the abstract machine that
corresponds to that implementation (referred to as the ["corresponding instance]
below).
[:zh_CN]
此文档中应当定义对应于该实现的抽象机器的实例（下文称为“对应实例”）。

[para]
[:en]
[%behavior [!unspecified]]
Certain other aspects and operations of the abstract machine are described in
this document as unspecified (for example, evaluation of expressions in a
[~new-initializer] if the allocation function fails to allocate memory
([#expr.new])).
[:zh_CN]
[%行为 [!未指明的～]]
本文档将抽象机器的其他一些特定方面和操作描述为未指明的（例如，当分配函数分配内存
失败时，[~new-初始化式]中的表达式的求值（[#expr.new]））。

[:en]
Where possible, this document defines a set of allowable behaviors.
[:zh_CN]
只要可能，本文档都将定义一组可接受的行为。

[:en]
These define the nondeterministic aspects of the abstract machine.
[:zh_CN]
它们定义了抽象机器的非确定性的方面。

[:en]
An instance of the abstract machine can thus have more than one possible
execution for a given program and a given input.
[:zh_CN]
对于某个给定程序和给定数据，抽象机器的实例将可能因而产生不只一种可能的执行。

[para]
[:en]
[%behavior [!undefined]]
Certain other operations are described in this document as undefined (for
example, the effect of attempting to modify a const object).
[:zh_CN]
[%行为 [!未定义的～]]
其他一些特定的操作被本文档称为未定义的（例如，试图修改某个 const 对象的后果）。

[enter:note]
[:en]
This document imposes no requirements on the behavior of programs that contain
undefined behavior.
[:zh_CN]
本文档对包含未定义行为的程序的行为不作任何规定。
[exit:note]

[para]
[:en]
[%program [!well-formed]]
[%behavior [!observable]]
A conforming implementation executing a well-formed program shall produce the
same observable behavior as one of the possible executions of the corresponding
instance of the abstract machine with the same program and the same input.
[:zh_CN]
[%程序 [!良构的～]]
[%行为 [!可观察～]]
符合标准的实现执行良构的程序时产生的可观察行为，应该与该实现的对应抽象机器实例
依据同一程序和同一输出产生的可能的执行之一相一致。

[:en]
[%behavior [!undefined]]
However, if any such execution contains an undefined operation, this document
places no requirement on the implementation executing that program with that
input (not even with regard to operations preceding the first undefined
operation).
[:zh_CN]
[%行为 [!未定义的～]]
然而，如果任何这种执行中包含未定义的操作，本文档不会对以该输入执行该程序的实现作
任何规定（甚至对于第一个未定义操作之前的操作也不作规定）。

[para]
[:en]
[%conformance requirements]
The least requirements on a conforming implementation are:
[:zh_CN]
[%遵从性规定]
对符合标准的实现的最低要求是：

[list:ul]

[item]
[:en]
Accesses through volatile glvalues are evaluated strictly according to the rules
of the abstract machine.
[:zh_CN]
通过 volatile 左值进行的访问是严格按照抽象机器的规则进行求值的。

[item]
[:en]
At program termination, all data written into files shall be identical to one of
the possible results that execution of the program according to the abstract
semantics would have produced.
[:zh_CN]
程序终止时，写入文件的所有数据应与该程序根据抽象语义的执行所产生可能的结果之一
相吻合。

[item]
[:en]
The input and output dynamics of interactive devices shall take place in such a
fashion that prompting output is actually delivered before a program waits for
input.
[:zh_CN]
交互设备的输入输出的动作的行为方式应当为：在程序开始等待输入之前，提示输出已经
确实发出。

[:en]
What constitutes an interactive device is [%@impldef interactive device]
implementation-defined.
[:zh_CN]
交互设备的构成[%@impldef 交互式设备]由实现定义。

[list:end]

[:en]
These collectively are referred to as the [+observable behavior [%behavior
[!observable]]] of the program.
[:zh_CN]
这些共同称之为程序的[+可观察行为 [%行为[!可观察～]]]。

[enter:note]
[:en]
More stringent correspondences between abstract and actual semantics may be
defined by each implementation.
[:zh_CN]
抽象语义和实际语义之间更严格的对应应由每个实现各自定义。
[exit:note]

[para]
[:en]
[%operator [!precedence of]]
[%expression [!order of evaluation of]]
[:zh_CN]
[%运算符 [!～优先级]]
[%表达式 [!～求值顺序]]

[enter:note]
[:en]
Operators can be regrouped according to the usual mathematical rules only where
the operators really are associative or commutative.[#:note#fn:$section.3]
[:zh_CN]
仅当运算符在该处确实具有结合性或交换性时，才能根据常规的数学规则进行重新组合。
[#:note#fn:$section.3]

[note:foot#fn:$section.3]
[:en]
Overloaded operators are never assumed to be associative or commutative.
[:zh_CN]
重载运算符总不具有结合性或交换性。
[note:end]

[:en]
For example, in the following fragment
[:zh_CN]
例如，在如下片段中

[codeblock]
int a, b;
/* ... */
a = a + 32760 + b + 5;
[codeblock:end]

[:en@~]
the expression statement behaves exactly the same as
[:zh_CN@~]
根据运算符的结合性和优先级，该表达式与

[codeblock]
a = (((a + 32760) + b) + 5);
[codeblock:end]

[:en@~]
due to the associativity and precedence of these operators.
[:zh_CN@~]
具有完全相同的行为。

[:en]
Thus, the result of the sum [`(a + 32760)] is next added to [`b], and that
result is then added to 5 which results in the value assigned to [`a].
[:zh_CN]
按此，求和 [`(a + 32760)] 的结果接着与 [`b] 相加，然后对其结果加上 5，所得的
值被赋值给 [`a]。

[:en]
On a machine in which overflows produce an exception and in which the range of
values representable by an [`int] is [=crange(-32768,+32767)], the
implementation cannot rewrite this expression as
[:zh_CN]
在溢出产生异常且 [`int] 能够表示的值的范围是 [=crange(-32768,+32767)] 的机器上，
实现不能把该表达式重写为

[codeblock]
a = ((a + b) + 32765);
[codeblock:end]

[:en@~]
since if the values for [`a] and [`b] were, respectively, -32754 and -15, the
sum [`a + b] would produce an exception while the original expression would not;
[:zh_CN@~]
因为若 [`a] 和 [`b] 的值分别为 -32754 和 -15，则 [`a + b] 的和就会导致异常，
而原来的表达式却不会；

[:en@~]
nor can the expression be rewritten either as
[:zh_CN@~]
该表达式也不能重写为

[codeblock]
a = ((a + 32765) + b);
[codeblock:end]

[:en@~]
or
[:zh_CN@~]
或

[codeblock]
a = (a + (b + 32765));
[codeblock:end]

[:en@~]
since the values for [`a] and [`b] might have been, respectively, 4 and -8 or
-17 and 12.
[:zh_CN@~]
因为 [`a] 和 [`b] 的值可能分别是 4 和 -8，或 -17 和 12。

[:en]
However on a machine in which overflows do not produce an exception and in which
the results of overflows are reversible, the above expression statement can be
rewritten by the implementation in any of the above ways because the same result
will occur.
[:zh_CN]
然而在溢出不导致异常且溢出结果可逆的机器上，上面的表达式语句就可以被实现以上述
任意方式重写，因为它们所产生的结果相同。

[exit:note]
