[section#fs.class.path
    [:en] Class [`path]
    [:zh_CN] 类 [`path]
]

[%@library path]
[para]
[:en] An object of class [`path] represents a path ([#fs.def.path]) and contains
a pathname ([#fs.def.pathname]).
[:zh_CN] 类 [`path] 的对象表示一个路径（[#fs.def.path]），包含一个路径名
（[#fs.def.pathname]）。

[:en] Such an object is concerned only with the lexical and syntactic aspects
of a path.
[:zh_CN] 这种对象仅关注路径的词法和语法。

[:en] The path does not necessarily exist in external storage, and the pathname
is not necessarily valid for the current operating system or for a particular
file system.
[:zh_CN] 而该路径不必在外部存储中存在，且该路径名对于当前操作系统或某个特定文件
系统也不必是有效的。

[para]
[enter:note]
[:en] Class [`path] is used to support the differences between the string types
used by different operating systems to represent pathnames, and to perform
conversions between encodings when necessary.
[:zh_CN] 使用类 [`path] 来支持不同操作系统用以表示路径名的字符串类型之间的差异，
并当需要时实施不同编码之间的转换。
[exit:note]

[codeblock:synopsis [!:mark SeeBelow] ]
namespace std::filesystem {
  class path {
  public:
    using value_type  = [=SeeBelow];
    using string_type = basic_string<value_type>;
    static constexpr value_type preferred_separator = [=SeeBelow];

    // [:en] [#fs.enum.path.format], enumeration [`format]
    // [|:zh_CN] [#fs.enum.path.format]，枚举 [`format]
    enum format;

    // [:en] [#fs.path.construct], constructors and destructor
    // [|:zh_CN] [#fs.path.construct]，构造函数和析构函数
    path() noexcept;
    path(const path& p);
    path(path&& p) noexcept;
    path(string_type&& source, format fmt = auto_format);
    template <class Source>
      path(const Source& source, format fmt = auto_format);
    template <class InputIterator>
      path(InputIterator first, InputIterator last, format fmt = auto_format);
    template <class Source>
      path(const Source& source, const locale& loc, format fmt = auto_format);
    template <class InputIterator>
      path(InputIterator first, InputIterator last, const locale& loc, format fmt = auto_format);
    ~path();

    // [:en] [#fs.path.assign], assignments
    // [|:zh_CN] [#fs.path.assign]，赋值
    path& operator=(const path& p);
    path& operator=(path&& p) noexcept;
    path& operator=(string_type&& source);
    path& assign(string_type&& source);
    template <class Source>
      path& operator=(const Source& source);
    template <class Source>
      path& assign(const Source& source);
    template <class InputIterator>
      path& assign(InputIterator first, InputIterator last);

    // [:en] [#fs.path.append], appends
    // [|:zh_CN] [#fs.path.append]，追加
    path& operator/=(const path& p);
    template <class Source>
      path& operator/=(const Source& source);
    template <class Source>
      path& append(const Source& source);
    template <class InputIterator>
      path& append(InputIterator first, InputIterator last);

    // [:en] [#fs.path.concat], concatenation
    // [|:zh_CN] [#fs.path.concat]，拼接
    path& operator+=(const path& x);
    path& operator+=(const string_type& x);
    path& operator+=(basic_string_view<value_type> x);
    path& operator+=(const value_type* x);
    path& operator+=(value_type x);
    template <class Source>
      path& operator+=(const Source& x);
    template <class EcharT>
      path& operator+=(EcharT x);
    template <class Source>
      path& concat(const Source& x);
    template <class InputIterator>
      path& concat(InputIterator first, InputIterator last);

    // [:en] [#fs.path.modifiers], modifiers
    // [|:zh_CN] [#fs.path.modifiers]，改动函数
    void  clear() noexcept;
    path& make_preferred();
    path& remove_filename();
    path& replace_filename(const path& replacement);
    path& replace_extension(const path& replacement = path());
    void  swap(path& rhs) noexcept;

    // [:en] [#fs.path.native.obs], native format observers
    // [|:zh_CN] [#fs.path.native.obs]，本地格式探查函数
    const string_type& native() const noexcept;
    const value_type*  c_str() const noexcept;
    operator string_type() const;

    template <class EcharT, class traits = char_traits<EcharT>,
              class Allocator = allocator<EcharT>>
      basic_string<EcharT, traits, Allocator>
        string(const Allocator& a = Allocator()) const;
    std::string    string() const;
    std::wstring   wstring() const;
    std::string    u8string() const;
    std::u16string u16string() const;
    std::u32string u32string() const;

    // [:en] [#fs.path.generic.obs], generic format observers
    // [|:zh_CN] [#fs.path.generic.obs]，通用格式探查函数
    template <class EcharT, class traits = char_traits<EcharT>,
              class Allocator = allocator<EcharT>>
      basic_string<EcharT, traits, Allocator>
        generic_string(const Allocator& a = Allocator()) const;
    std::string    generic_string() const;
    std::wstring   generic_wstring() const;
    std::string    generic_u8string() const;
    std::u16string generic_u16string() const;
    std::u32string generic_u32string() const;

    // [:en] [#fs.path.compare], compare
    // [|:zh_CN] [#fs.path.compare]，比较
    int compare(const path& p) const noexcept;
    int compare(const string_type& s) const;
    int compare(basic_string_view<value_type> s) const;
    int compare(const value_type* s) const;

    // [:en] [#fs.path.decompose], decomposition
    // [|:zh_CN] [#fs.path.decompose]，分解
    path root_name() const;
    path root_directory() const;
    path root_path() const;
    path relative_path() const;
    path parent_path() const;
    path filename() const;
    path stem() const;
    path extension() const;

    // [:en] [#fs.path.query], query
    // [|:zh_CN] [#fs.path.query]，查询
    bool empty() const noexcept;
    bool has_root_name() const;
    bool has_root_directory() const;
    bool has_root_path() const;
    bool has_relative_path() const;
    bool has_parent_path() const;
    bool has_filename() const;
    bool has_stem() const;
    bool has_extension() const;
    bool is_absolute() const;
    bool is_relative() const;

    // [:en] [#fs.path.gen], generation
    // [|:zh_CN] [#fs.path.gen]，生成
    path lexically_normal() const;
    path lexically_relative(const path& base) const;
    path lexically_proximate(const path& base) const;

    // [:en] [#fs.path.itr], iterators
    // [|:zh_CN] [#fs.path.itr]，迭代器
    class iterator;
    using const_iterator = iterator;

    iterator begin() const;
    iterator end() const;
  };
}
[codeblock:end]

[%@library value_type[!path]]
[%@library path[!value_type]]
[para]
[:en] [`value_type] is a [`typedef] for the operating system dependent encoded
character type used to represent pathnames.
[:zh_CN] [`value_type] 是对特定于操作系统的编码字符类型的 [`typedef]，用于表示
路径名。

[%@library preferred_separator[!path]]
[%@library path[!preferred_separator]]
[para]
[:en] The value of the [`preferred_separator] member is the operating system
dependent [~preferred-separator] character ([#fs.path.generic]).
[:zh_CN] 成员 [`preferred_separator] 的值是特定于操作系统的[~首选分隔符]字符
（[#fs.path.generic]）。

[para]
[enter:example]
[:en] For POSIX-based operating systems, [`value_type] is [`char] and
[`preferred_separator] is the slash character ([`'/']).
[:zh_CN] 对于基于 POSIX 的操作系统，[`value_type] 为 [`char] 而
[`preferred_separator] 为斜杠字符（[`'/']）。

[:en] For Windows-based operating systems, [`value_type] is [`wchar_t] and
[`preferred_separator] is the backslash character ([`L'\\']).
[:zh_CN] 对于基于 Windows 的操作系统，[`value_type] 为 [`wchar_t] 而
[`preferred_separator] 为反斜杠字符（[`L'\\']）。
[exit:example]

[include fs.path.generic]

[include fs.path.cvt]

[include fs.path.req]

[include fs.path.member]

[include fs.path.itr]

[include fs.path.nonmember]
