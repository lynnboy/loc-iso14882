[section#ios
    [:en] Class template [`basic_ios]
    [:zh_CN] 类模板 [`basic_ios]
]

[include ios.overview]

[include basic.ios.cons]

\rSec3[basic.ios.members]{Member functions}

\indexlibrarymember{tie}{basic_ios}%
\begin{itemdecl}
basic_ostream<charT, traits>* tie() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
An output sequence that is
\textit{tied}
to (synchronized with) the sequence controlled by the stream buffer.
\end{itemdescr}

\indexlibrarymember{tie}{basic_ios}%
\begin{itemdecl}
basic_ostream<charT, traits>* tie(basic_ostream<charT, traits>* tiestr);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
If \tcode{tiestr} is not null, \tcode{tiestr} must not be reachable by
traversing the linked list of tied stream objects starting from
\tcode{tiestr->tie()}.

\pnum
\postconditions
\tcode{tiestr == tie()}.

\pnum
\returns
The previous value of
\tcode{tie()}.
\end{itemdescr}

\indexlibrarymember{rdbuf}{basic_ios}%
\begin{itemdecl}
basic_streambuf<charT, traits>* rdbuf() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A pointer to the
\tcode{streambuf}
associated with the stream.
\end{itemdescr}

\indexlibrarymember{rdbuf}{basic_ios}%
\begin{itemdecl}
basic_streambuf<charT, traits>* rdbuf(basic_streambuf<charT, traits>* sb);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions
\tcode{sb == rdbuf()}.

\pnum
\effects
Calls
\tcode{clear()}.

\pnum
\returns
The previous value of
\tcode{rdbuf()}.
\end{itemdescr}

\indexlibrarymember{imbue}{basic_ios}%
\begin{itemdecl}
locale imbue(const locale& loc);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{ios_base::imbue(loc)}~(\ref{ios.base.locales})
and
if
\tcode{rdbuf() != 0}
then
\tcode{rdbuf()->pubimbue(loc)} (\ref{streambuf.locales}).

\pnum
\returns
The prior value of
\tcode{ios_base::imbue()}.
\end{itemdescr}

\indexlibrarymember{narrow}{basic_ios}%
\begin{itemdecl}
char narrow(char_type c, char dfault) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{use_facet<ctype<char_type>>(getloc()).narrow(c, dfault)}
\end{itemdescr}

\indexlibrarymember{widen}{basic_ios}%
\begin{itemdecl}
char_type widen(char c) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{use_facet<ctype<char_type>>(getloc()).widen(c)}
\end{itemdescr}

\indexlibrarymember{fill}{basic_ios}%
\begin{itemdecl}
char_type fill() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The character used to pad (fill) an output conversion to the specified
field width.
\end{itemdescr}

\indexlibrarymember{fill}{basic_ios}%
\begin{itemdecl}
char_type fill(char_type fillch);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions
\tcode{traits::eq(fillch, fill())}.

\pnum
\returns
The previous value of
\tcode{fill()}.
\end{itemdescr}

\indexlibrarymember{copyfmt}{basic_ios}%
\begin{itemdecl}
basic_ios& copyfmt(const basic_ios& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If
\tcode{(this == \&rhs)}
does nothing.
Otherwise assigns to the member objects of
\tcode{*this}
the corresponding member objects of \tcode{rhs} as follows:

\begin{enumerate}
\item calls each registered callback pair \tcode{(fn, index)} as
\tcode{(*fn)(erase_event, *this, index)};

\item assigns to the member objects of \tcode{*this} the corresponding member objects of
\tcode{rhs}, except that

\begin{itemize}
\item \tcode{rdstate()}, \tcode{rdbuf()}, and \tcode{exceptions()} are left unchanged;

\item the contents of arrays pointed at by \tcode{pword} and \tcode{iword} are copied,
not the pointers themselves;\footnote{ This suggests an infinite amount of copying, but the implementation can keep
track of the maximum element of the arrays that is nonzero.}
and

\item if any newly stored pointer values in \tcode{*this} point at objects stored outside
the object \tcode{rhs} and those objects are destroyed when \tcode{rhs} is destroyed, the
newly stored pointer values are altered to point at newly constructed copies of the
objects;
\end{itemize}

\item calls each callback pair that was copied from \tcode{rhs} as
\tcode{(*fn)(copyfmt_event, *this, index)};

\item calls \tcode{exceptions(rhs.exceptions())}.

\end{enumerate}

\pnum
\begin{note}
The second pass through the callback pairs permits a copied \tcode{pword}
value to be zeroed, or to have its referent deep copied or reference counted, or to have
other special action taken.
\end{note}

\pnum
\postconditions
The postconditions of this function are indicated in Table~\ref{tab:iostreams.copyfmt.effects}.


\begin{LibEffTab}{\tcode{basic_ios::copyfmt()} effects}
{tab:iostreams.copyfmt.effects}{Value}{1.2in}
\tcode{rdbuf()}             &
  \textit{unchanged}        \\
\tcode{tie()}               &
  \tcode{rhs.tie()}         \\
\tcode{rdstate()}           &
  \textit{unchanged}        \\
\tcode{exceptions()}        &
  \tcode{rhs.exceptions()}  \\
\tcode{flags()}             &
  \tcode{rhs.flags()}       \\
\tcode{width()}             &
  \tcode{rhs.width()}       \\
\tcode{precision()}         &
  \tcode{rhs.precision()}   \\
\tcode{fill()}              &
  \tcode{rhs.fill()}        \\
\tcode{getloc()}            &
  \tcode{rhs.getloc()}      \\
\end{LibEffTab}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{move}{basic_ios}%
\begin{itemdecl}
void move(basic_ios& rhs);
void move(basic_ios&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions \tcode{*this} shall have the state that
\tcode{rhs} had before the function call, except that
\tcode{rdbuf()} shall return 0. \tcode{rhs} shall be in a valid but
unspecified state, except that \tcode{rhs.rdbuf()} shall return the
same value as it returned before the function call, and
\tcode{rhs.tie()} shall return 0.
\end{itemdescr}

\indexlibrarymember{swap}{basic_ios}%
\begin{itemdecl}
void swap(basic_ios& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects The states of \tcode{*this} and \tcode{rhs}
shall be exchanged, except that \tcode{rdbuf()} shall return the same
value as it returned before the function call, and \tcode{rhs.rdbuf()}
shall return the same value as it returned before the function call.
\end{itemdescr}

\indexlibrarymember{set_rdbuf}{basic_ios}%
\begin{itemdecl}
void set_rdbuf(basic_streambuf<charT, traits>* sb);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{sb != nullptr}.

\pnum
\effects Associates the \tcode{basic_streambuf} object
pointed to by \tcode{sb} with this stream without calling
\tcode{clear()}.

\pnum
\postconditions \tcode{rdbuf() == sb}.

\pnum
\throws Nothing.
\end{itemdescr}

\rSec3[iostate.flags]{\tcode{basic_ios} flags functions}

\indexlibrarymember{operator bool}{basic_ios}%
\begin{itemdecl}
explicit operator bool() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!fail()}.
\end{itemdescr}

\indexlibrarymember{operator"!}{basic_ios}%
\begin{itemdecl}
bool operator!() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{fail()}.
\end{itemdescr}

\indexlibrarymember{rdstate}{basic_ios}%
\begin{itemdecl}
iostate rdstate() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The error state of the stream buffer.
\end{itemdescr}

\indexlibrarymember{clear}{basic_ios}%
\begin{itemdecl}
void clear(iostate state = goodbit);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions
If
\tcode{rdbuf() != 0}
then
\tcode{state == rdstate()};
otherwise
\tcode{rdstate() == (state | ios_base::badbit)}.

\pnum
\effects
If \tcode{((state | (rdbuf() ? goodbit : badbit)) \& exceptions()) == 0},
returns.
Otherwise, the function throws an object of class
\tcode{basic_ios::failure}~(\ref{ios::failure}),
constructed with
\impldef{argument values to construct \tcode{basic_ios::failure}}
argument values.%
\end{itemdescr}

\indexlibrarymember{setstate}{basic_ios}%
\begin{itemdecl}
void setstate(iostate state);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{clear(rdstate() | state)}
(which may throw
\tcode{basic_ios::failure}~(\ref{ios::failure})).
\end{itemdescr}

\indexlibrarymember{good}{basic_ios}%
\begin{itemdecl}
bool good() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{rdstate() == 0}
\end{itemdescr}

\indexlibrarymember{eof}{basic_ios}%
\begin{itemdecl}
bool eof() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
if
\tcode{eofbit}
is set in
\tcode{rdstate()}.
\end{itemdescr}

\indexlibrarymember{fail}{basic_ios}%
\begin{itemdecl}
bool fail() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
if
\tcode{failbit}
or
\tcode{badbit}
is set in
\tcode{rdstate()}.\footnote{Checking
\tcode{badbit}
also for
\tcode{fail()}
is historical practice.}
\end{itemdescr}

\indexlibrarymember{bad}{basic_ios}%
\begin{itemdecl}
bool bad() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
if
\tcode{badbit}
is set in
\tcode{rdstate()}.
\end{itemdescr}

\indexlibrarymember{exceptions}{basic_ios}%
\begin{itemdecl}
iostate exceptions() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
A mask that determines what elements set in
\tcode{rdstate()}
cause exceptions to be thrown.
\end{itemdescr}

\indexlibrarymember{exceptions}{basic_ios}%
\begin{itemdecl}
void exceptions(iostate except);
\end{itemdecl}

\begin{itemdescr}
\pnum
\postconditions
\tcode{except == exceptions()}.

\pnum
\effects
Calls
\tcode{clear(rdstate())}.
\end{itemdescr}
