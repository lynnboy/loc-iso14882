[section#basic.link
    [:en] Program and linkage
    [:zh_CN] 程序与连接
[%:begin#linkage
    [:en] linkage
    [:zh_CN] 连接 ]
]

[para]
[:en]
[%program]
A [+program] consists of one or more translation units ([#lex.separate]) linked
together.
[:zh_CN]
[%程序]
[+程序]由一个或多个被连接起来的翻译单元（[#lex.separate]）构成。

[:en]
A translation unit consists of a sequence of declarations.
[:zh_CN]
翻译单元由一系列的声明式构成。

[syntax]
[rule translation-unit [:zh_CN] 翻译单元 ]
    [| [~:opt declaration-seq] ]
    [| [~:opt global-module-fragment] module-declaration [~:opt top-level-declaration-seq]
        [~:opt private-module-fragment] ]
[rule:end]
[syntax:end]

[para]
[:en]
[%linkage] [%translation unit] [%linkage[!internal]] [%linkage[!external]]
A name is said to have [+linkage] when it might denote the same object,
reference, function, type, template, namespace or value as a name introduced by
a declaration in another scope:
[:zh_CN]
[%连接] [%翻译单元] [%连接[!内部～]] [%连接[!外部～]]
当某个名字能够与在另一个作用域中由某个声明式引入的名字代表同一个对象、引用、函数、
类型、模板、命名空间或值时，就称其是有[+连接]的：

[list]
[item]
[:en]
When a name has [%linkage[!external]][+external linkage], the entity it denotes
can be referred to by names from scopes of other translation units or from other
scopes of the same translation unit.
[:zh_CN]
若某个名字具有[%连接[!外部～]][+外部连接]，则其所代表的实体可以用其他翻译单元中
的作用域，或相同翻译单元中的其他作用域中的名字来代表。

[item]
[:en]
When a name has [+module linkage[%linkage[!module]]], the entity it denotes can
be referred to by names from other scopes of the same module unit
([#module.unit]) or from scopes of other module units of that same module.
[:zh_CN]
若某个名字具有[+模块连接[%连接[!模块～]]]，则其所代表的实体可以用相同模块单元的
其他作用域，或相同模块的其他模块单元的作用域中的名字来代表。

[item]
[:en]
When a name has [%linkage[!internal]][+internal linkage], the entity it denotes
can be referred to by names from other scopes in the same translation unit.
[:zh_CN]
若某个名字具有[%连接[!内部～]][+内部连接]，则其所代表的实体可以用相同翻译单元中
的其他作用域中的名字来代表。

[item]
[:en]
When a name has [%linkage[!no]][+no linkage], the entity it denotes cannot be
referred to by names from other scopes.
[:zh_CN]
若某个名字为[%连接[!无～]][+无连接]，则其所代表的实体就不能用其他作用域中的名字
来代表。
[list:end]

[para]
[:en]
[%linkage[![`static] and]] [%[`static][!linkage of]]
[%linkage[![`const] and]] [%[`const][!linkage of]]
[%linkage[![`inline] and]] [%[`inline][!linkage of]]
A name having namespace scope ([#basic.scope.namespace]) has internal linkage if
it is the name of
[:zh_CN]
[%连接[![`static] 与～]] [%[`static][!～的连接]]
[%连接[![`const] 与～]] [%[`const][!～的连接]]
[%连接[![`inline] 与～]] [%[`inline][!～的连接]]
如下情况下，具有命名空间作用域（[#basic.scope.namespace]）的名字具有内部连接：

[list]
[item]
[:en@~] a variable, variable template, function, or function template that is
explicitly declared [`static]; or,
[:zh_CN@~] 被明确声明为 [`static] 的变量、变量模板、函数或函数模板；或者

[item]
[:en@~] a non-template variable of non-volatile const-qualified type, unless
[:zh_CN@~] 非 volatile 的 const 限定的类型的非模板变量，排除以下情况：
[list]
[item]
[:en@~] it is explicitly declared [`extern], or
[:zh_CN@~] 它被显式声明为 [`extern]，或
[item]
[:en@~] it is inline or exported, or
[:zh_CN@~] 它被内联或被导出，或
[item]
[:en@~] it was previously declared and the prior declaration did not have
internal linkage; or
[:zh_CN@~] 它之前已被声明且其之前的声明式并不具有内部连接；或者
[list:end]

[item]
[:en@~] a data member of an anonymous union.
[:zh_CN@~] 匿名联合体的数据成员。
[list:end]

[begin:note]
[:en]
An instantiated variable template that has const-qualified type can have
external or module linkage, even if not declared [`extern].
[:zh_CN]
具有 const 限定的类型的已实例化的变量模板，即使未被声明为 [`extern] 也可以具有
外部或模块连接。
[end:note]

[para]
[:en]
An unnamed namespace or a namespace declared directly or indirectly within an
unnamed namespace has internal linkage.
[:zh_CN]
无名命名空间，或者直接或间接声明于无名命名空间中的命名空间具有内部连接。

[:en]
All other namespaces have external linkage.
[:zh_CN]
其他任何命名空间均具有外部连接。

[:en]
A name having namespace scope that has not been given internal linkage above and
that is the name of
[:zh_CN]
具有命名空间作用域的名字，尚未被以上述方式给定内部连接，若它是下列各项之一的名字：

[list]
[item]
[:en@~] a variable; or
[:zh_CN@~] 变量；或者

[item]
[:en@~] a function; or
[:zh_CN@~] 函数；或者

[item]
[:en@~]
[%class[!linkage of]]
a named class ([#class.pre]), or an unnamed class defined in a typedef
declaration in which the class has the typedef name for linkage purposes
([#dcl.typedef]); or
[:zh_CN@~]
[%类[!～的连接]]
具名类（[#class.pre]），或定义于 typedef 声明式中的无名类，其具有用于连接的
typedef 名（[#dcl.typedef]）；或者

[item]
[:en@~]
[%enumeration[!linkage of]]
a named enumeration ([#dcl.enum]), or an unnamed enumeration defined in a
typedef declaration in which the enumeration has the typedef name for linkage
purposes ([#dcl.typedef]); or
[:zh_CN@~]
[%枚举[!～的连接]]
有名字的枚举（[#dcl.enum]），或定义于 typedef 声明式中的无名枚举，其具有用于连接
的 typedef 名（[#dcl.typedef]）；或者

[item]
[:en@~] an unnamed enumeration that has an enumerator as a name for linkage
purposes ([#dcl.enum]); or
[:zh_CN@~] 无名枚举，具有一个枚举符作为连接目的的名字（[#dcl.enum]）；或者

[item]
[:en@~] a template
[:zh_CN@~] 模板
[list:end]

[:en@~] has its linkage determined as follows:
[:zh_CN@~] 则其连接以如下方式确定：

[list]
[item]
[:en@~] if the enclosing namespace has internal linkage, the name has internal
linkage;
[:zh_CN@~] 当其外围命名空间具有内部连接时，该名字具有内部连接；
[item]
[:en@~] otherwise, if the declaration of the name is attached to a named module
([#module.unit]) and is not exported ([#module.interface]), the name has module
linkage;
[:zh_CN@~] 否则，若该名字的声明式附属与某个具名模块（[#module.unit]）但未被导出
（[#module.interface]），则该名字具有模块连接；
[item]
[:en@~] otherwise, the name has external linkage.
[:zh_CN@~] 否则，该名字具有外部连接。
[list:end]

[para]
[:en]
In addition, a member function, static data member, a named class or enumeration
of class scope, or an unnamed class or enumeration defined in a class-scope
typedef declaration such that the class or enumeration has the typedef name for
linkage purposes ([#dcl.typedef]), has the same linkage, if any, as the name of
the class of which it is a member.
[:zh_CN]
此外，类的成员函数，静态数据成员，类作用域中的具名类或枚举，或者定义于类作用域中
的 typedef 声明式中（从而使其具有用于连接的 typedef 名）的无名类或枚举
（[#dcl.typedef]），它们具有与其作为成员的类的名字相同的连接（如果有）。

[para]
[:en]
The name of a function declared in block scope and the name of a variable
declared by a block scope [`extern] declaration have linkage.
[:zh_CN]
在块作用域中声明的函数的名字，以及由块作用域 [`extern] 声明式所声明的变量的名字
具有连接。

[:en]
If such a declaration is attached to a named module, the program is ill-formed.
[:zh_CN]
如果这样的声明式附属与某个具名模块，则程序员非良构。

[:en]
If there is a visible declaration of an entity with linkage, ignoring entities
declared outside the innermost enclosing namespace scope, such that the block
scope declaration would be a (possibly ill-formed) redeclaration if the two
declarations appeared in the same declarative region, the block scope
declaration declares that same entity and receives the linkage of the previous
declaration.
[:zh_CN]
若忽略其最内层外围命名空间作用域之外所声明的实体后，某个有连接实体的声明式是
可见的，并在当该声明式和块作用域声明式出现于相同的声明区时将导致块作用域声明式
变为（可能非良构的）重复声明式，则此块作用域声明式就对同一个实体进行声明，并获得
其之前所声明的连接。

[:en]
If there is more than one such matching entity, the program is ill-formed.
[:zh_CN]
若它所匹配的实体多于一个，则该程序非良构。

[:en]
Otherwise, if no matching entity is found, the block scope entity receives
external linkage.
[:zh_CN]
否则，若没找到匹配的实体，则这个块作用域实体就获得外部连接。

[:en]
If, within a translation unit, the same entity is declared with both internal
and external linkage, the program is ill-formed.
[:zh_CN]
如果同一个翻译单元中，相同的实体被同时声明为具有内部连接和外部连接，则程序非良构。

[begin:example]
[codeblock]
static void f();
extern "C" void h();
static int i = 0;               // #1
void g() {
  extern void f();              // [:en] internal linkage \
                                   [:zh_CN] 内部连接
  extern void h();              // [:en] C language linkage \
                                   [:zh_CN] C 语言连接
  int i;                        // [:en] #2: [`i] has no linkage \
                                   [:zh_CN] #2：[`i] 无连接
  {
    extern void f();            // [:en] internal linkage \
                                   [:zh_CN] 内部连接
    extern int i;               // [:en] #3: external linkage \
                                   [:zh_CN] #3：外部连接，非良构
  }
}
[codeblock:end]

[:en]
Without the declaration at line #2, the declaration at line #3 would link with
the declaration at line #1.
[:zh_CN]
如果没有行 #2 的声明式的话，行 #3 的声明式将与行 #1 的声明式相连接。

[:en]
Because the declaration with internal linkage is hidden, however, #3 is given
external linkage, making the program ill-formed.
[:zh_CN]
但由于具有内部连接的声明式被隐藏了，行 #3 所获得的却是外部连接，导致程序非良构。
[end:example]

[para]
[:en]
When a block scope declaration of an entity with linkage is not found to refer
to some other declaration, then that entity is a member of the innermost
enclosing namespace.
[:zh_CN]
当某个有连接实体的块作用域声明式，没有找到所能代表的其他声明式时，该实体就成为其
最内层外围命名空间的成员。

[:en]
However such a declaration does not introduce the member name in its namespace
scope.
[:zh_CN]
然而这种声明式并不向其命名空间作用域中引入成员名。

[begin:example]
[codeblock]
namespace X {
  void p() {
    q();                        // [:en] error: [`q] not yet declared \
                                   [:zh_CN] 错误：[`q] 还未声明
    extern void q();            // [:en] [`q] is a member of namespace [`X] \
                                   [:zh_CN] [`q] 是命名空间 [`X] 的成员
  }

  void middle() {
    q();                        // [:en] error: [`q] not yet declared \
                                   [:zh_CN] 错误：[`q] 还未声明
  }

  void q() { /* ... */ }        // [:en] definition of [`X::q] \
                                   [:zh_CN] [`X::q] 的定义式
}

void q() { /* ... */ }          // [:en] some other, unrelated [`q] \
                                   [:zh_CN] 某个无关的其他 [`q]
[codeblock:end]
[end:example]

[para]
[:en]
[%linkage[!no]]
Names not covered by these rules have no linkage.
[:zh_CN]
[%连接[!无～]]
未由下列规则覆盖到的名字没有连接。

[:en]
Moreover, except as noted, a name declared at block scope ([#basic.scope.block])
has no linkage.
[:zh_CN]
此外，除非另行指明，在块作用域（[#basic.scope.block]）中声明的名字没有连接。

[para]
[:en]
Two names that are the same ([#basic.pre]) and that are declared in different
scopes shall denote the same variable, function, type, template or namespace if
[:zh_CN]
在下列情况下，相同的（[#basic.pre]），且声明于不同的作用域中的两个名字，应当代表
相同的变量、函数、类型、模板或命名空间：

[list]
[item]
[:en]
both names have external or module linkage and are declared in declarations
attached to the same module, or else both names have internal linkage and are
declared in the same translation unit; and
[:zh_CN]
两个名字都具有外部或模块连接且均在附属与相同模块的声明式中所声明，或者都具有
内部连接且声明于相同翻译单元中；且

[item]
[:en]
both names refer to members of the same namespace or to members, not by
inheritance, of the same class; and
[:zh_CN]
两个名字都代表相同命名空间的成员，或相同类的（不来自继承的）成员；且

[item]
[:en]
when both names denote functions or function templates, the signatures
([#defns.signature], [#defns.signature.templ]) are the same.
[:zh_CN]
若两个名字都代表函数或函数模板，则其签名（[#defns.signature]，
[#defns.signature.templ]）相同。

[:en]
If multiple declarations of the same name with external linkage would declare
the same entity except that they are attached to different modules, the program
is ill-formed; no diagnostic is required.
[:zh_CN]
如果同一个具有外部连接的名字的多个声明式，除附属与不同模块之外声明了同一个实体，
则程序非良构；无须诊断。

[begin:note]
[:en]
[~using-declaration]s, typedef declarations, and [~alias-declaration]s do not
declare entities, but merely introduce synonyms.
[:zh_CN]
[~using-声明式]、typedef 声明式和别名声明式并不声明实体而仅仅引入了同义词。

[:en]
Similarly, [~using-directive]s do not declare entities.
[:zh_CN]
雷斯蒂，[~using-指令]并不声明实体。

[:en]
Enumerators do not have linkage, but may serve as the name of an enumeration
with linkage ([#dcl.enum]).
[:zh_CN]
枚举符没有连接，但可作为具有连接的枚举的名字（[#dcl.enum]）。
[end:note]

[para]
[:en]
If a declaration would redeclare a reachable declaration attached to a different
module, the program is ill-formed.
[:zh_CN]
如果某个声明式重新声明了某个附属与不同模块的声明式，则程序非良构。

[begin:example]
[:en] [`"decls.h"]:
[:zh_CN] [`"decls.h"]：
[codeblock]
int f();            // [:en] #1, attached to the global module
int g();            // [:en] #2, attached to the global module
[codeblock:end]

[:en] Module interface of [`M]:
[:zh_CN] [`M] 的模块接口：
[codeblock]
module;
#include "decls.h"
export module M;
export using ::f;   // [:en] OK: does not declare an entity, exports #1
int g();            // [:en] error: matches #2, but attached to [`M]
export int h();     // #3
export int k();     // #4
[codeblock:end]

[:en] Other translation unit:
[:zh_CN] 另一个翻译单元：
[codeblock]
import M;
static int h();     // [:en] error: matches #3
int k();            // [:en] error: matches #4
[codeblock:end]
[end:example]

[:en]
As a consequence of these rules, all declarations of an entity are attached to
the same module; the entity is said to be [+attached[%attached[!entity]]] to
that module.
[:zh_CN]
这些规则的结果是，一个实体的所有声明式均附属于同一个模块；该实体被称为
[+附属[%附属[!实体]]]于这个模块。

[para]
[:en]
[%consistency[!type declaration]] [%declaration[!multiple]]
After all adjustments of types (during which typedefs ([#dcl.typedef]) are
replaced by their definitions), the types specified by all declarations
referring to a given variable or function shall be identical, except that
declarations for an array object can specify array types that differ by the
presence or absence of a major array bound ([#dcl.array]).
[:zh_CN]
[%一致性[!类型声明式的～]] [%声明式[!多重～]]
在全部类型调整（其中 typedef（[#dcl.typedef]）都被其定义所取代）之后，除了数组
对象的声明式可以指定因带有或不带有主数组边界（[#dcl.array]）而相异的数组类型外，
所有代表给定变量或函数的声明式所指定的类型都应当一致。

[:en]
A violation of this rule on type identity does not require a diagnostic.
[:zh_CN]
违反本条关于类型一致的规则无须诊断。

[para]
[begin:note]
[:en]
Linkage to non-[=Cpp] declarations can be achieved using a
[~linkage-specification] ([#dcl.link]).
[:zh_CN]
到非 [=Cpp] 的声明式的连接可以通过使用[~连接说明]来达成（[#dcl.link]）。
[end:note]

[para]
[:en]
A declaration [$D] [+names[%name]] an entity [$E] if
[:zh_CN]
以下情况下，声明式 [$D] [+指名]实体 [$E]：
[list]
[item]
[:en] [$D] contains a [~lambda-expression] whose closure type is [$E],
[:zh_CN] [$D] 包含闭包类型为 [$E] 的 [~lambda-表达式]，
[item]
[:en] [$E] is not a function or function template and [$D] contains an
[~id-expression], [~type-specifier], [~nested-name-specifier], [~template-name],
or [~concept-name] denoting [$E], or
[:zh_CN] [$E] 不是函数或函数模板，且 [$D] 包含代表 [$E] 的[~标识表达式]，
[~类型说明符]，[~嵌套名说明符]，[~模板名]，或 [~概念名]，或者
[item]
[:en] [$E] is a function or function template and [$D] contains an expression
that names [$E] ([#basic.def.odr]) or an [~id-expression] that refers to a set
of overloads that contains [$E].
[:zh_CN] [$E] 是函数或函数模板，且 [$D] 包含指名了 [$E] 的表达式
（[#basic.def.odr]）或指代包含了 [$E] 的重载集合的[~标识表达式]。

[begin:note]
[:en]
Non-dependent names in an instantiated declaration do not refer to a set of
overloads ([#temp.nondep]).
[:zh_CN]
已实例化声明式中的非待决名并不指代重载集合（[#temp.nondep]）。
[end:note]
[list:end]

[para]
[:en]
A declaration is an [+exposure] if it either names a TU-local entity (defined
below), ignoring
[:zh_CN]
如果一个声明式或者指名了翻译单元局部的实体（下文定义），其中排除
[list]
[item]
[:en] the [~function-body] for a non-inline function or function template
(but not the deduced return type for a (possibly instantiated) definition of
a function with a declared return type that uses a placeholder type
([#dcl.spec.auto])),
[:zh_CN] 非内联函数或函数模板的[~函数体]（但不包括对函数的（可能被实例化的）
定义式的推断返回类型，该函数具有使用了占位符类型的声明返回类型（[#dcl.spec.auto]））
[item]
[:en] the [~initializer] for a variable or variable template (but not the
variable[=']s type),
[:zh_CN] 变量或变量模板的[~初始化式]（但不包括变量的类型），
[item]
[:en] friend declarations in a class definition, and
[:zh_CN] 类定义式中的友元声明式，以及
[item]
[:en] any reference to a non-volatile const object or reference with internal or
no linkage initialized with a constant expression that is not an odr-use
([#basic.def.odr]),
[:zh_CN] 对某个非 [`volatile] 的 [`const] 对象或引用的任何涉指，其具有内部或
无连接且以并非 ODR 式使用的常量表达式所初始化（[#basic.def.odr]），
[list:end]
[:en@~] or defines a constexpr variable initialized to a TU-local value (defined
below).
[:zh_CN@~] 或者定义了以翻译单元局部的实体（下文定义）初始化的 constexpr 变量，则
它是一个[+显露式]。

[begin:note]
[:en]
An inline function template can be an exposure even though
explicit specializations of it might be usable in other translation units.
[:zh_CN]
即使可以在其他翻译单元中使用其显示特例，内联函数模板仍可以为显露式。
[end:note]

[para]
[:en]
An entity is [+TU-local[%TU-local[!entity]]] if it is
[:zh_CN]
符合下列情况的实体是[+翻译单元局部的[%翻译单元局部的[!实体]]]：

[list]
[item]
[:en] a type, function, variable, or template that
[:zh_CN] 以下情况的类型，函数，变量，或模板：
[list]
[item]
[:en@~] has a name with internal linkage, or
[:zh_CN@~] 具有带有内部连接的名字，或者
[item]
[:en@~] does not have a name with linkage and is declared, or introduced by a
[~lambda-expression], within the definition of a TU-local entity,
[:zh_CN@~] 不具有带有连接的名字，且是在翻译单元局部的实体的定义式中，声明或由
[~lambda-表达式]所引入的，
[list:end]

[item]
[:en] a type with no name that is defined outside a [~class-specifier],
function body, or [~initializer] or is introduced by a [~defining-type-specifier]
that is used to declare only TU-local entities,
[:zh_CN] 在[~类说明符]，函数体，或[~初始化式]以外定义的，或者由用于声明仅为
翻译单元局部的实体的[~定义类型说明符]所引入的，没有名字的类型，

[item]
[:en] a specialization of a TU-local template,
[:zh_CN] 翻译单元局部的模板的特化式，

[item]
[:en] a specialization of a template with any TU-local template argument, or
[:zh_CN] 带有任何翻译单元局部的模板的实参的模板特化式，或者

[item]
[:en] a specialization of a template whose (possibly instantiated) declaration
is an exposure.
[:zh_CN] 模板的特化式，该模板的（可能被实例化的）声明式为显露式。

[begin:note]
[:en]
The specialization might have been implicitly or explicitly instantiated.
[:zh_CN]
该特化式可能已被隐式或显示实例化。
[end:note]
[list:end]

[para]
[:en]
A value or object is [+TU-local[%TU-local[!value or object]]] if either
[:zh_CN]
符合下列情况的值或对象是[+翻译单元局部的[%翻译单元局部的[!值或对象]]]：
[list]
[item]
[:en] it is, or is a pointer to, a TU-local function or the object associated
with a TU-local variable,
[:zh_CN] 它是翻译单元局部的函数或与翻译单元局部的变量相关联的对象，或为其指针，
[item]
[:en] it is an object of class or array type and any of its subobjects or
any of the objects or functions to which its non-static data members of
reference type refer is TU-local and is usable in constant expressions.
[:zh_CN] 它是类或数组类型的对象，而且其任何子对象，或其引用类型的非静态数据成员
所指代的任何对象或函数，均为翻译单元局部的且可在常量表达式中使用。
[list:end]

[para]
[:en]
If a (possibly instantiated) declaration of, or a deduction guide for,
a non-TU-local entity in a module interface unit (outside the
[~private-module-fragment], if any) or module partition ([#module.unit]) is an
exposure, the program is ill-formed.
[:zh_CN]
如果模块接口单元（于[~私有模块分段]之外，如果有）或模块分区（[#module.unit]）
中的某个非翻译单元局部的实体，其（可能被实例化的）声明式或者其推断导引是显露式，
则程序非良构。

[:en]
Such a declaration in any other context is deprecated ([#depr.local]).
[:zh_CN]
其他任何语境中的这种声明式是被摒弃的（[#depr.local]）。

[para]
[:en]
If a declaration that appears in one translation unit names a TU-local entity
declared in another translation unit that is not a header unit, the program is
ill-formed.
[:zh_CN]
如果出现于一个翻译单元中的声明式指名了声明于另一个并非头文件单元翻译单元中的
翻译单元局部实体，则程序非良构。

[:en]
A declaration instantiated for a template specialization ([#temp.spec])
appears at the point of instantiation of the specialization ([#temp.point]).
[:zh_CN]
对某个模板特例（[#temp.spec]）实例化的声明式，出现于该特例的实例化点
（[#temp.point]）。

[para]
[begin:example]
[:en] Translation unit #1
[:zh_CN] 翻译单元 #1
[codeblock]
export module A;
static void f() {}
inline void it() { f(); }           // [:en] error: is an exposure of [`f] \
                                    [:zh_CN] 错误：[`f] 的显露式
static inline void its() { f(); }   // OK
template<int> void g() { its(); }   // OK
template void g<0>();

decltype(f) *fp;                    // [:en] error: [`f] (though not its type) is TU-local \
                                    [:zh_CN] 错误：[`f] 是翻译单元局部的（虽然其类型不是）
auto &fr = f;                       // OK
constexpr auto &fr2 = fr;           // [:en] error: is an exposure of [`f] \
                                    [:zh_CN] 错误：[`f] 的显露式
constexpr static auto fp2 = fr;     // OK

struct S { void (&ref)(); } s{f};               // [:en] OK, value is TU-local \
                                                [:zh_CN] OK，翻译单元局部的值
constexpr extern struct W { S &s; } wrap{s};    // [:en] OK, value is not TU-local \
                                                [:zh_CN] OK，不是翻译单元局部的值

static auto x = []{f();};           // OK
auto x2 = x;                        // [:en] error: the closure type is TU-local \
                                    [:zh_CN] 错误：闭包类型是翻译单元局部的
int y = ([]{f();}(),0);             // [:en] error: the closure type is not TU-local \
                                    [:zh_CN] 错误：闭包类型不是翻译单元局部的
int y2 = (x,0);                     // OK

namespace N {
  struct A {};
  void adl(A);
  static void adl(int);
}
void adl(double);

inline void h(auto x) { adl(x); }   // [:en] OK, but a specialization might be an exposure \
                                    [:zh_CN] OK，但特例可能是显露式
[codeblock:end]

[:en] Translation unit #2
[:zh_CN] 翻译单元 #2
[codeblock]
module A;
void other() {
  g<0>();                           // [:en] OK, specialization is explicitly instantiated \
                                    [:zh_CN] OK，显示实例化了特化式
  g<1>();                           // [:en] error: instantiation uses TU-local [`its] \
                                    [:zh_CN] 错误：实例化使用了翻译单元局部的 [`its]
  h(N::A{});                        // [:en] error: overload set contains TU-local [`N::adl(int)] \
                                    [:zh_CN] 错误：重载集合包含了翻译单元局部的 [`N::adl(int)]
  h(0);                             // [:en] OK, calls [`adl(double)] \
                                    [:zh_CN] OK，调用 [`adl(double)]
  adl(N::A{});                      // [:en] OK; [`N::adl(int)] not found, calls [`N::adl(N::A)] \
                                    [:zh_CN] OK；未找到 [`N::adl(int)]，调用 [`N::adl(N::A)]
  fr();                             // [:en] OK, calls [`f] \
                                    [:zh_CN] OK，调用 [`f]
  constexpr auto ptr = fr;          // [:en] error: [`fr] is not usable in constant expressions here \
                                    [:zh_CN] 错误：不能在这里的常量表达式中使用 [`fr]
}
[codeblock:end]
[end:example]

[%:end#linkage]
