[section#class.temporary
    [:en] Temporary objects
    [:zh_CN] 临时对象
]

[para]
[:en]
[%object temporary[%temporary]]
[%temporary]
[%optimization of temporary[%temporary[!elimination of]]]
[%temporary[!elimination of]]
[%temporary[!implementation-defined generation of]]
Temporary objects are created
[:zh_CN]
[%对象[!临时～][%临时对象]]
[%临时对象]
[%临时对象的优化[%临时对象[!～的消除]]]
[%临时对象[!～的消除]]
[%临时对象[!由实现定义的～生成]]
以下情况下会创建临时对象

[list]
[item]
[:en]
when a prvalue is converted to an xvalue ([#conv.rval]),
[:zh_CN]
当纯右值被被转换为临限值时（[#conv.rval]），

[item]
[:en]
when needed by the implementation to pass or return an object of
trivially-copyable type (see below), and
[:zh_CN]
当实现需要用来传递或返回可平凡复制的类型的对象时（见下文），以及

[item]
[:en]
when throwing an exception ([#except.throw]).
[:zh_CN]
当抛出异常时（[#except.throw]）。

[enter:note]
[:en]
The lifetime of exception objects is described in [#except.throw].
[:zh_CN]
异常对象的生存期在 [#except.throw] 中说明。
[exit:note]

[list:end]

[:en]
Even when the creation of the temporary object is unevaluated ([#expr.prop]),
all the semantic restrictions shall be respected as if the temporary object had
been created and later destroyed.
[:zh_CN]
即使临时对象的创建是免求值的（[#expr.prop]），其所有语义限制也要按照如同该临时
对象被创建随后被销毁一样予以遵守。

[enter:note]
[:en]
This includes accessibility ([#class.access]) and whether it is deleted, for the
constructor selected and for the destructor.
[:zh_CN]
这包括所选择的构造函数和析构函数的可访问性（[#class.access]）和是否被弃置
（[#dcl.fct.def.delete]）。

[:en]
However, in the special case of the operand of a [~decltype-specifier]
([#expr.call]), no temporary is introduced, so the foregoing does not apply to
such a prvalue.
[:zh_CN]
但是，对于用作 [~decltype-说明符]的操作数的特殊情况下（[#expr.call]），并不会
引入临时对象，因此前面所提到的并不适用于这种纯右值。
[exit:note]

[para]
[:en]
The materialization of a temporary object is generally delayed as long as
possible in order to avoid creating unnecessary temporary objects.
[:zh_CN]
临时对象的实体化通常会被尽可能推迟，以避免创建不必要的临时对象。

[enter:note]
[:en]
Temporary objects are materialized:
[:zh_CN]
以下情况下会实体化临时对象：

[list]
[item]
[:en]
when binding a reference to a prvalue ([#dcl.init.ref], [#expr.type.conv],
[#expr.dynamic.cast], [#expr.static.cast], [#expr.const.cast], [#expr.cast]),
[:zh_CN]
当向引用绑定纯右值时（[#dcl.init.ref]，[#expr.type.conv]，[#expr.dynamic.cast]，
[#expr.static.cast]，[#expr.const.cast]，[#expr.cast]），

[item]
[:en]
when performing member access on a class prvalue ([#expr.ref],
[#expr.mptr.oper]),
[:zh_CN]
当对类的纯右值实施成员访问时（[#expr.ref]，[#expr.mptr.oper]），

[item]
[:en]
when performing an array-to-pointer conversion or subscripting on an array
prvalue ([#conv.array], [#expr.sub]),
[:zh_CN]
当对数组纯右值实施数组向指针转换或者下标操作时（[#conv.array]，[#expr.sub]），

[item]
[:en]
when initializing an object of type [`std::initializer_list<T>] from a
[~braced-init-list] ([#dcl.init.list]),
[:zh_CN]
当以[~花括号初始化列表]对 [`std::initializer_list<T>] 类型的对象进行初始化时
（[#dcl.init.list]），

[item]
[:en]
for certain unevaluated operands ([#expr.typeid], [#expr.sizeof]), and
[:zh_CN]
对于某些免求值操作数（[#expr.typeid]，[#expr.sizeof]），以及

[item]
[:en]
when a prvalue that has type other than [$cv] [`void] appears as a
discarded-value expression ([#expr.prop]).
[:zh_CN]
当类型并非 [$cv] [`void] 纯右值被用作弃值表达式时（[#expr.prop]）。
[list:end]
[exit:note]

[enter:example]
[:en]
Consider the following code:
[:zh_CN]
考虑如下代码：

[codeblock]
class X {
public:
  X(int);
  X(const X&);
  X& operator=(const X&);
  ~X();
};

class Y {
public:
  Y(int);
  Y(Y&&);
  ~Y();
};

X f(X);
Y g(Y);

void h() {
  X a(1);
  X b = f(X(2));
  Y c = g(Y(3));
  a = f(a);
}
[codeblock:end]

[:en]
[%class object copy[%constructor[!copy]]]
[%constructor[!copy]]
[`X(2)] is constructed in the space used to hold [`f()][=']s argument and
[`X(3)] is constructed in the space used to hold [`g()][=']s argument.
[:zh_CN]
[%类对象复制[%构造函数[!复制～]]]
[%构造函数[!复制～]]
[`X(2)] 被构造于持有 [`f()] 的实参的空间之中，[`X(3)] 被构造于持有 [`g()] 的实参
的空间之中。

[:en]
Likewise, [`f()][=']s result is constructed directly in [`b] and [`g()][=']s
result is constructed directly in [`c].
[:zh_CN]
相似地，[`f()] 的结果直接构造于 [`b] 之中，[`g()] 的结果直接构造于 [`c] 之中。

[:en]
On the other hand, the expression [`a = f(a)] requires a temporary for the
result of [`f(a)], which is materalized so that the reference parameter of
[`A::operator=(const A&)] can bind to it.
[:zh_CN]
另一方面，表达式 [`a = f(a)] 需要为 [`f(a)] 的结果提供一个临时对象，其被实体化
是为了让 [`A::operator=(const A&)] 的引用形参可以绑定于其上。
[exit:example]

[para]
[:en]
When an object of class type [`X] is passed to or returned from a function,
if each copy constructor, move constructor, and destructor of [`X] is either
trivial or deleted, and [`X] has at least one non-deleted copy or move
constructor, implementations are permitted to create a temporary object to hold
the function parameter or result object.
[:zh_CN]
当类类型 [`X] 的对象传递给函数或从函数返回时，若 [`X] 的各个复制构造函数，移动
构造函数，以及析构函数均为平凡的或者弃置的，并且 [`X] 带有至少一个未弃置的复制或
移动构造函数，则允许实现创建一个临时变量以斥候函数的形参或返回对象。

[:en]
The temporary object is constructed from the function argument or return value,
respectively, and the function[=']s parameter or return object is initialized as
if by using the non-deleted trivial constructor to copy the temporary (even if
that constructor is inaccessible or would not be selected by overload resolution
to perform a copy or move of the object).
[:zh_CN]
这个临时对象分别以函数的实参或返回值进行构造，而函数的形参或返回对象的初始化则
如同使用这个未弃置的平凡构造函数来复制这个临时对象一样，即便该构造函数无法访问，
或者当实施复制或移动对象时并不会被重载决议所选择时也是如此。

[enter:note]
[:en]
This latitude is granted to allow objects of class type to be passed to or
returned from functions in registers.
[:zh_CN]
这个自由度允许类类型的对象通过寄存器传递给函数或者从函数返回。
[exit:note]

[para]
[:en]
[%temporary[!constructor for]]
[%temporary[!destructor for]]
[%temporary[!destruction of]]
When an implementation introduces a temporary object of a class that has a
non-trivial constructor ([#class.default.ctor], [#class.copy.ctor]), it shall
ensure that a constructor is called for the temporary object.
[:zh_CN]
[%临时对象[!～的构造函数]]
[%临时对象[!～的析构函数]]
[%临时对象[!～的销毁]]
当实现引入了带有非平凡构造函数（[#class.default.ctor]，[#class.copy.ctor]）的类
的临时对象时，它应当保证为该临时对象调用构造函数。

[:en]
Similarly, the destructor shall be called for a temporary with a non-trivial
destructor ([#class.dtor]).
[:zh_CN]
相似地，应当为带有非平凡析构函数（[#class.dtor]）的临时对象调用其析构函数。

[:en]
Temporary objects are destroyed as the last step in evaluating the
full-expression ([#intro.execution]) that (lexically) contains the point where
they were created.
[:zh_CN]
临时对象的销毁是作为（在词法上）包含它们的创建点的全表达式（[#intro.execution]）
求值的最后一步进行的。

[:en]
This is true even if that evaluation ends in throwing an exception.
[:zh_CN]
即使其求值过程以抛出异常来结束时也应如此。

[:en]
The [%value computation] value computations and [%side effects] side effects of
destroying a temporary object are associated only with the full-expression, not
with any specific subexpression.
[:zh_CN]
销毁临时对象时的[%值计算]值计算和[%副作用]副作用，仅与全表达式而不是其任何特定的
子表达式相关联。

[para]
[:en]
[%initializer[!temporary and declarator]]
[%temporary[!order of destruction of]]
There are three contexts in which temporaries are destroyed at a different point
than the end of the full-expression.
[:zh_CN]
[%初始化式[!临时对象和声明符]]
[%临时对象[!～的销毁顺序]]
在两种语境中临时对象并不在全表达式的结尾处销毁。

[:en]
The first context is when a default constructor is called to initialize an
element of an array with no corresponding initializer ([#dcl.init]).
[:zh_CN]
第一种语境是当调用默认构造函数以初始化没有相应初始化式的数组的元素时
（[#dcl.init]）。

[:en]
The second context is when a copy constructor is called to copy an element of
an array while the entire array is copied ([#expr.prim.lambda.capture],
[#class.copy.ctor]).
[:zh_CN]
第二种语句是在整个数组的复制中调用复制构造函数以复制数组的元素时
（[#expr.prim.lambda.capture]，[#class.copy.ctor]）。

[:en]
In either case, if the constructor has one or more default arguments, the
destruction of every temporary created in a default argument is sequenced before
the construction of the next array element, if any.
[:zh_CN]
无论哪种情况，若构造函数带有一个或更多的默认实参，则由默认实参所创建的每个临时
对象的销毁，都按顺序早于下一个数组元素的构造（如果有）。

[para]
[:en]
The third context is when a reference is bound to a temporary object.
[#:note#fn:$1]
[:zh_CN]
第二种语境是当把引用绑定到临时对象时。[#:note#fn:$1]

[note:foot#fn:$1]
[:en]
The same rules apply to initialization of an [`initializer_list] object
([#dcl.init.list]) with its underlying temporary array.
[:zh_CN]
同样的规则适用于以其底层临时数组对 [`initializer_list] 对象进行初始化时
（[#dcl.init.list]）。
[note:end]

[:en]
The temporary object to which the reference is bound or the temporary object
that is the complete object of a subobject to which the reference is bound
persists for the lifetime of the reference if the glvalue to which the reference
is bound was obtained through one of the following:
[:zh_CN]
如果该引用所绑定的泛左值是以如下方式之一获得的，则由该引用所绑定的临时对象，或者
作为由该引用所绑定的子对象的完整对象的临时对象，将持续到该引用的生存期：

[list]
[item]
[:en]
a temporary materialization conversion ([#conv.rval]),
[:zh_CN]
临时对象具体化转换（[#conv.rval]），

[item]
[:en]
[`(] [~expression] [`)], where [~expression] is one of these expressions,
[:zh_CN]
[`(] [~表达式] [`)]，其中的[~表达式]为这里的表达式之一，

[item]
[:en]
subscripting ([#expr.sub]) of an array operand, where that operand is one of
these expressions,
[:zh_CN]
对某个数组操作数的下标操作（[#expr.sub]），该操作数为这里的表达式之一，

[item]
[:en]
a class member access ([#expr.ref]) using the [`.] operator where the left
operand is one of these expressions and the right operand designates a
non-static data member of non-reference type,
[:zh_CN]
使用 [`.] 运算符的类成员访问（[#expr.ref]），其中的左操作数为这里的表达式之一，
且其右操作数代表具有非引用类型的某个非静态数据成员，

[item]
[:en]
a pointer-to-member operation ([#expr.mptr.oper]) using the [`.*] operator
where the left operand is one of these expressions and the right operand is a
pointer to data member of non-reference type,
[:zh_CN]
使用 [`.*] 运算符的成员指针操作（[#expr.mptr.oper]），其中的左操作数为这里的
表达式之一，且其右操作数为指向具有非引用类型的数据成员的指针，

[item]
[:en]
a
[:zh_CN]
以

[list]
[item]
[:en@~] [`const_cast] ([#expr.const.cast]),
[:zh_CN@~] [`const_cast]（[#expr.const.cast]），
[item]
[:en@~] [`static_cast] ([#expr.static.cast]),
[:zh_CN@~] [`static_cast]（[#expr.static.cast]），
[item]
[:en@~] [`dynamic_cast] ([#expr.dynamic.cast]), or
[:zh_CN@~] [`dynamic_cast]（[#expr.dynamic.cast]），或者
[item]
[:en@~] [`reinterpret_cast] ([#expr.reinterpret.cast])
[:zh_CN@~] [`reinterpret_cast]（[#expr.reinterpret.cast]）
[list:end]

[:en@~]
converting, without a user-defined conversion, a glvalue operand that is one of
these expressions to a glvalue that refers to the object designated by the
operand, or to its complete object or a subobject thereof,
[:zh_CN@~]
实施的转换，不进行用户定义的转换，将这里的表达式之一的泛左值操作数转换为指代由
该操作数所代表的对象，或指代其完整对象或子对象的泛左值，

[item]
[:en]
a conditional expression ([#expr.cond]) that is a glvalue where the second or
third operand is one of these expressions, or
[:zh_CN]
条件表达式（[#expr.cond]），是泛左值，其第二个或第三个操作数为这里的表达式之一，
或者

[item]
[:en]
a comma expression ([#expr.comma]) that is a glvalue where the right operand is
one of these expressions.
[:zh_CN]
逗号表达式（[#expr.comma]），是泛左值，其第二个操作数时这里的表达式之一。
[list:end]

[enter:example]
[codeblock]
template<typename T> using id = T;

int i = 1;
int&& a = id<int[3]>{1, 2, 3}[i];          // [:en] temporary array has same lifetime as [`a]
                                           // [|:zh_CN] 临时数组与 [`a] 具有相同生存期
const int& b = static_cast<const int&>(0); // [:en] temporary [`int] has same lifetime as [`b]
                                           // [|:zh_CN] 临时的 [`int] 与 [`b] 具有相同生存期
int&& c = cond ? id<int[3]>{1, 2, 3}[i] : static_cast<int&&>(0);
                                           // [:en] exactly one of the two temporaries is lifetime-extended
                                           // [|:zh_CN] 两个临时对象中恰好有一个扩展了生存期
[codeblock:end]
[exit:example]

[enter:note]
[:en]
An explicit type conversion ([#expr.type.conv], [#expr.cast]) is interpreted as
a sequence of elementary casts, covered above.
[:zh_CN]
显式类型转换（[#expr.type.conv]，[#expr.cast]）可被解释为一系列的基本强制转换，
已被上文覆盖。

[enter:example]
[codeblock]
const int& x = (const int&)1;  // [:en] temporary for value 1 has same lifetime as x
                               // [|:zh_CN] 对值 1 的临时对象与 [`x] 具有相同生存期
[codeblock:end]
[exit:example]
[exit:note]

[enter:note]
[:en]
If a temporary object has a reference member initialized by another temporary
object, lifetime extension applies recursively to such a member[=']s
initializer.
[:zh_CN]
如果临时对象中有一个以其他临时对象初始化的引用成员，则对这种成员初始化式递归运用
生存期扩展。

[enter:example]
[codeblock]
struct S {
  const int& m;
};
const S& s = S{1};             // [:en] both [`S] and [`int] temporaries have lifetime of [`s]
                               // [|:zh_CN] [`S] 和 [`int] 的临时对象都具有 [`s] 的生存期
[codeblock:end]
[exit:example]
[exit:note]

[:en]
The exceptions to this lifetime rule are:
[:zh_CN]
这条生存期规则的例外情况为：

[list]
[item]
[:en]
A temporary object bound to a reference parameter in a function call
([#expr.call]) persists until the completion of the full-expression containing
the call.
[:zh_CN]
在函数调用（[#expr.call]）中绑定到引用形参的临时对象，持续到包含该调用的全表达式
完成时。

[item]
[:en]
A temporary object bound to a reference element of an aggregate of class type
initialized from a parenthesized [~expression-list] ([#dcl.init]) persists until
the completion of the full-expression containing the [~expression-list].
[:zh_CN]
在以带括号的[~表达式列表]所初始化的类类型的聚合（[#dcl.init]）中绑定到其引用元素
的临时对象，持续到包含该[~表达式列表]的全表达式完成时。

[item]
[:en]
The lifetime of a temporary bound to the returned value in a function [`return]
statement ([#stmt.return]) is not extended; the temporary is destroyed at the
end of the full-expression in the [`return] statement.
[:zh_CN]
在函数 [`return] 语句（[#stmt.return]）中绑定到返回值的临时对象的生存期并未扩展，
这个临时对象将在该 [`return] 语句中的全表达式结尾处被销毁。

[item]
[:en]
A temporary bound to a reference in a [~new-initializer] ([#expr.new]) persists
until the completion of the full-expression containing the [~new-initializer].
[:zh_CN]
在 [~new-初始化式]（[#expr.new]）中绑定到引用上的临时对象，持续到包含该
[~new-初始化式]的全表达式完成时。

[enter:example]
[codeblock]
struct S { int mi; const std::pair<int,int>& mp; };
S a { 1, {2,3} };
S* p = new S{ 1, {2,3} };   // [:en] Creates dangling reference
                            // [|:zh_CN] 创建了悬挂的引用
[codeblock:end]
[exit:example]
[list:end]

[para]
[:en]
The destruction of a temporary whose lifetime is not extended by being bound to
a reference is sequenced before the destruction of every temporary which is
constructed earlier in the same full-expression.
[:zh_CN]
生存期没有因为被绑定到引用上而被扩展的临时对象的销毁，按顺序早于在相同的全表达式
中更早被构造的所有临时对象的销毁。

[:en]
If the lifetime of two or more temporaries to which references are bound ends
at the same point, these temporaries are destroyed at that point in the reverse
order of the completion of their construction.
[:zh_CN]
如果两个或多个绑定到引用的临时对象的生存期在同一处结束，则这些临时对象在该处以与
它们构造完成相反的顺序销毁。

[:en]
In addition, the destruction of temporaries bound to references shall take into
account the ordering of destruction of objects with static, thread, or automatic
storage duration ([#basic.stc.static], [#basic.stc.thread], [#basic.stc.auto]);
that is, if [`obj1] is an object with the same storage duration as the temporary
and created before the temporary is created the temporary shall be destroyed
before [`obj1] is destroyed; if [`obj2] is an object with the same storage
duration as the temporary and created after the temporary is created the
temporary shall be destroyed after [`obj2] is destroyed.
[:zh_CN]
此外，绑定到引用的临时对象的销毁，应当与具有静态、线程或自动存储期
（[#basic.stc.static]，[#basic.stc.thread]，[#basic.stc.auto]）的对象的销毁顺序
一同考虑；就是说，如果 [`obj1] 是具有与临时对象相同存储期的，创建于临时对象创建
之前的对象，那么该临时对象应当在 [`obj1] 被销毁之前销毁；如果 [`obj2] 是与临时
对象相同存储期的，创建于临时对象创建之后的具有对象，那么该临时对象应当在 [`obj2]
被销毁之后销毁。

[para]
[enter:example]
[codeblock]
struct S {
  S();
  S(int);
  friend S operator+(const S&, const S&);
  ~S();
};
S obj1;
const S& cr = S(16)+S(23);
S obj2;
[codeblock:end]

[:en]
The expression [`S(16) + S(23)] creates three temporaries: a first temporary
[`T1] to hold the result of the expression [`S(16)], a second temporary [`T2]
to hold the result of the expression [`S(23)], and a third temporary [`T3] to
hold the result of the addition of these two expressions.
[:zh_CN]
表达式 [`S(16) + S(23)] 创建了三个临时对象：第一个临时对象 [`T1] 用以持有表达式
[`S(16)] 的结果，第二个临时对象 [`T2] 用以持有表达式 [`S(23)] 的结果，而第三个
临时对象 [`T3] 用以持有这两个表达式相加的结果。

[:en]
The temporary [`T3] is then bound to the reference [`cr].
[:zh_CN]
临时对象 [`T3] 随即被绑定到引用 [`cr] 上。

[:en]
It is unspecified whether [`T1] or [`T2] is created first.
[:zh_CN]
[`T1] 和 [`T2] 哪个先创建是未指明的。

[:en]
On an implementation where [`T1] is created before [`T2], [`T2] shall be
destroyed before [`T1].
[:zh_CN]
在 [`T1] 比 [`T2] 先创建的实现中，保证 [`T2] 比 [`T1] 先销毁。

[:en]
The temporaries [`T1] and [`T2] are bound to the reference parameters of
[`operator+]; these temporaries are destroyed at the end of the full-expression
containing the call to [`operator+].
[:zh_CN]
临时对象 [`T1] 和 [`T2] 被绑定到 [`operator+] 的引用形参上；这些临时对象在包含对
[`operator+] 的调用的全表达式的结尾处被销毁。

[:en]
The temporary [`T3] bound to the reference [`cr] is destroyed at the end of
[`cr][=']s lifetime, that is, at the end of the program.
[:zh_CN]
被绑定到引用 [`cr] 上的临时对象 [`T3] 在 [`cr] 的生存期结束时，也就是在程序的
末尾被销毁。

[:en]
In addition, the order in which [`T3] is destroyed takes into account the
destruction order of other objects with static storage duration.
[:zh_CN]
此外，[`T3] 的销毁顺序与其他具有静态存储期的对象的析构顺序一同考虑。

[:en]
That is, because [`obj1] is constructed before [`T3], and [`T3] is constructed
before [`obj2], [`obj2] shall be destroyed before [`T3], and [`T3] shall be
destroyed before [`obj1].
[:zh_CN]
就是说，因为 [`obj1] 在 [`T3] 之前构造，且 [`T3] 在 [`obj2] 之前构造，所以保证
[`obj2] 在 [`T3] 之前销毁，且 [`T3] 在 [`obj1] 之前销毁。
[exit:example]
