[section#depr.func.adaptor.typedefs
    [:en] Typedefs to support function binders
    [:zh_CN] 支持函数绑定器的 typedef
]

[para]
[:en] To enable old function adaptors to manipulate function objects that take
one or two arguments, many of the function objects in this International
Standard correspondingly provide [~typedef-name]s [`argument_type] and
[`result_type] for function objects that take one argument and
[`first_argument_type], [`second_argument_type], and [`result_type] for function
objects that take two arguments.
[:zh_CN] 为启用旧式函数适配器来操作接受一个或两个实参的函数对象，本国际标准中的
许多函数对象中，都相应地为接受一个实参的函数对象提供了 [~typedef-名]
[`argument_type] 和 [`result_type]，并为接受两个实参的函数对象提供了
[`first_argument_type]、[`second_argument_type] 和 [`result_type]。

[para]
[:en] The following member names are defined in addition to names specified in
[#function.objects]:
[:zh_CN] 除了在 [#function.objects] 中所指定的名字之外，还定义了下列成员名：

[%@library result_type[!owner_less]]
[%@library owner_less[!result_type]]
[%@library first_argument_type[!owner_less]]
[%@library owner_less[!first_argument_type]]
[%@library second_argument_type[!owner_less]]
[%@library owner_less[!second_argument_type]]
[%@library result_type[!owner_less]]
[%@library owner_less[!result_type]]
[%@library first_argument_type[!owner_less]]
[%@library owner_less[!first_argument_type]]
[%@library second_argument_type[!owner_less]]
[%@library owner_less[!second_argument_type]]
[%@library result_type[!plus]]
[%@library plus[!result_type]]
[%@library first_argument_type[!plus]]
[%@library plus[!first_argument_type]]
[%@library second_argument_type[!plus]]
[%@library plus[!second_argument_type]]
[%@library result_type[!minus]]
[%@library minus[!result_type]]
[%@library first_argument_type[!minus]]
[%@library minus[!first_argument_type]]
[%@library second_argument_type[!minus]]
[%@library minus[!second_argument_type]]
[%@library result_type[!multiplies]]
[%@library multiplies[!result_type]]
[%@library first_argument_type[!multiplies]]
[%@library multiplies[!first_argument_type]]
[%@library second_argument_type[!multiplies]]
[%@library multiplies[!second_argument_type]]
[%@library result_type[!divides]]
[%@library divides[!result_type]]
[%@library first_argument_type[!divides]]
[%@library divides[!first_argument_type]]
[%@library second_argument_type[!divides]]
[%@library divides[!second_argument_type]]
[%@library result_type[!modulus]]
[%@library modulus[!result_type]]
[%@library first_argument_type[!modulus]]
[%@library modulus[!first_argument_type]]
[%@library second_argument_type[!modulus]]
[%@library modulus[!second_argument_type]]
[%@library result_type[!negate]]
[%@library negate[!result_type]]
[%@library argument_type[!negate]]
[%@library negate[!argument_type]]
[%@library result_type[!equal_to]]
[%@library equal_to[!result_type]]
[%@library first_argument_type[!equal_to]]
[%@library equal_to[!first_argument_type]]
[%@library second_argument_type[!equal_to]]
[%@library equal_to[!second_argument_type]]
[%@library result_type[!not_equal_to]]
[%@library not_equal_to[!result_type]]
[%@library first_argument_type[!not_equal_to]]
[%@library not_equal_to[!first_argument_type]]
[%@library second_argument_type[!not_equal_to]]
[%@library not_equal_to[!second_argument_type]]
[%@library result_type[!greater]]
[%@library greater[!result_type]]
[%@library first_argument_type[!greater]]
[%@library greater[!first_argument_type]]
[%@library second_argument_type[!greater]]
[%@library greater[!second_argument_type]]
[%@library result_type[!less]]
[%@library less[!result_type]]
[%@library first_argument_type[!less]]
[%@library less[!first_argument_type]]
[%@library second_argument_type[!less]]
[%@library less[!second_argument_type]]
[%@library result_type[!greater_equal]]
[%@library greater_equal[!result_type]]
[%@library first_argument_type[!greater_equal]]
[%@library greater_equal[!first_argument_type]]
[%@library second_argument_type[!greater_equal]]
[%@library greater_equal[!second_argument_type]]
[%@library result_type[!less_equal]]
[%@library less_equal[!result_type]]
[%@library first_argument_type[!less_equal]]
[%@library less_equal[!first_argument_type]]
[%@library second_argument_type[!less_equal]]
[%@library less_equal[!second_argument_type]]
[%@library result_type[!logical_and]]
[%@library logical_and[!result_type]]
[%@library first_argument_type[!logical_and]]
[%@library logical_and[!first_argument_type]]
[%@library second_argument_type[!logical_and]]
[%@library logical_and[!second_argument_type]]
[%@library result_type[!logical_or]]
[%@library logical_or[!result_type]]
[%@library first_argument_type[!logical_or]]
[%@library logical_or[!first_argument_type]]
[%@library second_argument_type[!logical_or]]
[%@library logical_or[!second_argument_type]]
[%@library result_type[!logical_not]]
[%@library logical_not[!result_type]]
[%@library argument_type[!logical_not]]
[%@library logical_not[!argument_type]]
[%@library result_type[!bit_and]]
[%@library bit_and[!result_type]]
[%@library first_argument_type[!bit_and]]
[%@library bit_and[!first_argument_type]]
[%@library second_argument_type[!bit_and]]
[%@library bit_and[!second_argument_type]]
[%@library result_type[!bit_or]]
[%@library bit_or[!result_type]]
[%@library first_argument_type[!bit_or]]
[%@library bit_or[!first_argument_type]]
[%@library second_argument_type[!bit_or]]
[%@library bit_or[!second_argument_type]]
[%@library result_type[!bit_xor]]
[%@library bit_xor[!result_type]]
[%@library first_argument_type[!bit_xor]]
[%@library bit_xor[!first_argument_type]]
[%@library second_argument_type[!bit_xor]]
[%@library bit_xor[!second_argument_type]]
[%@library result_type[!bit_not]]
[%@library bit_not[!result_type]]
[%@library argument_type[!bit_not]]
[%@library bit_not[!argument_type]]
[%@library result_type[!function]]
[%@library function[!result_type]]
[%@library argument_type[!function]]
[%@library function[!argument_type]]
[%@library first_argument_type[!function]]
[%@library function[!first_argument_type]]
[%@library second_argument_type[!function]]
[%@library function[!second_argument_type]]
[codeblock:synopsis [!:mark SeeBelow] ]
namespace std {
  template<class T> struct owner_less<shared_ptr<T>> {
    using result_type          = bool;
    using first_argument_type  = shared_ptr<T>;
    using second_argument_type = shared_ptr<T>;
  };

  template<class T> struct owner_less<weak_ptr<T>> {
    using result_type          = bool;
    using first_argument_type  = weak_ptr<T>;
    using second_argument_type = weak_ptr<T>;
  };

  template<class T> class reference_wrapper {
  public:
    using result_type          = [=SeeBelow]; // [:en] not always defined
                                              // [|:zh_CN] 不总有定义
    using argument_type        = [=SeeBelow]; // [:en] not always defined
                                              // [|:zh_CN] 不总有定义
    using first_argument_type  = [=SeeBelow]; // [:en] not always defined
                                              // [|:zh_CN] 不总有定义
    using second_argument_type = [=SeeBelow]; // [:en] not always defined
                                              // [|:zh_CN] 不总有定义
  };

  template<class T> struct plus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct minus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct multiplies {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct divides {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct modulus {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct negate {
    using argument_type = T;
    using result_type   = T;
  };

  template<class T> struct equal_to {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct not_equal_to {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct greater {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct less {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct greater_equal {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct less_equal {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct logical_and {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct logical_or {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = bool;
  };

  template<class T> struct logical_not {
    using argument_type = T;
    using result_type   = bool;
  };

  template<class T> struct bit_and {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct bit_or {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct bit_xor {
    using first_argument_type  = T;
    using second_argument_type = T;
    using result_type          = T;
  };

  template<class T> struct bit_not {
    using argument_type = T;
    using result_type   = T;
  };

  template<class R, class T1> class function<R(T1)> {
  public:
    using argument_type = T1;
  };

  template<class R, class T1, class T2> class function<R(T1, T2)> {
  public:
    using first_argument_type  = T1;
    using second_argument_type = T2;
  };
}
[codeblock:end]

[%@library reference_wrapper[![:en]weak result type[:zh_CN]弱结果类型]]
[para]
[:en] [`reference_wrapper<T>] has a weak result type ([#depr.weak.result_type]).
[:zh_CN] [`reference_wrapper<T>] 带有弱结果类型（[#depr.weak.result_type]）。

[:en] If [`T] is a function type, [`result_type] shall be a synonym for the
return type of [`T].
[:zh_CN] 当 [`T] 是函数类型时，[`result_type] 应当为 [`T] 的返回类型的同义词。

[%@library argument_type[!reference_wrapper]]
[%@library reference_wrapper[!argument_type]]
[para]
[:en] The template specialization [`reference_wrapper<T>] shall define a nested
type named [`argument_type] as a synonym for [`T1] only if the type [`T] is any
of the following:
[:zh_CN] 仅当类型 [`T] 为以下之一时，模板特例 [`reference_wrapper<T>] 应当定义
名为 [`argument_type] 的嵌套类型使其作为 [`T1] 的同义词：

[list]
[item]
[:en] a function type or a pointer to function type taking one argument of type
[`T1]
[:zh_CN] 接受一个 [`T1] 类型的函数类型或函数指针类型

[item]
[:en] a pointer to member function [`R T0::f() [$cv]] (where [$cv] represents
the member function[=']s cv-qualifiers); the type [`T1] is [$cv] [`T0*]
[:zh_CN] 成员函数指针 [`R T0::f() [$cv]]（其中 [$cv] 代表成员函数的 cv 限定符）；
类型 [`T1] 为 [$cv] [`T0*]

[item]
[:en] a class type where the [~qualified-id] [`T::argument_type] is valid and
denotes a type ([#temp.deduct]); the type [`T1] is [`T::argument_type].
[:zh_CN] 类类型，其中[~限定标识] [`T::argument_type] 有效且代表某个类型
（[#temp.deduct]）；类型 [`T1] 为 [`T::argument_type]。
[list:end]

[%@library first_argument_type[!reference_wrapper]]
[%@library reference_wrapper[!first_argument_type]]
[%@library second_argument_type[!reference_wrapper]]
[%@library reference_wrapper[!second_argument_type]]
[para]
[:en] The template specialization [`reference_wrapper<T>] shall define two
nested types named [`first_argument_type] and [`second_argument_type] as
synonyms for [`T1] and [`T2], respectively, only if the type [`T] is any
of the following:
[:zh_CN] 仅当类型 [`T] 为以下之一时，模板特例 [`reference_wrapper<T>] 应当定义
名为 [`first_argument_type] 和 [`second_argument_type] 的嵌套类型使其分别作为
[`T1] 和 [`T2] 的同义词：

[list]
[item]
[:en] a function type or a pointer to function type taking two arguments of
types [`T1] and [T2]
[:zh_CN] 接受两个 [`T1] 和 [`T2] 类型的函数类型或函数指针类型

[item]
[:en] a pointer to member function [`R T0::f(T2) [$cv]] (where [$cv] represents
the member function[=']s cv-qualifiers); the type [`T1] is [$cv] [`T0*]
[:zh_CN] 成员函数指针 [`R T0::f(T2) [$cv]]（其中 [$cv] 代表成员函数的 cv 限定符）
；类型 [`T1] 为 [$cv] [`T0*]

[item]
[:en] a class type where the [~qualified-id]s [`T::first_argument_type] and
[`T::second_argument_type] are both valid and both denotes types
([#temp.deduct]); the type [`T1] is [`T::first_argument_type] and the type [`T2]
is [`T::second_argument_type].
[:zh_CN] 类类型，其中[~限定标识] [`T::first_argument_type] 和
[`T::second_argument_type] 都有效且都代表某个类型（[#temp.deduct]）；类型 [`T1]
为 [`T::first_argument_type]，类型 [`T2] 为 [`T::second_argument_type]。
[list:end]

[%@library result_type[!hash]]
[%@library hash[!result_type]]
[%@library argument_type[!hash]]
[%@library hash[!argument_type]]
[para]
[:en] All enabled specializations [`hash<Key>] of [`hash] ([#unord.hash])
provide two nested types, [`result_type] and [`argument_type], which shall be
synonyms for [`size_t] and [`Key], respectively.
[:zh_CN] [`hash] 的所有启用的特例 [`hash<Key>]（[#unord.hash]）都提供两个嵌套
类型 [`result_type] 和 [`argument_type]，它们应当分别是 [`size_t] 和 [`Key] 的
同义词。

[%@library bind[![:en]weak result type[:zh_CN]弱结果类型]]
[para]
[:en] The forwarding call wrapper [`g] returned by a call to
[`bind(f, bound_args...)] ([#func.bind.bind]) shall have a weak result type
([#depr.weak.result_type]).
[:zh_CN] 由调用 [`bind(f, bound_args...)]（[#func.bind.bind]）所返回的转发调用
包装器 [`g] 应当带有弱结果类型（[#depr.weak.result_type]）。

[para]
[:en] The forwarding call wrapper [`g] returned by a call to
[`bind<R>(f, bound_args...)] ([#func.bind.bind]) shall have a nested type
[`result_type] defined as a synonym for [`R].
[:zh_CN] 由调用 [`bind<R>(f, bound_args...)]（[#func.bind.bind]）所返回的转发
调用包装器 [`g] 应当带有定义为 [`R] 的同义词的嵌套类型 [`result_type]。

[%@library result_type[!mem_fn]]
[%@library mem_fn[!result_type]]
[para]
[:en] The simple call wrapper returned from a call to [`mem_fn(pm)] shall have a
nested type [`result_type] that is a synonym for the return type of [`pm] when
[`pm] is a pointer to member function.
[:zh_CN] 当 [`pm] 为成员函数指针时，由调用 [`mem_fn(pm)] 所返回的简单调用包装器
应当带有嵌套类型 [`result_type]，作为 [`pm] 的返回类型的同义词。

[%@library result_type[!mem_fn]]
[%@library mem_fn[!result_type]]
[%@library argument_type[!mem_fn]]
[%@library mem_fn[!argument_type]]
[para]
[:en] The simple call wrapper returned from a call to [`mem_fn(pm)] shall define
two nested types named [`argument_type] and [`result_type] as synonyms for
[$cv] [`T*] and [`Ret], respectively, when [`pm] is a pointer to member function
with cv-qualifier [$cv] and taking no arguments, where [`Ret] is [`pm][=']s
return type.
[:zh_CN] 当 [`pm] 是带有 cv 限定符 [$cv] 且不接受任何实参的成员函数指针时，由
调用 [`mem_fn(pm)] 所返回的简单调用包装器应当定义两个名为 [`argument_type] 和
[`result_type] 的嵌套类型，分别作为 [$cv] [`T*] 和 [`Ret] 的同义词，其中 [`Ret]
为 [`pm] 的返回类型。

[%@library result_type[!mem_fn]]
[%@library mem_fn[!result_type]]
[%@library first_argument_type[!mem_fn]]
[%@library mem_fn[!first_argument_type]]
[%@library second_argument_type[!mem_fn]]
[%@library mem_fn[!second_argument_type]]
[para]
[:en] The simple call wrapper returned from a call to [`mem_fn(pm)] shall define
three nested types named [`first_argument_type], [`second_argument_type], and
[`result_type] as synonyms for [$cv] [`T*], [`T1], and [`Ret], respectively,
when [`pm] is a pointer to member function with cv-qualifier [$cv] and taking
one argument of type [`T1], where [`Ret] is [`pm][=']s return type.
[:zh_CN] 当 [`pm] 是带有 cv 限定符 [$cv] 并接受一个 [`T1] 类型的实参的成员函数
指针时，由调用 [`mem_fn(pm)] 所返回的简单调用包装器应当定义三个名为
[`first_argument_type]、[`second_argument_type] 和 [`result_type] 的嵌套类型，
分别作为 [$cv] [`T*]、[`T1] 和 [`Ret] 的同义词，其中 [`Ret] 为 [`pm] 的返回类型。

[para]
[:en] The following member names are defined in addition to names specified in
[#containers]:
[:zh_CN] 除了在 [#containers] 中所指定的名字之外，还定义了下列成员名：

[%@library result_type[!map::value_compare]]
[%@library map::value_compare[!result_type]]
[%@library first_argument_type[!map::value_compare]]
[%@library map::value_compare[!first_argument_type]]
[%@library second_argument_type[!map::value_compare]]
[%@library map::value_compare[!second_argument_type]]
[%@library result_type[!multimap::value_compare]]
[%@library multimap::value_compare[!result_type]]
[%@library first_argument_type[!multimap::value_compare]]
[%@library multimap::value_compare[!first_argument_type]]
[%@library second_argument_type[!multimap::value_compare]]
[%@library multimap::value_compare[!second_argument_type]]
[codeblock:synopsis]
namespace std {
  template<class Key, class T, class Compare, class Allocator>
  class map<Key, T, Compare, Allocator>::value_compare {
  public:
    using result_type          = bool;
    using first_argument_type  = value_type;
    using second_argument_type = value_type;
  };

  template<class Key, class T, class Compare, class Allocator>
  class multimap<Key, T, Compare, Allocator>::value_compare {
  public:
    using result_type          = bool;
    using first_argument_type  = value_type;
    using second_argument_type = value_type;
  };
}
[codeblock:end]
