[section#depr.negators
    [:en] Negators
    [:zh_CN] 求反器
]

[para]
[%@header functional]
[:en] The header [`<functional>] has the following additions:
[:zh_CN] 头文件 [`<functional>] 有下列添加声明：

[%@library unary_negate]
[%@library not1]
[%@library binary_negate]
[%@library not2]
[codeblock:synopsis]
namespace std {
  template<class Predicate> class unary_negate;
  template<class Predicate>
    constexpr unary_negate<Predicate> not1(const Predicate&);
  template<class Predicate> class binary_negate;
  template<class Predicate>
    constexpr binary_negate<Predicate> not2(const Predicate&);
}
[codeblock:end]

[para]
[:en] Negators [`not1] and [`not2] take a unary and a binary predicate,
respectively, and return their logical negations ([#expr.unary.op]).
[:zh_CN] 求反器 [`not1] 和 [`not2] 分别接受一个一元和二元谓词并返回其逻辑逆反
（[#expr.unary.op]）。

[%@library unary_negate]
[%@library argument_type[!unary_negate]]
[%@library unary_negate[!argument_type]]
[%@library result_type[!unary_negate]]
[%@library unary_negate[!result_type]]
[codeblock:synopsis]
template<class Predicate>
class unary_negate {
public:
  constexpr explicit unary_negate(const Predicate& pred);
  constexpr bool operator()(const typename Predicate::argument_type& x) const;
  using argument_type = typename Predicate::argument_type;
  using result_type   = bool;
};
[codeblock:end]

[%@library operator()[!unary_negate]]
[%@library unary_negate[!operator()]]
[codeblock:declaration]
constexpr bool operator()(const typename Predicate::argument_type& x) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`!pred(x)].
[:zh_CN] [`!pred(x)]。
[exit:description]

[%@library not1]
[codeblock:declaration]
template<class Predicate>
   constexpr unary_negate<Predicate> not1(const Predicate& pred);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`unary_negate<Predicate>(pred)].
[:zh_CN] [`unary_negate<Predicate>(pred)]。
[exit:description]

[%@library binary_negate]
[%@library first_argument_type[!binary_negate]]
[%@library binary_negate[!first_argument_type]]
[%@library second_argument_type[!binary_negate]]
[%@library binary_negate[!second_argument_type]]
[%@library result_type[!binary_negate]]
[%@library binary_negate[!result_type]]
[codeblock:synopsis]
template<class Predicate>
class binary_negate {
public:
  constexpr explicit binary_negate(const Predicate& pred);
  constexpr bool operator()(const typename Predicate::first_argument_type& x,
                            const typename Predicate::second_argument_type& y) const;
  using first_argument_type  = typename Predicate::first_argument_type;
  using second_argument_type = typename Predicate::second_argument_type;
  using result_type          = bool;

};
[codeblock:end]

[%@library operator()[!binary_negate]]
[%@library binary_negate[!operator()]]
[codeblock:declaration]
constexpr bool operator()(const typename Predicate::first_argument_type& x,
                          const typename Predicate::second_argument_type& y) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`!pred(x,y)].
[:zh_CN] [`!pred(x,y)]。
[exit:description]

[%@library not2]
[codeblock:declaration]
template<class Predicate>
  constexpr binary_negate<Predicate> not2(const Predicate& pred);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`binary_negate<Predicate>(pred)].
[:zh_CN] [`binary_negate<Predicate>(pred)]。
[exit:description]
