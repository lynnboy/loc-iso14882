[section#algorithms.results
    [:en] Algorithm result types
    [:zh_CN] 算法结果类型
]

[para]
[:en]
Each of the class templates specified in this subclause has the template
parameters, data members, and special members specified below, and has no base
classes or members other than those specified.
[:zh_CN]
本子条款中所指定的每个类模板，具有如下所指定的模板形参、数据成员和特殊成员，并且
不具有除所指定之外的基类或成员。

[codeblock:synopsis]
namespace std::ranges {
  template<class I, class F>
  struct [[redoc("`:lib>")]]in_fun_result {
    [[no_unique_address]] I [[redoc("[%@lib@member in[!in_fun_result]]")]]in;
    [[no_unique_address]] F [[redoc("[%@lib@member fun[!in_fun_result]]")]]fun;

    template<class I2, class F2>
      requires [[redoc("`:c>")]]convertible_to<const I&, I2> && [[redoc("`:c>")]]convertible_to<const F&, F2>
    constexpr operator in_fun_result<I2, F2>() const & {
      return {in, fun};
    }

    template<class I2, class F2>
      requires [[redoc("`:c>")]]convertible_to<I, I2> && [[redoc("`:c>")]]convertible_to<F, F2>
    constexpr operator in_fun_result<I2, F2>() && {
      return {std::move(in), std::move(fun)};
    }
  };

  template<class I1, class I2>
  struct [[redoc("`:lib>")]]in_in_result {
    [[no_unique_address]] I1 [[redoc("[%@lib@member in1[!in_in_result]]")]]in1;
    [[no_unique_address]] I2 [[redoc("[%@lib@member in2[!in_in_result]]")]]in2;

    template<class II1, class II2>
      requires [[redoc("`:c>")]]convertible_to<const I1&, II1> && [[redoc("`:c>")]]convertible_to<const I2&, II2>
    constexpr operator in_in_result<II1, II2>() const & {
      return {in1, in2};
    }

    template<class II1, class II2>
      requires [[redoc("`:c>")]]convertible_to<I1, II1> && [[redoc("`:c>")]]convertible_to<I2, II2>
    constexpr operator in_in_result<II1, II2>() && {
      return {std::move(in1), std::move(in2)};
    }
  };

  template<class I, class O>
  struct [[redoc("`:lib>")]]in_out_result {
    [[no_unique_address]] I [[redoc("[%@lib@member in[!in_out_result]]")]]in;
    [[no_unique_address]] O [[redoc("[%@lib@member out[!in_out_result]]")]]out;

    template<class I2, class O2>
      requires [[redoc("`:c>")]]convertible_to<const I&, I2> && [[redoc("`:c>")]]convertible_to<const O&, O2>
    constexpr operator in_out_result<I2, O2>() const & {
      return {in, out};
    }

    template<class I2, class O2>
      requires [[redoc("`:c>")]]convertible_to<I, I2> && [[redoc("`:c>")]]convertible_to<O, O2>
    constexpr operator in_out_result<I2, O2>() && {
      return {std::move(in), std::move(out)};
    }
  };

  template<class I1, class I2, class O>
  struct [[redoc("`:lib>")]]in_in_out_result {
    [[no_unique_address]] I1 [[redoc("[%@lib@member in1[!in_in_out_result]]")]]in1;
    [[no_unique_address]] I2 [[redoc("[%@lib@member in2[!in_in_out_result]]")]]in2;
    [[no_unique_address]] O  [[redoc("[%@lib@member out[!in_in_out_result]]")]]out;

    template<class II1, class II2, class OO>
      requires [[redoc("`:c>")]]convertible_to<const I1&, II1> &&
               [[redoc("`:c>")]]convertible_to<const I2&, II2> &&
               [[redoc("`:c>")]]convertible_to<const O&, OO>
    constexpr operator in_in_out_result<II1, II2, OO>() const & {
      return {in1, in2, out};
    }

    template<class II1, class II2, class OO>
      requires [[redoc("`:c>")]]convertible_to<I1, II1> &&
               [[redoc("`:c>")]]convertible_to<I2, II2> &&
               [[redoc("`:c>")]]convertible_to<O, OO>
    constexpr operator in_in_out_result<II1, II2, OO>() && {
      return {std::move(in1), std::move(in2), std::move(out)};
    }
  };

  template<class I, class O1, class O2>
  struct [[redoc("`:lib>")]]in_out_out_result {
    [[no_unique_address]] I  [[redoc("[%@lib@member in[!in_out_out_result]]")]]in;
    [[no_unique_address]] O1 [[redoc("[%@lib@member out1[!in_out_out_result]]")]]out1;
    [[no_unique_address]] O2 [[redoc("[%@lib@member out2[!in_out_out_result]]")]]out2;

    template<class II, class OO1, class OO2>
      requires [[redoc("`:c>")]]convertible_to<const I&, II> &&
               [[redoc("`:c>")]]convertible_to<const O1&, OO1> &&
               [[redoc("`:c>")]]convertible_to<const O2&, OO2>
    constexpr operator in_out_out_result<II, OO1, OO2>() const & {
      return {in, out1, out2};
    }

    template<class II, class OO1, class OO2>
      requires [[redoc("`:c>")]]convertible_to<I, II> &&
               [[redoc("`:c>")]]convertible_to<O1, OO1> &&
               [[redoc("`:c>")]]convertible_to<O2, OO2>
    constexpr operator in_out_out_result<II, OO1, OO2>() && {
      return {std::move(in), std::move(out1), std::move(out2)};
    }
  };

  template<class T>
  struct [[redoc("`:lib>")]]min_max_result {
    [[no_unique_address]] T [[redoc("[%@lib@member min[!min_max_result]]")]]min;
    [[no_unique_address]] T [[redoc("[%@lib@member max[!min_max_result]]")]]max;

    template<class T2>
      requires [[redoc("`:c>")]]convertible_to<const T&, T2>
    constexpr operator min_max_result<T2>() const & {
      return {min, max};
    }

    template<class T2>
      requires [[redoc("`:c>")]]convertible_to<T, T2>
    constexpr operator min_max_result<T2>() && {
      return {std::move(min), std::move(max)};
    }
  };

  template<class I>
  struct [[redoc("`:lib>")]]in_found_result {
    [[no_unique_address]] I [[redoc("[%@lib@member in[!in_found_result]]")]]in;
    bool [[redoc("[%@lib@member found[!in_found_result]]")]]found;

    template<class I2>
      requires [[redoc("`:c>")]]convertible_to<const I&, I2>
    constexpr operator in_found_result<I2>() const & {
      return {in, found};
    }
    template<class I2>
      requires [[redoc("`:c>")]]convertible_to<I, I2>
    constexpr operator in_found_result<I2>() && {
      return {std::move(in), found};
    }
  };

  template<class I, class T>
  struct [[redoc("`:lib>")]]in_value_result {
    [[no_unique_address]] I [[redoc("[%@lib@member in[!in_value_result]]")]]in;
    [[no_unique_address]] T [[redoc("[%@lib@member value[!in_value_result]]")]]value;

    template<class I2, class T2>
      requires [[redoc("`:c>")]]convertible_to<const I&, I2> && [[redoc("`:c>")]]convertible_to<const T&, T2>
    constexpr operator in_value_result<I2, T2>() const & {
      return {in, value};
    }

    template<class I2, class T2>
      requires [[redoc("`:c>")]]convertible_to<I, I2> && [[redoc("`:c>")]]convertible_to<T, T2>
    constexpr operator in_value_result<I2, T2>() && {
      return {std::move(in), std::move(value)};
    }
  };

  template<class O, class T>
  struct [[redoc("`:lib>")]]out_value_result {
    [[no_unique_address]] O [[redoc("[%@lib@member out[!out_value_result]]")]]out;
    [[no_unique_address]] T [[redoc("[%@lib@member value[!out_value_result]]")]]value;

    template<class O2, class T2>
      requires [[redoc("`:c>")]]convertible_to<const O&, O2> && [[redoc("`:c>")]]convertible_to<const T&, T2>
    constexpr operator out_value_result<O2, T2>() const & {
      return {out, value};
    }

    template<class O2, class T2>
      requires [[redoc("`:c>")]]convertible_to<O, O2> && [[redoc("`:c>")]]convertible_to<T, T2>
    constexpr operator out_value_result<O2, T2>() && {
      return {std::move(out), std::move(value)};
    }
  };
}
[codeblock:end]
