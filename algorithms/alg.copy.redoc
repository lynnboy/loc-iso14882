[section#alg.copy
    [:en] Copy
    [:zh_CN] 复制
]

[%@lib copy]
[codeblock:declaration]
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator copy(InputIterator first, InputIterator last,
                                OutputIterator result);

template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O>
  requires [[redoc("`:c>")]]indirectly_copyable<I, O>
  constexpr ranges::copy_result<I, O> ranges::copy(I first, S last, O result);
template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O>
  requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O>
  constexpr ranges::copy_result<borrowed_iterator_t<R>, O> ranges::copy(R&& r, O result);
[codeblock:end]

[div:description]
[para]
[:en] Let [$N] be [`last - first].
[:zh_CN] 令 [$N] 为 [`last - first]。

[para:expects]
[:en] [`result] is not in the range [=range(first,last)].
[:zh_CN] [`result] 不处于范围 [=range(first,last)] 之中。

[para:effects]
[:en] Copies elements in the range [=range(first,last)] into the range
[=range(result,result + `[$N`])] starting from [`first] and proceeding to [`last].
[:zh_CN] 将范围 [=range(first,last)] 中的元素复制到范围
[=range(result,result + `[$N`])] 中，开始于 [`first] 并进行到 [`last]。

[:en] For each non-negative integer [$n < N], performs
[`*(result + [$n]) = *(first + [$n])].
[:zh_CN] 对于每个非负整数 [$n < N]，实施 [`*(result + [$n]) = *(first + [$n])]。

[para:returns]
[list]
[item]
[:en@~] [`result + [$N]] for the overload in namespace [`std].
[:zh_CN@~] 对于命名空间 [`std] 中的重载，返回 [`result + [$N]]。
[item]
[:en@~] [`{last, result + [$N]}] for the overloads in namespace [`ranges].
[:zh_CN@~] 对于命名空间 [`ranges] 中的重载，返回 [`{last, result + [$N]}]。
[list:end]

[para:complexity]
[:en] Exactly [$N] assignments.
[:zh_CN] 恰好进行 [$N] 次赋值。
[div:end]

[%@lib copy]
[codeblock:declaration]
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 copy(ExecutionPolicy&& exec,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);

template<[[redoc("*:c>")]]execution-policy Ep, [[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sized_sentinel_for<I> S,
         [[redoc("`:c>")]]random_access_iterator O, [[redoc("`:c>")]]sized_sentinel_for<O> OutS>
  requires [[redoc("`:c>")]]indirectly_copyable<I, O>
  ranges::copy_result<I, O>
    ranges::copy(Ep&& exec, I first, S last, O result, OutS result_last);
template<[[redoc("*:c>")]]execution-policy Ep, [[redoc("*:c>")]]sized-random-access-range R, [[redoc("*:c>")]]sized-random-access-range OutR>
  requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::copy_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::copy(Ep&& exec, R&& r, OutR&& result_r);
[codeblock:end]

[div:description]
[para]
[:en] Let [`result_last] be [`result + (last - first)] for the overload in namespace [`std].
[:zh_CN] 令 [`result_last] 对于命名空间 [`std] 中的重载为 [`result + (last - first)]。

[para]
[:en] Let [$N] be [$\min([`last - first], \ [`result_last - result])].
[:zh_CN] 令 [$N] 为 [$\min([`last - first], \ [`result_last - result])]。

[para:expects]
[:en] The ranges [=range(first,last)] and [=range(result,result + [$N]] do not overlap.
[:zh_CN] 范围 [=range(first,last)] 和 [=range(result,result + [$N]] 没有重叠。

[para:effects]
[:en] Copies elements in the range [=range(first,first + [$N])] into the range
[=range(result,result + [$N])].
[:zh_CN] 将范围 [=range(first,first + [$N])] 中的元素复制到范围
[=range(result,result + [$N])] 中。

[:en] For each non-negative integer [$n < N], performs [`*(result + [$n]) = *(first + [$n])].
[:zh_CN] 对于每个非负整数 [$n < N]，实施 [`*(result + [$n]) = *(first + [$n])]。

[para:returns]
[list]
[item]
[:en] [`result + [$N]] for the overload in namespace [`std].
[:zh_CN] 对于命名空间 [`std] 中的重载，返回 [`result + (last - first)]。
[item]
[:en] [`{first + [$N], result + [$N]}] for the overload in namespace [`ranges].
[:zh_CN] 对于命名空间 [`ranges] 中的重载，返回 [`{first + [$N], result + [$N]}]。
[list:end]

[para:complexity]
[:en] Exactly [$N] assignments.
[:zh_CN] 恰好进行 [$N] 次赋值。
[div:end]

[%@lib copy_n]
[codeblock:declaration]
template<class InputIterator, class Size, class OutputIterator>
  constexpr OutputIterator copy_n(InputIterator first, Size n,
                                  OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class Size, class ForwardIterator2>
  ForwardIterator2 copy_n(ExecutionPolicy&& exec,
                          ForwardIterator1 first, Size n,
                          ForwardIterator2 result);

template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]weakly_incrementable O>
  requires [[redoc("`:c>")]]indirectly_copyable<I, O>
  constexpr ranges::copy_n_result<I, O>
    ranges::copy_n(I first, iter_difference_t<I> n, O result);

template<[[redoc("*:c>")]]execution-policy Ep, [[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]random_access_iterator O,
         [[redoc("`:c>")]]sized_sentinel_for<O> OutS>
  requires [[redoc("`:c>")]]indirectly_copyable<I, O>
  ranges::copy_n_result<I, O>
    ranges::copy_n(Ep&& exec, I first, iter_difference_t<I> n, O result, OutS result_last);
[codeblock:end]

[div:description]
[para]
[:en] Let [$N] be [$\max(0, [`n])].
[:zh_CN] 令 [$N] 为 [$\max(0, [`n])]。

[para]
[:en] Let [`result_last] be [`result + [$M]] for the overloads with no parameter [`result_last].
[:zh_CN] 令 [`result_last] 对于没有 [`result_last] 形参的重载为 [`result + [$M]]。

[para]
[:en] Let [$M] be [$\min([`result_last - result], M)].
[:zh_CN] 令 [$M] 为 [$\min([`result_last - result], M)]。

[para:mandates]
[:en] The type [`Size] is convertible to an integral type ([#conv.integral], [#class.conv]).
[:zh_CN] 类型 [`Size] 可以转换为整型类型（[#conv.integral]，[#class.conv]）。

[para:effects]
[:en] For each non-negative integer [$i < N], performs
[`*(result + [$i]) = *(first + [$i])].
[:zh_CN] 对于每个非负整数 [$i < N]，实施 [`*(result + [$i]) = *(first + [$i])]。

[para:returns]
[list]
[item]
[:en@~] [`result + [$N]] for the overload in namespace [`std].
[:zh_CN@~] 对于命名空间 [`std] 中的重载，返回 [`result + [$N]]。
[item]
[:en@~] [`{first + [$N], result + [$N]}] for the overloads in namespace [`ranges].
[:zh_CN@~] 对于命名空间 [`ranges] 中的重载，返回 [`{first + [$N], result + [$N]}]。
[list:end]

[para:complexity]
[:en] Exactly [$N] assignments.
[:zh_CN] 恰好进行 [$N] 次赋值。
[div:end]

[%@lib copy_if]
[codeblock:declaration]
template<class InputIterator, class OutputIterator, class Predicate>
  constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
                                   OutputIterator result, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Predicate>
  ForwardIterator2 copy_if(ExecutionPolicy&& exec,
                           ForwardIterator1 first, ForwardIterator1 last,
                           ForwardIterator2 result, Predicate pred);

template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O, class Proj = identity,
         [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
  requires [[redoc("`:c>")]]indirectly_copyable<I, O>
  constexpr ranges::copy_if_result<I, O>
    ranges::copy_if(I first, S last, O result, Pred pred, Proj proj = {});
template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O, class Proj = identity,
         [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O>
  constexpr ranges::copy_if_result<borrowed_iterator_t<R>, O>
    ranges::copy_if(R&& r, O result, Pred pred, Proj proj = {});

template<[[redoc("*:c>")]]execution-policy Ep, [[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sized_sentinel_for<I> S,
          [[redoc("`:c>")]]random_access_iterator O, [[redoc("`:c>")]]sized_sentinel_for<O> OutS,
          class Proj = identity, [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
  requires [[redoc("`:c>")]]indirectly_copyable<I, O>
  ranges::copy_if_result<I, O>
    ranges::copy_if(Ep&& exec, I first, S last, O result, OutS result_last,
                    Pred pred, Proj proj = {});
template<[[redoc("*:c>")]]execution-policy Ep, [[redoc("*:c>")]]sized-random-access-range R, [[redoc("*:c>")]]sized-random-access-range OutR,
          class Proj = identity,
          [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
  requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, iterator_t<OutR>>
  ranges::copy_if_result<borrowed_iterator_t<R>, borrowed_iterator_t<OutR>>
    ranges::copy_if(Ep&& exec, R&& r, OutR&& result_r, Pred pred, Proj proj = {});
[codeblock:end]

[div:description]
[para]
[:en] Let [$E([`i])] be:
[:zh_CN] 令 [$E([`i])]：

[list]
[item]
[:en@~] [`bool(pred(*i))] for the overloads in namespace [`std].
[:zh_CN@~] 对于命名空间 [`std] 中的重载，为 [`bool(pred(*i))]。
[item]
[:en@~] [`bool(invoke(pred, invoke(proj, *i)))] for the overloads in namespace [`ranges].
[:zh_CN@~] 对于命名空间 [`ranges] 中的重载，为
[`bool(invoke(pred, invoke(proj, *i)))]。
[list:end]

[para]
[:en] Let:
[:zh_CN] 令：
[list]
[item]
[:en@~] [$M] be the number of iterators [`i] in the range [=range(first,last)]
for which the condition [$E([`i])] holds;
[:zh_CN@~] [$N] 为范围 [=range(first,last)] 中使得条件 [$E([`i])] 成立的迭代器 [`i] 的数量。
[item]
[:en@~] [`result_last] be [`result + [$M]] for the overloads with no parameter
[`result_last] or [`result_r];
[:zh_CN@~] 对于没有 [`result_last] 或 [`result_r] 形参的重载，[`result_last] 为 [`result + [$M]]；
[item]
[:en@~] [$N] be [$\min(M, [`result_last - result])].
[:zh_CN@~] 令 [$N] 为 [$\min(M, [`result_last - result])]。
[list:end]

[para:expects]
[:en] The ranges [=range(first,last)] and [=range(result,result + [$N])] do not overlap.
[:zh_CN] 范围 [=range(first,last)] 和 [=range(result,result + [$N])] 没有重叠。

[begin:note]
[:en] For the parallel algorithm overload in namespace [`std], there can be a
performance cost if [`iterator_traits<ForwardIterator1>::value_type] does not
meet the [^:oc MoveConstructible] ([#:tab#cpp17.moveconstructible]) requirements.
[:zh_CN] 对于命名空间 [`std] 中的并行算法重载，当
[`iterator_traits<ForwardIterator1>::value_type] 不满足 [^:oc MoveConstructible]
（[#:tab#cpp17.moveconstructible]）的规定时可能存在一些性能损耗。

[:en] For the parallel algorithm overloads in namespace [`ranges], there can be
a performance cost if [`iter_value_t<I>] does not model [`:c move_constructible].
[:zh_CN] 对于命名空间 [`ranges] 中的并行算法重载，当
[`iter_value_t<I>] 不构成 [`:c move_constructible] 时可能存在一些性能损耗。
[end:note]

[para:effects]
[:en] Copies the first [$N] elements referred to by the iterator [`i] in the range
[=range(first,last)] for which [$E([`i])] is [`true] into the range [=range(result,result + [$N])].
[:zh_CN] 将范围 [=range(first,last)] 中由迭代器 [`i] 所指代的前 [$N] 个使 [$E] 为
[`true] 的元素，复制到范围 [=range(result,result + [$N])] 中。

[para:returns]
[list]
[item]
[:en] [`result + [$N]] for the overload in namespace [`std].
[:zh_CN] 对于命名空间 [`std] 中的重载，返回 [`result + [$N]]。
[item]
[:en] [`{last, result + [$N]}] for the overloads in namespace [`ranges],
if [$N] is equal to [$M].
[:zh_CN] 对于命名空间 [`ranges] 中的重载，若 [$N] 等于 [$M]，则返回 [`{last, result + [$N]}]。
[item]
[:en] Otherwise, [`{j, result_last}] for the overloads in namespace [`ranges],
where [`j] is the iterator in [=range(first,last)] for which [$E([`j])] holds and
there are exactly [$N] iterators [`i] in [=range(first,j)] for which [$E([`i])] holds.
[:zh_CN] 否则，对于命名空间 [`ranges] 中的重载，返回 [`{j, result_last}]，其中 [`j] 是
[=range(first,last)] 中使 [$E([`j])] 成立的迭代器，并且在 [=range(first,j)] 中
恰好有 [$N] 个迭代器 [`i] 使 [$E([`i])] 成立。
[list:end]

[para:complexity]
[:en] At most [`last - first] applications of the corresponding predicate and
any projection.
[:zh_CN] 最多进行 [`last - first] 次对应谓词和任何投射的运用。

[para:remarks]
[:en] Stable ([#algorithm.stable]).
[:zh_CN] 稳定的（[#algorithm.stable]）。
[div:end]

[%@lib copy_backward]
[codeblock:declaration]
template<class BidirectionalIterator1, class BidirectionalIterator2>
  constexpr BidirectionalIterator2
    copy_backward(BidirectionalIterator1 first,
                  BidirectionalIterator1 last,
                  BidirectionalIterator2 result);

template<[[redoc("`:c>")]]bidirectional_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]bidirectional_iterator I2>
  requires [[redoc("`:c>")]]indirectly_copyable<I1, I2>
  constexpr ranges::copy_backward_result<I1, I2>
    ranges::copy_backward(I1 first, S1 last, I2 result);
template<[[redoc("`:c>")]]bidirectional_range R, [[redoc("`:c>")]]bidirectional_iterator I>
  requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, I>
  constexpr ranges::copy_backward_result<borrowed_iterator_t<R>, I>
    ranges::copy_backward(R&& r, I result);
[codeblock:end]

[div:description]
[para]
[:en] Let [$N] be [`last - first].
[:zh_CN] 令 [$N] 为 [`last - first]。

[para:expects]
[:en] [`result] is not in the range [=brange(first,last)].
[:zh_CN] [`result] 不处于范围 [=brange(first,last)] 之中。

[para:effects]
[:en] Copies elements in the range [=range(first,last)] into the range
[=range(result - `[$N`],result)] starting from [`last - 1] and proceeding
to [`first].[#:fn]
[:zh_CN] 将范围 [=range(first,last)] 中的元素复制到范围
[=range(result - `[$N`],result)] 中，开始于 [`last - 1] 并进行到 [`first][#:fn]。

[note:foot]
[:en] [`copy_backward] can be used instead of [`copy] when [`last] is in
the range [=range(result - `[$N`],result)].
[:zh_CN] 如果 [`last] 处于范围 [=range(result - `[$N`],result)] 之中，则可以用
[`copy_backward] 来代替 [`copy]。
[note:end]

[:en] For each positive integer [$n \le N], performs
[`*(result - [$n]) = *(last - [$n])].
[:zh_CN] 对于每个正整数 [$n \le N]，实施 [`*(result - [$n]) = *(last - [$n])]。

[para:returns]
[list]
[item]
[:en@~] [`result - [$N]] for the overload in namespace [`std].
[:zh_CN@~] 对于命名空间 [`std] 中的重载，返回 [`result - [$N]]。
[item]
[:en@~] [`{last, result - [$N]}] for the overloads in namespace [`ranges].
[:zh_CN@~] 对于命名空间 [`ranges] 中的重载，返回 [`{last, result - [$N]}]。
[list:end]

[para:complexity]
[:en] Exactly [$N] assignments.
[:zh_CN] 恰好进行 [$N] 次赋值。
[div:end]
