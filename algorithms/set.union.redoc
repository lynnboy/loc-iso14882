[section#set.union
    [`set_union]
]

[%@lib set_union]
[codeblock:declaration]
template<class InputIterator1, class InputIterator2, class OutputIterator>
  constexpr OutputIterator
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2,
              OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_union(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator2 last2,
              ForwardIterator result);

template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
  constexpr OutputIterator
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2,
              OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_union(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator2 last2,
              ForwardIterator result, Compare comp);

template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
         [[redoc("`:c>")]]weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires [[redoc("`:c>")]]mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_union_result<I1, I2, O>
    ranges::set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, [[redoc("`:c>")]]weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires [[redoc("`:c>")]]mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
    ranges::set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});

template<[[redoc("*:c>")]]execution-policy Ep, [[redoc("`:c>")]]random_access_iterator I1, [[redoc("`:c>")]]sized_sentinel_for<I1> S1,
         [[redoc("`:c>")]]random_access_iterator I2, [[redoc("`:c>")]]sized_sentinel_for<I2> S2,
         [[redoc("`:c>")]]random_access_iterator O, [[redoc("`:c>")]]sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires [[redoc("`:c>")]]mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::set_union_result<I1, I2, O>
    ranges::set_union(Ep&& exec, I1 first1, S1 last1,
                      I2 first2, S2 last2, O result, OutS result_last,
                      Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<[[redoc("*:c>")]]execution-policy Ep, [[redoc("*:c>")]]sized-random-access-range R1, [[redoc("*:c>")]]sized-random-access-range R2,
         [[redoc("*:c>")]]sized-random-access-range OutR, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires [[redoc("`:c>")]]mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>,
                           borrowed_iterator_t<OutR>>
    ranges::set_union(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r, Comp comp = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
[codeblock:end]

[div:description]
[para]
[:en] Let:
[:zh_CN] 令：
[list]
[item]
[:en@~] [`comp] be [`less{}], and [`proj1] be [`identity{}], and [`proj2] be
[`identity{}], for the overloads with no parameters by those names;
[:zh_CN@~] 对于没有名为 [`comp]、[`proj1] 和 [`proj2] 的形参的重载，令 [`comp]
为 [`less()]，[`proj1] 为 [`identity{}]，以及 [`proj2] 为 [`identity{}]；
[item]
[:en@~] [$M] be [`last1 - first1] plus the number of elements in
[=range(first2,last2)] that are not present in [=range(first1,last1)];
[:zh_CN@~] [$M] 为 [`last1 - first1] 加上未出现在
[=range(first1,last1)] 中的 [=range(first2,last2)] 中的元素个数；
[item]
[:en@~] [`result_last] be [`result + [$M]] for the overloads with no parameter
[`result_last] or [`result_r];
[:zh_CN@~] 对于没有 [`result_last] 或 [`result_r] 形参的重载，令
[`result_last] 为 [`result + [$M]]；
[item]
[:en@~] [$N] be [$\min(M, \ [`result_last - result])].
[:zh_CN@~] [$N] 为 [$\min(M, \ [`result_last - result])]。
[list:end]

[para:expects]
[:en] The ranges [=range(first1,last1)] and [=range(first2,last2)] are sorted
with respect to [`comp] and [`proj1] or [`proj2], respectively.
[:zh_CN] 范围 [=range(first1,last1)] 和 [=range(first2,last2)] 分别根据
[`comp] 和 [`proj1] 或 [`proj2] 有序。

[:en] The resulting range does not overlap with either of the original ranges.
[:zh_CN] 结果范围不与任何一个源范围有重叠。

[para:effects]
[:en] Constructs a sorted union of [$N] elements from the two ranges; that is,
the set of elements that are present in one or both of the ranges.
[:zh_CN] 构造两个范围中 [$N] 个元素的有序并集；就是说，由出现于一个或两个范围的元素所构成的集合。

[para:returns]
[list]
[item]
[:en] [`result_last] for the overloads in namespace [`std].
[:zh_CN] 命名空间 [`std] 中的各重载返回 [`result_last]。
[item]
[:en] [`{last1, last2, result + [$N]}] for the overloads in namespace [`ranges],
if [$N] is equal to [$M].
[:zh_CN] 命名空间 [`ranges] 中的各重载，当 [$N] 等于 [$M] 时，返回
[`{last1, last2, result + [$N]}]。
[item]
[:en] Otherwise, [`{j1, j2, result_last}] for the overloads in namespace [`ranges],
where the iterators [`j1] and [`j2] point to positions past the last copied or
skipped elements in [=range(first1,last1)] and [=range(first2,last2)], respectively.
[:zh_CN] 否则，命名空间 [`ranges] 中的各重载返回 [`{j1, j2, result_last}]，
其中迭代器 [`j1] 和 [`j2] 分别指向 [=range(first1,last1)] 和
[=range(first2,last2)] 中最后一个被复制或跳过的元素之后的位置。
[list:end]

[para:complexity]
[:en] At most [`2 * ((last1 - first1) + (last2 - first2)) - 1] comparisons and
applications of each projection.
[:zh_CN] 最多进行 [`2 * ((last1 - first1) + (last2 - first2)) - 1] 次比较和每种投射的运用。

[para:remarks]
[:en] Stable ([#algorithm.stable]).
[:zh_CN] 稳定的（[#algorithm.stable]）。

[:en] If [=range(first1,last1)] contains [$m] elements that are equivalent to
each other and [=range(first2,last2)] contains [$n] elements that are equivalent
to them, then all [$m] elements from the first range are copied to the output
range, in order, and then the final [$\max(n - m, 0)] elements from the second
range are copied to the output range, in order.
[:zh_CN] 如果 [=range(first1,last1)] 包含 [$m] 个互相等价的元素，而
[=range(first2,last2)] 包含 [$n] 个与其等价的元素，则第一个范围中的全部 [$m] 个元素
被依序复制到输出范围中，并且第二个范围中的 [$\max(n - m, 0)] 个元素被依序复制到输出范围中。
[div:end]
