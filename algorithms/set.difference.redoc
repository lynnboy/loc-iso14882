[section#set.difference
    [`set_difference]
]

[%@lib set_difference]
[codeblock:declaration]
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2,
                   OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_difference(ExecutionPolicy&& exec,
                   ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2,
                   ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2,
                   OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_difference(ExecutionPolicy&& exec,
                   ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2,
                   ForwardIterator result, Compare comp);

template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
         [[redoc("`:c>")]]weakly_incrementable O, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires [[redoc("`:c>")]]mergeable<I1, I2, O, Comp, Proj1, Proj2>
  constexpr ranges::set_difference_result<I1, O>
    ranges::set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, [[redoc("`:c>")]]weakly_incrementable O,
         class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
  requires [[redoc("`:c>")]]mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
  constexpr ranges::set_difference_result<borrowed_iterator_t<R1>, O>
    ranges::set_difference(R1&& r1, R2&& r2, O result,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});

template<[[redoc("*:c>")]]execution-policy Ep, [[redoc("`:c>")]]random_access_iterator I1, [[redoc("`:c>")]]sized_sentinel_for<I1> S1,
         [[redoc("`:c>")]]random_access_iterator I2, [[redoc("`:c>")]]sized_sentinel_for<I2> S2,
         [[redoc("`:c>")]]random_access_iterator O, [[redoc("`:c>")]]sized_sentinel_for<O> OutS, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires [[redoc("`:c>")]]mergeable<I1, I2, O, Comp, Proj1, Proj2>
  ranges::set_difference_result<I1, O>
    ranges::set_difference(Ep&& exec, I1 first1, S1 last1,
                           I2 first2, S2 last2, O result, OutS result_last,
                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
template<[[redoc("*:c>")]]execution-policy Ep, [[redoc("*:c>")]]sized-random-access-range R1, [[redoc("*:c>")]]sized-random-access-range R2,
         [[redoc("*:c>")]]sized-random-access-range OutR, class Comp = ranges::less,
         class Proj1 = identity, class Proj2 = identity>
  requires [[redoc("`:c>")]]mergeable<iterator_t<R1>, iterator_t<R2>, iterator_t<OutR>, Comp, Proj1, Proj2>
  ranges::set_difference_result<borrowed_iterator_t<R1>, borrowed_iterator_t<OutR>>
    ranges::set_difference(Ep&& exec, R1&& r1, R2&& r2, OutR&& result_r, Comp comp = {},
                           Proj1 proj1 = {}, Proj2 proj2 = {});
[codeblock:end]

[div:description]
[para]
[:en] Let:
[:zh_CN] 令：
[list]
[item]
[:en@~] [`comp] be [`less{}], and [`proj1] and [`proj2] be [`identity{}] for
the overloads with no parameters by those names;
[:zh_CN@~] 对于没有名为 [`comp] 和 [`proj1] 和 [`proj2] 的形参的重载，令 [`comp]
为 [`less()]，以及 [`proj1] 和 [`proj2] 为 [`identity{}]；
[item]
[:en@~] [$M] be the number of elements in [=range(first1,last1)] that are not
present in [=range(first2,last2)];
[:zh_CN@~] 令 [$M] 为未出现在 [=range(first2,last2)] 中的 [=range(first1,last1)]
中的元素的数量；
[item]
[:en@~] [`result_last] be [`result + [$M]] for the overloads with no parameter
[`result_last] or [`result_r];
[:zh_CN@~] 对于没有形参 [`result_last] 或 [`result_r] 的重载，令 [`result_last] 为
[`result + [$M]]；
[item]
[:en@~] [$N] be [$\min(M, \ [`result_last - result])].
[:zh_CN@~] [$N] 为 [$\min(M, \ [`result_last - result])]。
[list:end]

[para:expects]
[:en] The ranges [=range(first1,last1)] and [=range(first2,last2)] are sorted
with respect to [`comp] and [`proj1] or [`proj2], respectively.
[:zh_CN] 范围 [=range(first1,last1)] 和 [=range(first2,last2)] 分别根据
[`comp] 和 [`proj1] 或 [`proj2] 有序。

[:en] The resulting range does not overlap with either of the original ranges.
[:zh_CN] 结果范围不与任何一个源范围有重叠。

[para:effects]
[:en] Copies [$N] elements of the range [=range(first1,last1)] which are not
present in the range [=range(first2,last2)] to the range [=range(result,result + [$N])].
[:zh_CN] 将范围 [=range(first1,last1)] 中不存在于范围 [=range(first2,last2)] 中的
[$N] 个元素复制到范围 [=range(result,result + [$N])] 中。

[:en] The elements in the constructed range are sorted.
[:zh_CN] 所构造的范围中的元素是有序的。

[para:returns]
[list]
[item]
[:en] [`result_last] for the overloads in namespace [`std].
[:zh_CN] 命名空间 [`std] 中的各重载返回 [`result_last]。
[item]
[:en] [`{last1, result + [$N]}] for the overloads in namespace [`ranges],
if [$N] is equal to [$M].
[:zh_CN] 命名空间 [`ranges] 中的各重载，当 [$N] 等于 [$M] 时，返回 [`{last1, result + [$N]}]。
[item]
[:en] Otherwise, [`{j1, result_last}] for the overloads in namespace [`ranges],
where the iterator [`j1] points to positions past the last copied or skipped
elements in [=range(first1,last1)] and [=range(first2,last2)], respectively.
[:zh_CN] 否则，命名空间 [`ranges] 中的各重载返回 [`{j1, result_last}]，
其中迭代器 [`j1] 分别指向 [=range(first1,last1)] 和 [=range(first2,last2)]
中最后一个被复制或跳过的元素之后的位置。
[list:end]

[para:complexity]
[:en] At most [`2 * ((last1 - first1) + (last2 - first2)) - 1] comparisons and
applications of each projection.
[:zh_CN] 最多进行 [`2 * ((last1 - first1) + (last2 - first2)) - 1] 次比较和每种
投射的运用。

[para:remarks]
[:en] If [=range(first1,last1)] contains [$m] elements that are equivalent to
each other and [=range(first2,last2)] contains [$n] elements that are equivalent
to them, the last [$\max(m - n, 0)] elements from [=range(first1,last1)] are
copied to the output range, in order.
[:zh_CN] 如果 [=range(first1,last1)] 包含 [$m] 个互相等价的元素，而
[=range(first2,last2)] 包含 [$n] 个与其等价的元素，则 [=range(first1,last1)] 中
的最后 [$\max(m - n, 0)] 个元素被依序复制到输出范围中。
[div:end]
