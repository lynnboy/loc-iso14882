[section#algorithms.requirements
    [:en] Algorithms requirements
    [:zh_CN] 算法的规定
]

[para]
[:en] All of the algorithms are separated from the particular implementations of
data structures and are parameterized by iterator types.
[:zh_CN] 所有算法均与数据结构的特定实现分离，并以迭代器类型进行参数化。

[:en] Because of this, they can work with program-defined data structures, as
long as these data structures have iterator types satisfying the assumptions on
the algorithms.
[:zh_CN] 因此，它们可以与由程序定义的数据结构一起工作，只要这些数据结构具有符合
算法的假设的迭代器类型即可。

[para]
[:en] For purposes of determining the existence of data races, algorithms shall
not modify objects referenced through an iterator argument unless the
specification requires such modification.
[:zh_CN] 当确定是否存在数据竞争时，算法不能对通过迭代器实参所引用的对象产生改动，
除非其说明需要进行这种改动。

[para]
[:en] Throughout this Clause, the names of template parameters are used to
express type requirements.
[:zh_CN] 本章通篇中，利用模板形参的名字来表达类型规定。

[list]
[item]
[:en] If an algorithm[=']s template parameter is named [`InputIterator],
[`InputIterator1], or [`InputIterator2], the template argument shall satisfy the
requirements of an input iterator ([#input.iterators]).
[:zh_CN] 如果算法的模板形参名为 [`InputIterator]、[`InputIterator1] 或
[`InputIterator2]，则其模板实参应当符合输入迭代器的规定（[#input.iterators]）。

[item]
[:en] If an algorithm[=']s template parameter is named [`OutputIterator],
[`OutputIterator1], or [`OutputIterator2], the template argument shall satisfy
the requirements of an output iterator ([#output.iterators]).
[:zh_CN] 如果算法的模板形参名为 [`OutputIterator]、[`OutputIterator1] 或
[`OutputIterator2]，则其模板实参应当符合输出迭代器的规定（[#output.iterators]）。

[item]
[:en] If an algorithm[=']s template parameter is named [`ForwardIterator],
[`ForwardIterator1], or [`ForwardIterator2], the template argument shall satisfy
the requirements of a forward iterator ([#forward.iterators]).
[:zh_CN] 如果算法的模板形参名为 [`ForwardIterator]、[`ForwardIterator1] 或
[`ForwardIterator2]，则其模板实参应当符合前向迭代器的规定
（[#forward.iterators]）。

[item]
[:en] If an algorithm[=']s template parameter is named [`BidirectionalIterator],
[`BidirectionalIterator1], or [`BidirectionalIterator2], the template argument
shall satisfy the requirements of a bidirectional iterator
([#bidirectional.iterators]).
[:zh_CN] 如果算法的模板形参名为 [`BidirectionalIterator]、
[`BidirectionalIterator1] 或 [`BidirectionalIterator2]，则其模板实参应当符合双向
迭代器的规定（[#bidirectional.iterators]）。

[item]
[:en] If an algorithm[=']s template parameter is named [`RandomAccessIterator],
[`RandomAccessIterator1], or [`RandomAccessIterator2], the template argument
shall satisfy the requirements of a random-access iterator
([#random.access.iterators]).
[:zh_CN] 如果算法的模板形参名为 [`RandomAccessIterator]、
[`RandomAccessIterator1] 或 [`RandomAccessIterator2]，则其模板实参应当符合随机
访问迭代器的规定（[#random.access.iterators]）。
[list:end]

[para]
[:en] If an algorithm[=']s [=Effects] element specifies that a value pointed to
by any iterator passed as an argument is modified, then that algorithm has an
additional type requirement:
[:zh_CN] 如果算法的 [=Effects] 部分指定由任何作为实参传递的迭代器所指向的值将被
改动，则该算法还具有一个额外的类型规定：

[:en] The type of that argument shall satisfy the requirements of a mutable
iterator ([#iterator.requirements]).
[:zh_CN] 该实参的类型应当符合可改动迭代器的规定（[#iterator.requirements]）。

[enter:note]
[:en] This requirement does not affect arguments that are named
[`OutputIterator], [`OutputIterator1], or [`OutputIterator2], because output
iterators must always be mutable.
[:zh_CN] 这条规定并不会影响名为 [`OutputIterator]、[`OutputIterator1] 或
[`OutputIterator2] 的实参，因为输出迭代器总是可改动的。
[exit:note]

[para]
[:en] Both in-place and copying versions are provided for certain algorithms.
[#:note#fn:$section.1]
[:zh_CN] 一些算法同时提供了就地版本和复制版本。[#:note#fn:$section.1]

[note:foot#fn:$section.1]
[:en] The decision whether to include a copying version was usually based on
complexity considerations.
[:zh_CN] 是否包括复制版本的决策通常依据其复杂度考虑。

[:en] When the cost of doing the operation dominates the cost of copy, the
copying version is not included.
[:zh_CN] 如果实施运算的代价主要由复制成本所支配，则不包括其复制版本。

[:en] For example, [`sort_copy] is not included because the cost of sorting is
much more significant, and users might as well do [`copy] followed by [`sort].
[:zh_CN] 例如，由于进行排序的成本太高，因此并未包括 [`sort_copy]，而用户可以进行
[`copy] 之后再 [`sort]。
[note:end]

[:en] When such a version is provided for [*algorithm] it is called
[*algorithm[`_copy]].
[:zh_CN] 当为 [*algorithm] 提供这种版本时它将叫做 [*algorithm[`_copy]]。

[:en] Algorithms that take predicates end with the suffix [`_if] (which follows
the suffix [`_copy]).
[:zh_CN] 接受谓词的算法以 [`_if] 后缀结尾（跟在后缀 [`_copy] 之后）。

[para]
[:en] The [`Predicate] parameter is used whenever an algorithm expects a
function object ([#function.objects]) that, when applied to the result of
dereferencing the corresponding iterator, returns a value testable as [`true].
[:zh_CN] [`Predicate] 形参被用于当算法预期一个函数对象（[#function.objects]）
之时，当它被施加于对应迭代器的解引用的结果时，将返回一个可以检验是否为 [`true]
的值。

[:en] In other words, if an algorithm takes [`Predicate pred] as its argument
and [`first] as its iterator argument, it should work correctly in the construct
[`pred(*first)] contextually converted to [`bool] ([#conv]).
[:zh_CN] 换句话说，如果算法接受 [`Predicate pred] 作为实参，并接受 [`first] 作为
其迭代器实参，则语言构造 [`pred(*first)] 被按语境转换为 [`bool]（[#conv]）应当
能够正确工作。

[:en] The function object [`pred] shall not apply any non-constant function
through the dereferenced iterator.
[:zh_CN] 函数对象 [`pred] 不能通过所解引用的迭代器调用任何非 const 函数。

[para]
[:en] The [`BinaryPredicate] parameter is used whenever an algorithm expects a
function object that when applied to the result of dereferencing two
corresponding iterators or to dereferencing an iterator and type [`T] when [`T]
is part of the signature returns a value testable as [`true].
[:zh_CN] [`BinaryPredicate] 形参被用于当算法预期一个函数对象之时，当它被施加于
两个对应迭代器的解引用的结果时，或当 [`T] 为其签名的一部分时它被施加于一个迭代器
的解引用值和一个 [`T] 类型的值时，将返回一个可以检验是否为 [`true] 的值。

[:en] In other words, if an algorithm takes [`BinaryPredicate binary_pred] as
its argument and [`first1] and [`first2] as its iterator arguments, it should
work correctly in the construct [`binary_pred(*first1, *first2)] contextually
converted to [`bool] ([#conv]).
[:zh_CN] 换句话说，如果算法接受 [`BinaryPredicate binary_pred] 作为实参，并接受
[`first1] 和 [`first2] 作为其迭代器实参，则语言构造 [`binary_pred(*first1,
*first2)] 被按语境转换为 [`bool]（[#conv]）应当能够正确工作。

[:en] [`BinaryPredicate] always takes the first iterator[=']s [`value_type] as
its first argument, that is, in those cases when [`T value] is part of the
signature, it should work correctly in the construct
[`binary_pred(*first1, value)] contextually converted to [`bool] ([#conv]).
[:zh_CN] [`BinaryPredicate] 总是接受其第一个迭代器的 [`value_type] 作为其第一个
实参，就是说，当 [`T value] 属于签名的一部分时，语言构造
[`binary_pred(*first1, value)] 被按语境转换为 [`bool]（[#conv]）应当能够正确工作
。

[:en] [`binary_pred] shall not apply any non-constant function through the
dereferenced iterators.
[:zh_CN] [`binary_pred] 不能通过所解引用的迭代器调用任何非 const 函数。

[para]
[enter:note]
[:en] Unless otherwise specified, algorithms that take function objects as
arguments are permitted to copy those function objects freely.
[:zh_CN] 除非另行说明，否则接受函数对象为其实参的算法都被允许对这些函数对象进行
随意复制。

[:en] Programmers for whom object identity is important should consider using a
wrapper class that points to a noncopied implementation object such as
[`reference_wrapper<T>] ([#refwrap]), or some equivalent solution.
[:zh_CN] 认为对象同一性重要的程序员应该考虑使用一种指向不被复制的实现对象的包装
类，比如 [`reference_wrapper<T>]（[#refwrap]），或者某个等价的方案。
[exit:note]

[para]
[:en] When the description of an algorithm gives an expression such as
[`*first == value] for a condition, the expression shall evaluate to either
[`true] or [`false] in boolean contexts.
[:zh_CN] 如果算法的说明中将表达式（比如 [`*first == value]）提出为某种条件，则
该表达式应当在布尔语境中求值为 [`true] 或为 [`false]。

[para]
[:en] In the description of the algorithms operators [`+] and [`-] are used for
some of the iterator categories for which they do not have to be defined.
[:zh_CN] 在算法的说明中，对于某些迭代器类别使用了运算符 [`+] 和 [`-]，但它们可能
不必是有定义的。

[:en] In these cases the semantics of [`a+n] is the same as that of
[:zh_CN] 这些情况下，[`a+n] 的语义与以下代码相同

[codeblock:notation]
X tmp = a;
advance(tmp, n);
return tmp;
[codeblock:end]

[:en@~] and that of [`b-a] is the same as of
[:zh_CN@~] 而 [`b-a] 的语义与以下代码相同

[codeblock:notation]
return distance(a, b);
[codeblock:end]
