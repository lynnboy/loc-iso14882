[section#specialized.algorithms
    [:en] Specialized [`<memory>] algorithms
    [:zh_CN] 特化的 [`<memory>] 算法
]

[para]
[:en]
The contents specified in this subclause [#specialized.algorithms] are declared
in the header [?libheader@ref memory].
[:zh_CN]
本子条款 [#specialized.algorithms] 中所指定的内容声明于头文件
[?libheader@ref memory] 中。

[para]
[:en]
Unless otherwise specified, if an exception is thrown in the following
algorithms, objects constructed by a placement [~new-expression] ([#expr.new])
are destroyed in an unspecified order before allowing the exception to propagate.
[:zh_CN]
除非另行说明，否则当下列算法中抛出异常时，以放置式 [~new-表达式]（[#expr.new]）
所构造的各个对象，在允许异常进行传播之前，以某个未指明的顺序进行销毁。

[para]
[begin:note]
[:en] When invoked on ranges of potentially overlapping subobjects
([#intro.object]), the algorithms specified in this subclause
[#specialized.algorithms] result in undefined behavior.
[:zh_CN] 当对潜在重叠的子对象（[#intro.object]）的范围上调用时，本子条款
[#specialized.algorithms] 中所指定的各个算法都导致未定义行为。
[end:note]

[para]
[:en] Some algorithms defined in this clause make use of the exposition-only
function [`[^voidify]]:
[:zh_CN] 本条款中所定义的某些算法，用到了仅用于阐释的函数 [`[^voidify]]：
[codeblock]
template<class T>
  constexpr void* [[redoc("^>")]]voidify(T& obj) noexcept {
    return const_cast<void*>(static_cast<const volatile void*>(addressof(obj)));
  }
[codeblock:end]

[include special.mem.concepts]

[include uninitialized.construct.default]

[include uninitialized.construct.value]

[include uninitialized.copy]

[include uninitialized.move]

[include uninitialized.fill]

[include specialized.construct]

[include specialized.destroy]
