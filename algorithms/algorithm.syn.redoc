[section#algorithm.syn
    [:en] Header [`<algorithm>] synopsis
    [:zh_CN] 头文件 [`<algorithm>] 纲要
]

[%@hdr@def algorithm]

[codeblock:synopsis]
#include <initializer_list>

namespace std {
  namespace ranges {
    // [:en] [#algorithms.results], algorithm result types \
       [:zh_CN] [#algorithms.results]，算法结果类型
    template<class I, class F>
      struct in_fun_result;

    template<class I1, class I2>
      struct in_in_result;

    template<class I, class O>
      struct in_out_result;

    template<class I1, class I2, class O>
      struct in_in_out_result;

    template<class I, class O1, class O2>
      struct in_out_out_result;

    template<class T>
      struct min_max_result;

    template<class I>
      struct in_found_result;
  }

  // [:en] [#alg.nonmodifying], non-modifying sequence operations \
     [:zh_CN] [#alg.nonmodifying]，无改动序列运算
  // [:en] [#alg.all.of], all of \
     [:zh_CN] [#alg.all.of]，全部……均为……（all of）
  template<class InputIterator, class Predicate>
    constexpr bool all_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool all_of(ExecutionPolicy&& exec,                         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                ForwardIterator first, ForwardIterator last, Predicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      constexpr bool all_of(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool all_of(R&& r, Pred pred, Proj proj = {});
  }

  // [:en] [#alg.any.of], any of \
     [:zh_CN] [#alg.any.of]，任意……为……（any of）
  template<class InputIterator, class Predicate>
    constexpr bool any_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool any_of(ExecutionPolicy&& exec,                         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                ForwardIterator first, ForwardIterator last, Predicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      constexpr bool any_of(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool any_of(R&& r, Pred pred, Proj proj = {});
  }

  // [:en] [#alg.none.of], none of \
     [:zh_CN] [#alg.none.of]，没有……为……（none of）
  template<class InputIterator, class Predicate>
    constexpr bool none_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool none_of(ExecutionPolicy&& exec,                        // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                 ForwardIterator first, ForwardIterator last, Predicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      constexpr bool none_of(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool none_of(R&& r, Pred pred, Proj proj = {});
  }

  // [:en] [#alg.foreach], for each \
     [:zh_CN] [#alg.foreach]，对每个……（for each）
  template<class InputIterator, class Function>
    constexpr Function for_each(InputIterator first, InputIterator last, Function f);
  template<class ExecutionPolicy, class ForwardIterator, class Function>
    void for_each(ExecutionPolicy&& exec,                       // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                  ForwardIterator first, ForwardIterator last, Function f);

  namespace ranges {
    template<class I, class F>
      using for_each_result = in_fun_result<I, F>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirectly_unary_invocable<projected<I, Proj>> Fun>
      constexpr for_each_result<I, Fun>
        for_each(I first, S last, Fun f, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirectly_unary_invocable<projected<iterator_t<R>, Proj>> Fun>
      constexpr for_each_result<borrowed_iterator_t<R>, Fun>
        for_each(R&& r, Fun f, Proj proj = {});
  }

  template<class InputIterator, class Size, class Function>
    constexpr InputIterator for_each_n(InputIterator first, Size n, Function f);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class Function>
    ForwardIterator for_each_n(ExecutionPolicy&& exec,          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                               ForwardIterator first, Size n, Function f);

  namespace ranges {
    template<class I, class F>
      using for_each_n_result = in_fun_result<I, F>;

    template<[[redoc("`:c>")]]input_iterator I, class Proj = identity,
             [[redoc("`:c>")]]indirectly_unary_invocable<projected<I, Proj>> Fun>
      constexpr for_each_n_result<I, Fun>
        for_each_n(I first, iter_difference_t<I> n, Fun f, Proj proj = {});
  }

  // [:en] [#alg.find], find \
     [:zh_CN] [#alg.find]，查找
  template<class InputIterator, class T>
    constexpr InputIterator find(InputIterator first, InputIterator last,
                                 const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    ForwardIterator find(ExecutionPolicy&& exec,                // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                         ForwardIterator first, ForwardIterator last,
                         const T& value);
  template<class InputIterator, class Predicate>
    constexpr InputIterator find_if(InputIterator first, InputIterator last,
                                    Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator find_if(ExecutionPolicy&& exec,             // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                            ForwardIterator first, ForwardIterator last,
                            Predicate pred);
  template<class InputIterator, class Predicate>
    constexpr InputIterator find_if_not(InputIterator first, InputIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator find_if_not(ExecutionPolicy&& exec,         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                                ForwardIterator first, ForwardIterator last,
                                Predicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T, class Proj = identity>
      requires [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
      constexpr I find(I first, S last, const T& value, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class T, class Proj = identity>
      requires [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T*>
      constexpr borrowed_iterator_t<R>
        find(R&& r, const T& value, Proj proj = {});
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      constexpr I find_if(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr borrowed_iterator_t<R>
        find_if(R&& r, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      constexpr I find_if_not(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr borrowed_iterator_t<R>
        find_if_not(R&& r, Pred pred, Proj proj = {});
  }

  // [:en] [#alg.find.end], find end \
     [:zh_CN] [#alg.find.end]，尾部查找
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      find_end(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
      find_end(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]forward_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
      constexpr subrange<I1>
        find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]forward_range R1, [[redoc("`:c>")]]forward_range R2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr borrowed_iterator_t<R1>
        find_end(R1&& r1, R2&& r2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // [:en] [#alg.find.first.of], find first \
     [:zh_CN] [#alg.find.first.of]，查找首个
  template<class InputIterator, class ForwardIterator>
    constexpr InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2);
  template<class InputIterator, class ForwardIterator, class BinaryPredicate>
    constexpr InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2,
                    BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      find_first_of(ExecutionPolicy&& exec,                     // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                    ForwardIterator1 first1, ForwardIterator1 last1,
                    ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
      find_first_of(ExecutionPolicy&& exec,                     // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                    ForwardIterator1 first1, ForwardIterator1 last1,
                    ForwardIterator2 first2, ForwardIterator2 last2,
                    BinaryPredicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]forward_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
      constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]forward_range R2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr borrowed_iterator_t<R1>
        find_first_of(R1&& r1, R2&& r2, Pred pred = {},
                      Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // [:en] [#alg.adjacent.find], adjacent find \
     [:zh_CN] [#alg.adjacent.find]，邻接查找
  template<class ForwardIterator>
    constexpr ForwardIterator
      adjacent_find(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class BinaryPredicate>
    constexpr ForwardIterator
      adjacent_find(ForwardIterator first, ForwardIterator last,
                    BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      adjacent_find(ExecutionPolicy&& exec,                     // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                    ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
    ForwardIterator
      adjacent_find(ExecutionPolicy&& exec,                     // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                    ForwardIterator first, ForwardIterator last,
                    BinaryPredicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_binary_predicate<projected<I, Proj>,
                                       projected<I, Proj>> Pred = ranges::equal_to>
      constexpr I adjacent_find(I first, S last, Pred pred = {},
                                Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_binary_predicate<projected<iterator_t<R>, Proj>,
                                       projected<iterator_t<R>, Proj>> Pred = ranges::equal_to>
      constexpr borrowed_iterator_t<R>
        adjacent_find(R&& r, Pred pred = {}, Proj proj = {});
  }

  // [:en] [#alg.count], count \
     [:zh_CN] [#alg.count]，计数
  template<class InputIterator, class T>
    constexpr typename iterator_traits<InputIterator>::difference_type
      count(InputIterator first, InputIterator last, const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    typename iterator_traits<ForwardIterator>::difference_type
      count(ExecutionPolicy&& exec,                             // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
            ForwardIterator first, ForwardIterator last, const T& value);
  template<class InputIterator, class Predicate>
    constexpr typename iterator_traits<InputIterator>::difference_type
      count_if(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    typename iterator_traits<ForwardIterator>::difference_type
      count_if(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator first, ForwardIterator last, Predicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T, class Proj = identity>
      requires [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
      constexpr iter_difference_t<I>
        count(I first, S last, const T& value, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class T, class Proj = identity>
      requires [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T*>
      constexpr range_difference_t<R>
        count(R&& r, const T& value, Proj proj = {});
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      constexpr iter_difference_t<I>
        count_if(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr range_difference_t<R>
        count_if(R&& r, Pred pred, Proj proj = {});
  }

  // [:en] [#mismatch], mismatch \
     [:zh_CN] [#mismatch]，查找不匹配
  template<class InputIterator1, class InputIterator2>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred);
  template<class InputIterator1, class InputIterator2>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  namespace ranges {
    template<class I1, class I2>
      using mismatch_result = in_in_result<I1, I2>;

    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
      constexpr mismatch_result<I1, I2>
        mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr mismatch_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
        mismatch(R1&& r1, R2&& r2, Pred pred = {},
                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // [:en] [#alg.equal], equal \
     [:zh_CN] [#alg.equal]，相等
  template<class InputIterator1, class InputIterator2>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, BinaryPredicate pred);
  template<class InputIterator1, class InputIterator2>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool equal(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    bool equal(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool equal(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    bool equal(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
      constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                           Pred pred = {},
                           Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr bool equal(R1&& r1, R2&& r2, Pred pred = {},
                           Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // [:en] [#alg.is.permutation], is permutation \
     [:zh_CN] [#alg.is.permutation]，是排列（is permutation）
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, BinaryPredicate pred);
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, ForwardIterator2 last2,
                                  BinaryPredicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]forward_iterator I2,
             [[redoc("`:c>")]]sentinel_for<I2> S2, class Proj1 = identity, class Proj2 = identity,
             [[redoc("`:c>")]]indirect_equivalence_relation<projected<I1, Proj1>,
                                           projected<I2, Proj2>> Pred = ranges::equal_to>
      constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                                    Pred pred = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]forward_range R1, [[redoc("`:c>")]]forward_range R2,
             class Proj1 = identity, class Proj2 = identity,
             [[redoc("`:c>")]]indirect_equivalence_relation<projected<iterator_t<R1>, Proj1>,
                                           projected<iterator_t<R2>, Proj2>>
               Pred = ranges::equal_to>
      constexpr bool is_permutation(R1&& r1, R2&& r2, Pred pred = {},
                                    Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // [:en] [#alg.search], search \
     [:zh_CN] [#alg.search]，搜索
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1
      search(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1
      search(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      search(ExecutionPolicy&& exec,                            // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    ForwardIterator1
      search(ExecutionPolicy&& exec,                            // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]forward_iterator I2,
             [[redoc("`:c>")]]sentinel_for<I2> S2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
      constexpr subrange<I1>
        search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]forward_range R1, [[redoc("`:c>")]]forward_range R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr borrowed_subrange_t<R1>
        search(R1&& r1, R2&& r2, Pred pred = {},
               Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class ForwardIterator, class Size, class T>
    constexpr ForwardIterator
      search_n(ForwardIterator first, ForwardIterator last,
               Size count, const T& value);
  template<class ForwardIterator, class Size, class T, class BinaryPredicate>
    constexpr ForwardIterator
      search_n(ForwardIterator first, ForwardIterator last,
               Size count, const T& value, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class T>
    ForwardIterator
      search_n(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator first, ForwardIterator last,
               Size count, const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class T,
           class BinaryPredicate>
    ForwardIterator
      search_n(ExecutionPolicy&& exec,                          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
               ForwardIterator first, ForwardIterator last,
               Size count, const T& value,
               BinaryPredicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T,
             class Pred = ranges::equal_to, class Proj = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<I, const T*, Pred, Proj>
      constexpr subrange<I>
        search_n(I first, S last, iter_difference_t<I> count,
                 const T& value, Pred pred = {}, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class T, class Pred = ranges::equal_to,
             class Proj = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<iterator_t<R>, const T*, Pred, Proj>
      constexpr borrowed_subrange_t<R>
        search_n(R&& r, range_difference_t<R> count,
                 const T& value, Pred pred = {}, Proj proj = {});
  }

  template<class ForwardIterator, class Searcher>
    constexpr ForwardIterator
      search(ForwardIterator first, ForwardIterator last, const Searcher& searcher);

  namespace ranges {
    // [:en] [#alg.starts.with], starts with \
       [:zh_CN] [#alg.starts.with]，开头为……
    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
      constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr bool starts_with(R1&& r1, R2&& r2, Pred pred = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});

    // [:en] [#alg.ends.with], ends with \
       [:zh_CN] [#alg.ends.with]，末尾为……
    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
      requires ([[redoc("`:c>")]]forward_iterator<I1> || [[redoc("`:c>")]]sized_sentinel_for<S1, I1>) &&
               ([[redoc("`:c>")]]forward_iterator<I2> || [[redoc("`:c>")]]sized_sentinel_for<S2, I2>) &&
               [[redoc("`:c>")]]indirectly_comparable<I1, I2, Pred, Proj1, Proj2>
      constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, class Pred = ranges::equal_to,
             class Proj1 = identity, class Proj2 = identity>
      requires ([[redoc("`:c>")]]forward_range<R1> || [[redoc("`:c>")]]sized_range<R1>) &&
               ([[redoc("`:c>")]]forward_range<R2> || [[redoc("`:c>")]]sized_range<R2>) &&
               [[redoc("`:c>")]]indirectly_comparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr bool ends_with(R1&& r1, R2&& r2, Pred pred = {},
                               Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // [:en] [#alg.modifying.operations], modifying sequence operations \
     [:zh_CN] [#alg.modifying.operations]，有改动序列运算
  // [:en] [#alg.copy], copy \
     [:zh_CN] [#alg.copy]，复制
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator copy(InputIterator first, InputIterator last,
                                  OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2 copy(ExecutionPolicy&& exec,               // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);

  namespace ranges {
    template<class I, class O>
      using copy_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O>
      constexpr copy_result<I, O>
        copy(I first, S last, O result);
    template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O>
      constexpr copy_result<borrowed_iterator_t<R>, O>
        copy(R&& r, O result);
  }

  template<class InputIterator, class Size, class OutputIterator>
    constexpr OutputIterator copy_n(InputIterator first, Size n,
                                    OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class Size,
           class ForwardIterator2>
    ForwardIterator2 copy_n(ExecutionPolicy&& exec,             // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                            ForwardIterator1 first, Size n,
                            ForwardIterator2 result);

  namespace ranges {
    template<class I, class O>
      using copy_n_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]weakly_incrementable O>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O>
      constexpr copy_n_result<I, O>
        copy_n(I first, iter_difference_t<I> n, O result);
  }

  template<class InputIterator, class OutputIterator, class Predicate>
    constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
                                     OutputIterator result, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate>
    ForwardIterator2 copy_if(ExecutionPolicy&& exec,            // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                             ForwardIterator1 first, ForwardIterator1 last,
                             ForwardIterator2 result, Predicate pred);

  namespace ranges {
    template<class I, class O>
      using copy_if_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O>
      constexpr copy_if_result<I, O>
        copy_if(I first, S last, O result, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O>
      constexpr copy_if_result<borrowed_iterator_t<R>, O>
        copy_if(R&& r, O result, Pred pred, Proj proj = {});
  }

  template<class BidirectionalIterator1, class BidirectionalIterator2>
    constexpr BidirectionalIterator2
      copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                    BidirectionalIterator2 result);

  namespace ranges {
    template<class I1, class I2>
      using copy_backward_result = in_out_result<I1, I2>;

    template<[[redoc("`:c>")]]bidirectional_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]bidirectional_iterator I2>
      requires [[redoc("`:c>")]]indirectly_copyable<I1, I2>
      constexpr copy_backward_result<I1, I2>
        copy_backward(I1 first, S1 last, I2 result);
    template<[[redoc("`:c>")]]bidirectional_range R, [[redoc("`:c>")]]bidirectional_iterator I>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, I>
      constexpr copy_backward_result<borrowed_iterator_t<R>, I>
        copy_backward(R&& r, I result);
  }

  // [:en] [#alg.move], move \
     [:zh_CN] [#alg.move]，移动
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator move(InputIterator first, InputIterator last,
                                  OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2>
    ForwardIterator2 move(ExecutionPolicy&& exec,               // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);

  namespace ranges {
    template<class I, class O>
      using move_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O>
      requires [[redoc("`:c>")]]indirectly_movable<I, O>
      constexpr move_result<I, O>
        move(I first, S last, O result);
    template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O>
      requires [[redoc("`:c>")]]indirectly_movable<iterator_t<R>, O>
      constexpr move_result<borrowed_iterator_t<R>, O>
        move(R&& r, O result);
  }

  template<class BidirectionalIterator1, class BidirectionalIterator2>
    constexpr BidirectionalIterator2
      move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                    BidirectionalIterator2 result);

  namespace ranges {
    template<class I1, class I2>
      using move_backward_result = in_out_result<I1, I2>;

    template<[[redoc("`:c>")]]bidirectional_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]bidirectional_iterator I2>
      requires [[redoc("`:c>")]]indirectly_movable<I1, I2>
      constexpr move_backward_result<I1, I2>
        move_backward(I1 first, S1 last, I2 result);
    template<[[redoc("`:c>")]]bidirectional_range R, [[redoc("`:c>")]]bidirectional_iterator I>
      requires [[redoc("`:c>")]]indirectly_movable<iterator_t<R>, I>
      constexpr move_backward_result<borrowed_iterator_t<R>, I>
        move_backward(R&& r, I result);
  }

  // [:en] [#alg.swap], swap \
     [:zh_CN] [#alg.swap]，交换
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                                           ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2 swap_ranges(ExecutionPolicy&& exec,        // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                                 ForwardIterator1 first1, ForwardIterator1 last1,
                                 ForwardIterator2 first2);

  namespace ranges {
    template<class I1, class I2>
      using swap_ranges_result = in_in_result<I1, I2>;

    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2>
      requires [[redoc("`:c>")]]indirectly_swappable<I1, I2>
      constexpr swap_ranges_result<I1, I2>
        swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2>
      requires [[redoc("`:c>")]]indirectly_swappable<iterator_t<R1>, iterator_t<R2>>
      constexpr swap_ranges_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
        swap_ranges(R1&& r1, R2&& r2);
  }

  template<class ForwardIterator1, class ForwardIterator2>
    constexpr void iter_swap(ForwardIterator1 a, ForwardIterator2 b);

  // [:en] [#alg.transform], transform \
     [:zh_CN] [#alg.transform]，变换
  template<class InputIterator, class OutputIterator, class UnaryOperation>
    constexpr OutputIterator
      transform(InputIterator first1, InputIterator last1,
                OutputIterator result, UnaryOperation op);
  template<class InputIterator1, class InputIterator2, class OutputIterator,
           class BinaryOperation>
    constexpr OutputIterator
      transform(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, OutputIterator result,
                BinaryOperation binary_op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class UnaryOperation>
    ForwardIterator2
      transform(ExecutionPolicy&& exec,                         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 result, UnaryOperation op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class BinaryOperation>
    ForwardIterator
      transform(ExecutionPolicy&& exec,                         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator result,
                BinaryOperation binary_op);

  namespace ranges {
    template<class I, class O>
      using unary_transform_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O,
             [[redoc("`:c>")]]copy_constructible F, class Proj = identity>
      requires [[redoc("`:c>")]]indirectly_writable<O, indirect_result_t<F&, projected<I, Proj>>>
      constexpr unary_transform_result<I, O>
        transform(I first1, S last1, O result, F op, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O, [[redoc("`:c>")]]copy_constructible F,
             class Proj = identity>
      requires [[redoc("`:c>")]]indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
      constexpr unary_transform_result<borrowed_iterator_t<R>, O>
        transform(R&& r, O result, F op, Proj proj = {});

    template<class I1, class I2, class O>
      using binary_transform_result = in_in_out_result<I1, I2, O>;

    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             [[redoc("`:c>")]]weakly_incrementable O, [[redoc("`:c>")]]copy_constructible F, class Proj1 = identity,
             class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_writable<O, indirect_result_t<F&, projected<I1, Proj1>,
                                             projected<I2, Proj2>>>
      constexpr binary_transform_result<I1, I2, O>
        transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, [[redoc("`:c>")]]weakly_incrementable O,
             [[redoc("`:c>")]]copy_constructible F, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_writable<O, indirect_result_t<F&, projected<iterator_t<R1>, Proj1>,
                                             projected<iterator_t<R2>, Proj2>>>
      constexpr binary_transform_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
        transform(R1&& r1, R2&& r2, O result,
                  F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // [:en] [#alg.replace], replace \
     [:zh_CN] [#alg.replace]，替换
  template<class ForwardIterator, class T>
    constexpr void replace(ForwardIterator first, ForwardIterator last,
                           const T& old_value, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    void replace(ExecutionPolicy&& exec,                        // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                 ForwardIterator first, ForwardIterator last,
                 const T& old_value, const T& new_value);
  template<class ForwardIterator, class Predicate, class T>
    constexpr void replace_if(ForwardIterator first, ForwardIterator last,
                              Predicate pred, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate, class T>
    void replace_if(ExecutionPolicy&& exec,                     // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                    ForwardIterator first, ForwardIterator last,
                    Predicate pred, const T& new_value);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T1, class T2, class Proj = identity>
      requires [[redoc("`:c>")]]indirectly_writable<I, const T2&> &&
               [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
      constexpr I
        replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class T1, class T2, class Proj = identity>
      requires [[redoc("`:c>")]]indirectly_writable<iterator_t<R>, const T2&> &&
               [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T1*>
      constexpr borrowed_iterator_t<R>
        replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = {});
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      requires [[redoc("`:c>")]]indirectly_writable<I, const T&>
      constexpr I replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      requires [[redoc("`:c>")]]indirectly_writable<iterator_t<R>, const T&>
      constexpr borrowed_iterator_t<R>
        replace_if(R&& r, Pred pred, const T& new_value, Proj proj = {});
  }

  template<class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator replace_copy(InputIterator first, InputIterator last,
                                          OutputIterator result,
                                          const T& old_value, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
    ForwardIterator2 replace_copy(ExecutionPolicy&& exec,       // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                                  ForwardIterator1 first, ForwardIterator1 last,
                                  ForwardIterator2 result,
                                  const T& old_value, const T& new_value);
  template<class InputIterator, class OutputIterator, class Predicate, class T>
    constexpr OutputIterator replace_copy_if(InputIterator first, InputIterator last,
                                             OutputIterator result,
                                             Predicate pred, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate, class T>
    ForwardIterator2 replace_copy_if(ExecutionPolicy&& exec,    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                                     ForwardIterator1 first, ForwardIterator1 last,
                                     ForwardIterator2 result,
                                     Predicate pred, const T& new_value);

  namespace ranges {
    template<class I, class O>
      using replace_copy_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T1, class T2,
             [[redoc("`:c>")]]output_iterator<const T2&> O, class Proj = identity>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O> &&
               [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T1*>
      constexpr replace_copy_result<I, O>
        replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                     Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class T1, class T2, [[redoc("`:c>")]]output_iterator<const T2&> O,
             class Proj = identity>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O> &&
               [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T1*>
      constexpr replace_copy_result<borrowed_iterator_t<R>, O>
        replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
                     Proj proj = {});

    template<class I, class O>
      using replace_copy_if_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T, [[redoc("`:c>")]]output_iterator<const T&> O,
             class Proj = identity, [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O>
      constexpr replace_copy_if_result<I, O>
        replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                        Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class T, [[redoc("`:c>")]]output_iterator<const T&> O, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O>
      constexpr replace_copy_if_result<borrowed_iterator_t<R>, O>
        replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
                        Proj proj = {});
  }

  // [:en] [#alg.fill], fill \
     [:zh_CN] [#alg.fill]，填充
  template<class ForwardIterator, class T>
    constexpr void fill(ForwardIterator first, ForwardIterator last, const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    void fill(ExecutionPolicy&& exec,                           // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
              ForwardIterator first, ForwardIterator last, const T& value);
  template<class OutputIterator, class Size, class T>
    constexpr OutputIterator fill_n(OutputIterator first, Size n, const T& value);
  template<class ExecutionPolicy, class ForwardIterator,
           class Size, class T>
    ForwardIterator fill_n(ExecutionPolicy&& exec,              // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                           ForwardIterator first, Size n, const T& value);

  namespace ranges {
    template<class T, [[redoc("`:c>")]]output_iterator<const T&> O, [[redoc("`:c>")]]sentinel_for<O> S>
      constexpr O fill(O first, S last, const T& value);
    template<class T, [[redoc("`:c>")]]output_range<const T&> R>
      constexpr borrowed_iterator_t<R> fill(R&& r, const T& value);
    template<class T, [[redoc("`:c>")]]output_iterator<const T&> O>
      constexpr O fill_n(O first, iter_difference_t<O> n, const T& value);
  }

  // [:en] [#alg.generate], generate \
     [:zh_CN] [#alg.generate]，生成
  template<class ForwardIterator, class Generator>
    constexpr void generate(ForwardIterator first, ForwardIterator last,
                            Generator gen);
  template<class ExecutionPolicy, class ForwardIterator, class Generator>
    void generate(ExecutionPolicy&& exec,                       // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                  ForwardIterator first, ForwardIterator last,
                  Generator gen);
  template<class OutputIterator, class Size, class Generator>
    constexpr OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class Generator>
    ForwardIterator generate_n(ExecutionPolicy&& exec,          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                               ForwardIterator first, Size n, Generator gen);

  namespace ranges {
    template<[[redoc("`:c>")]]input_or_output_iterator O, [[redoc("`:c>")]]sentinel_for<O> S, [[redoc("`:c>")]]copy_constructible F>
      requires [[redoc("`:c>")]]invocable<F&> && [[redoc("`:c>")]]indirectly_writable<O, invoke_result_t<F&>>
      constexpr O generate(O first, S last, F gen);
    template<class R, [[redoc("`:c>")]]copy_constructible F>
      requires [[redoc("`:c>")]]invocable<F&> && [[redoc("`:c>")]]output_range<R, invoke_result_t<F&>>
      constexpr borrowed_iterator_t<R> generate(R&& r, F gen);
    template<[[redoc("`:c>")]]input_or_output_iterator O, [[redoc("`:c>")]]copy_constructible F>
      requires [[redoc("`:c>")]]invocable<F&> && [[redoc("`:c>")]]indirectly_writable<O, invoke_result_t<F&>>
      constexpr O generate_n(O first, iter_difference_t<O> n, F gen);
  }

  // [:en] [#alg.remove], remove \
     [:zh_CN] [#alg.remove]，移除
  template<class ForwardIterator, class T>
    constexpr ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                                     const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    ForwardIterator remove(ExecutionPolicy&& exec,              // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                           ForwardIterator first, ForwardIterator last,
                           const T& value);
  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator remove_if(ExecutionPolicy&& exec,           // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                              ForwardIterator first, ForwardIterator last,
                              Predicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]permutable I, [[redoc("`:c>")]]sentinel_for<I> S, class T, class Proj = identity>
      requires [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
      constexpr subrange<I> remove(I first, S last, const T& value, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class T, class Proj = identity>
      requires [[redoc("`:c>")]]permutable<iterator_t<R>> &&
               [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T*>
      constexpr borrowed_subrange_t<R>
        remove(R&& r, const T& value, Proj proj = {});
    template<[[redoc("`:c>")]]permutable I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      constexpr subrange<I> remove_if(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      requires [[redoc("`:c>")]]permutable<iterator_t<R>>
      constexpr borrowed_subrange_t<R>
        remove_if(R&& r, Pred pred, Proj proj = {});
  }

  template<class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator
      remove_copy(InputIterator first, InputIterator last,
                  OutputIterator result, const T& value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class T>
    ForwardIterator2
      remove_copy(ExecutionPolicy&& exec,                       // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result, const T& value);
  template<class InputIterator, class OutputIterator, class Predicate>
    constexpr OutputIterator
      remove_copy_if(InputIterator first, InputIterator last,
                     OutputIterator result, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate>
    ForwardIterator2
      remove_copy_if(ExecutionPolicy&& exec,                    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                     ForwardIterator1 first, ForwardIterator1 last,
                     ForwardIterator2 result, Predicate pred);

  namespace ranges {
    template<class I, class O>
      using remove_copy_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O, class T,
             class Proj = identity>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O> &&
               [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to, projected<I, Proj>, const T*>
      constexpr remove_copy_result<I, O>
        remove_copy(I first, S last, O result, const T& value, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O, class T, class Proj = identity>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O> &&
               [[redoc("`:c>")]]indirect_binary_predicate<ranges::equal_to,
                                         projected<iterator_t<R>, Proj>, const T*>
      constexpr remove_copy_result<borrowed_iterator_t<R>, O>
        remove_copy(R&& r, O result, const T& value, Proj proj = {});

    template<class I, class O>
      using remove_copy_if_result = copy_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O,
             class Proj = identity, [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O>
      constexpr remove_copy_if_result<I, O>
        remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O>
      constexpr remove_copy_if_result<borrowed_iterator_t<R>, O>
        remove_copy_if(R&& r, O result, Pred pred, Proj proj = {});
  }

  // [:en] [#alg.unique], unique \
     [:zh_CN] [#alg.unique]，唯一
  template<class ForwardIterator>
    constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class BinaryPredicate>
    constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                                     BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator unique(ExecutionPolicy&& exec,              // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                           ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
    ForwardIterator unique(ExecutionPolicy&& exec,              // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                           ForwardIterator first, ForwardIterator last,
                           BinaryPredicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]permutable I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
      constexpr subrange<I> unique(I first, S last, C comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
      requires [[redoc("`:c>")]]permutable<iterator_t<R>>
      constexpr borrowed_subrange_t<R>
        unique(R&& r, C comp = {}, Proj proj = {});
  }

  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator
      unique_copy(InputIterator first, InputIterator last,
                  OutputIterator result);
  template<class InputIterator, class OutputIterator, class BinaryPredicate>
    constexpr OutputIterator
      unique_copy(InputIterator first, InputIterator last,
                  OutputIterator result, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      unique_copy(ExecutionPolicy&& exec,                       // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    ForwardIterator2
      unique_copy(ExecutionPolicy&& exec,                       // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result, BinaryPredicate pred);

  namespace ranges {
    template<class I, class O>
      using unique_copy_result = in_out_result<I, O>;

    template<input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O, class Proj = identity,
             [[redoc("`:c>")]]indirect_equivalence_relation<projected<I, Proj>> C = ranges::equal_to>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O> &&
               ([[redoc("`:c>")]]forward_iterator<I> ||
                ([[redoc("`:c>")]]input_iterator<O> && [[redoc("`:c>")]]same_as<iter_value_t<I>, iter_value_t<O>>) ||
                [[redoc("`:c>")]]indirectly_copyable_storable<I, O>)
      constexpr unique_copy_result<I, O>
        unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O, class Proj = identity,
             [[redoc("`:c>")]]indirect_equivalence_relation<projected<iterator_t<R>, Proj>> C = ranges::equal_to>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O> &&
               ([[redoc("`:c>")]]forward_iterator<iterator_t<R>> ||
                ([[redoc("`:c>")]]input_iterator<O> && [[redoc("`:c>")]]same_as<range_value_t<R>, iter_value_t<O>>) ||
                [[redoc("`:c>")]]indirectly_copyable_storable<iterator_t<R>, O>)
      constexpr unique_copy_result<borrowed_iterator_t<R>, O>
        unique_copy(R&& r, O result, C comp = {}, Proj proj = {});
  }

  // [:en] [#alg.reverse], reverse \
     [:zh_CN] [#alg.reverse]，反转
  template<class BidirectionalIterator>
    constexpr void reverse(BidirectionalIterator first, BidirectionalIterator last);
  template<class ExecutionPolicy, class BidirectionalIterator>
    void reverse(ExecutionPolicy&& exec,                        // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                 BidirectionalIterator first, BidirectionalIterator last);

  namespace ranges {
    template<[[redoc("`:c>")]]bidirectional_iterator I, [[redoc("`:c>")]]sentinel_for<I> S>
      requires [[redoc("`:c>")]]permutable<I>
      constexpr I reverse(I first, S last);
    template<[[redoc("`:c>")]]bidirectional_range R>
      requires [[redoc("`:c>")]]permutable<iterator_t<R>>
      constexpr borrowed_iterator_t<R> reverse(R&& r);
  }

  template<class BidirectionalIterator, class OutputIterator>
    constexpr OutputIterator
      reverse_copy(BidirectionalIterator first, BidirectionalIterator last,
                   OutputIterator result);
  template<class ExecutionPolicy, class BidirectionalIterator, class ForwardIterator>
    ForwardIterator
      reverse_copy(ExecutionPolicy&& exec,                      // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                   BidirectionalIterator first, BidirectionalIterator last,
                   ForwardIterator result);

  namespace ranges {
    template<class I, class O>
      using reverse_copy_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]bidirectional_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O>
      constexpr reverse_copy_result<I, O>
        reverse_copy(I first, S last, O result);
    template<[[redoc("`:c>")]]bidirectional_range R, [[redoc("`:c>")]]weakly_incrementable O>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O>
      constexpr reverse_copy_result<borrowed_iterator_t<R>, O>
        reverse_copy(R&& r, O result);
  }

  // [:en] [#alg.rotate], rotate \
     [:zh_CN] [#alg.rotate]，旋转
  template<class ForwardIterator>
    constexpr ForwardIterator rotate(ForwardIterator first,
                                     ForwardIterator middle,
                                     ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator rotate(ExecutionPolicy&& exec,              // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                           ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last);

  namespace ranges {
    template<[[redoc("`:c>")]]permutable I, [[redoc("`:c>")]]sentinel_for<I> S>
      constexpr subrange<I> rotate(I first, I middle, S last);
    template<[[redoc("`:c>")]]forward_range R>
      requires [[redoc("`:c>")]]permutable<iterator_t<R>>
      constexpr borrowed_subrange_t<R> rotate(R&& r, iterator_t<R> middle);
  }

  template<class ForwardIterator, class OutputIterator>
    constexpr OutputIterator
      rotate_copy(ForwardIterator first, ForwardIterator middle,
                  ForwardIterator last, OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      rotate_copy(ExecutionPolicy&& exec,                       // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                  ForwardIterator1 first, ForwardIterator1 middle,
                  ForwardIterator1 last, ForwardIterator2 result);

  namespace ranges {
    template<class I, class O>
      using rotate_copy_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, [[redoc("`:c>")]]weakly_incrementable O>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O>
      constexpr rotate_copy_result<I, O>
        rotate_copy(I first, I middle, S last, O result);
    template<[[redoc("`:c>")]]forward_range R, [[redoc("`:c>")]]weakly_incrementable O>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O>
      constexpr rotate_copy_result<borrowed_iterator_t<R>, O>
        rotate_copy(R&& r, iterator_t<R> middle, O result);
  }

  // [:en] [#alg.random.sample], sample \
     [:zh_CN] [#alg.random.sample]，抽样
  template<class PopulationIterator, class SampleIterator,
           class Distance, class UniformRandomBitGenerator>
    SampleIterator sample(PopulationIterator first, PopulationIterator last,
                          SampleIterator out, Distance n,
                          UniformRandomBitGenerator&& g);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S,
             [[redoc("`:c>")]]weakly_incrementable O, class Gen>
      requires ([[redoc("`:c>")]]forward_iterator<I> || [[redoc("`:c>")]]random_access_iterator<O>) &&
               [[redoc("`:c>")]]indirectly_copyable<I, O> &&
               [[redoc("`:c>")]]uniform_random_bit_generator<remove_reference_t<Gen>>
      O sample(I first, S last, O out, iter_difference_t<I> n, Gen&& g);
    template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O, class Gen>
      requires ([[redoc("`:c>")]]forward_range<R> || [[redoc("`:c>")]]random_access_iterator<O>) &&
               [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O> &&
               [[redoc("`:c>")]]uniform_random_bit_generator<remove_reference_t<Gen>>
      O sample(R&& r, O out, range_difference_t<R> n, Gen&& g);
  }

  // [:en] [#alg.random.shuffle], shuffle \
     [:zh_CN] [#alg.random.shuffle]，混洗
  template<class RandomAccessIterator, class UniformRandomBitGenerator>
    void shuffle(RandomAccessIterator first,
                 RandomAccessIterator last,
                 UniformRandomBitGenerator&& g);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Gen>
      requires [[redoc("`:c>")]]permutable<I> &&
               [[redoc("`:c>")]]uniform_random_bit_generator<remove_reference_t<Gen>>
      I shuffle(I first, S last, Gen&& g);
    template<[[redoc("`:c>")]]random_access_range R, class Gen>
      requires [[redoc("`:c>")]]permutable<iterator_t<R>> &&
               [[redoc("`:c>")]]uniform_random_bit_generator<remove_reference_t<Gen>>
      borrowed_iterator_t<R> shuffle(R&& r, Gen&& g);
  }

  // [:en] [#alg.shift], shift \
     [:zh_CN] [#alg.shift]，移位
  template<class ForwardIterator>
    constexpr ForwardIterator
      shift_left(ForwardIterator first, ForwardIterator last,
                 typename iterator_traits<ForwardIterator>::difference_type n);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      shift_left(ExecutionPolicy&& exec,                        // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                 ForwardIterator first, ForwardIterator last,
                 typename iterator_traits<ForwardIterator>::difference_type n);
  template<class ForwardIterator>
    constexpr ForwardIterator
      shift_right(ForwardIterator first, ForwardIterator last,
                  typename iterator_traits<ForwardIterator>::difference_type n);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      shift_right(ExecutionPolicy&& exec,                       // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                  ForwardIterator first, ForwardIterator last,
                  typename iterator_traits<ForwardIterator>::difference_type n);

  // [:en] [#alg.sorting], sorting and related operations \
     [:zh_CN] [#alg.sorting]，排序及相关运算
  // [:en] [#alg.sort], sorting \
     [:zh_CN] [#alg.sort]，排序
  template<class RandomAccessIterator>
    constexpr void sort(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void sort(RandomAccessIterator first, RandomAccessIterator last,
                        Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void sort(ExecutionPolicy&& exec,                           // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
              RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void sort(ExecutionPolicy&& exec,                           // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
              RandomAccessIterator first, RandomAccessIterator last,
              Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      constexpr I
        sort(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]random_access_range R, class Comp = ranges::less, class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        sort(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void stable_sort(ExecutionPolicy&& exec,                    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                     RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void stable_sort(ExecutionPolicy&& exec,                    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                     RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      I stable_sort(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]random_access_range R, class Comp = ranges::less, class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      borrowed_iterator_t<R>
        stable_sort(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
                                RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
                                RandomAccessIterator last, Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void partial_sort(ExecutionPolicy&& exec,                   // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                      RandomAccessIterator first, RandomAccessIterator middle,
                      RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void partial_sort(ExecutionPolicy&& exec,                   // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                      RandomAccessIterator first, RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      constexpr I
        partial_sort(I first, I middle, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]random_access_range R, class Comp = ranges::less, class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        partial_sort(R&& r, iterator_t<R> middle, Comp comp = {},
                     Proj proj = {});
  }

  template<class InputIterator, class RandomAccessIterator>
    constexpr RandomAccessIterator
      partial_sort_copy(InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last);
  template<class InputIterator, class RandomAccessIterator, class Compare>
    constexpr RandomAccessIterator
      partial_sort_copy(InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp);
  template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator>
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy&& exec,                 // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                        ForwardIterator first, ForwardIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last);
  template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator,
           class Compare>
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy&& exec,                 // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                        ForwardIterator first, ForwardIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp);

  namespace ranges {
    template<class I, class O>
      using partial_sort_copy_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1,
             [[redoc("`:c>")]]random_access_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_copyable<I1, I2> && [[redoc("`:c>")]]sortable<I2, Comp, Proj2> &&
               [[redoc("`:c>")]]indirect_strict_weak_order<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
      constexpr partial_sort_copy_result<I1, I2>
        partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                          Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]random_access_range R2, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R1>, iterator_t<R2>> &&
               [[redoc("`:c>")]]sortable<iterator_t<R2>, Comp, Proj2> &&
               [[redoc("`:c>")]]indirect_strict_weak_order<Comp, projected<iterator_t<R1>, Proj1>,
                                          projected<iterator_t<R2>, Proj2>>
      constexpr partial_sort_copy_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>>
        partial_sort_copy(R1&& r, R2&& result_r, Comp comp = {},
                          Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class ForwardIterator>
    constexpr bool is_sorted(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr bool is_sorted(ForwardIterator first, ForwardIterator last,
                             Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    bool is_sorted(ExecutionPolicy&& exec,                      // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                   ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    bool is_sorted(ExecutionPolicy&& exec,                      // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                   ForwardIterator first, ForwardIterator last,
                   Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
      constexpr bool is_sorted(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr bool is_sorted(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator>
    constexpr ForwardIterator
      is_sorted_until(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator
      is_sorted_until(ForwardIterator first, ForwardIterator last,
                      Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      is_sorted_until(ExecutionPolicy&& exec,                   // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                      ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator
      is_sorted_until(ExecutionPolicy&& exec,                   // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                      ForwardIterator first, ForwardIterator last,
                      Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
      constexpr I is_sorted_until(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr borrowed_iterator_t<R>
        is_sorted_until(R&& r, Comp comp = {}, Proj proj = {});
  }

  // [:en] [#alg.nth.element], Nth element \
     [:zh_CN] [#alg.nth.element]，第 N 位元素
  template<class RandomAccessIterator>
    constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                               RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                               RandomAccessIterator last, Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void nth_element(ExecutionPolicy&& exec,                    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void nth_element(ExecutionPolicy&& exec,                    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      constexpr I
        nth_element(I first, I nth, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]random_access_range R, class Comp = ranges::less, class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        nth_element(R&& r, iterator_t<R> nth, Comp comp = {}, Proj proj = {});
  }

  // [:en] [#alg.binary.search], binary search \
     [:zh_CN] [#alg.binary.search]，折半检索
  template<class ForwardIterator, class T>
    constexpr ForwardIterator
      lower_bound(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr ForwardIterator
      lower_bound(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
      constexpr I lower_bound(I first, S last, const T& value, Comp comp = {},
                              Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
               ranges::less>
      constexpr borrowed_iterator_t<R>
        lower_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator, class T>
    constexpr ForwardIterator
      upper_bound(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr ForwardIterator
      upper_bound(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
      constexpr I upper_bound(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
               ranges::less>
      constexpr borrowed_iterator_t<R>
        upper_bound(R&& r, const T& value, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator, class T>
    constexpr pair<ForwardIterator, ForwardIterator>
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr pair<ForwardIterator, ForwardIterator>
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
      constexpr subrange<I>
        equal_range(I first, S last, const T& value, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
               ranges::less>
      constexpr borrowed_subrange_t<R>
        equal_range(R&& r, const T& value, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator, class T>
    constexpr bool
      binary_search(ForwardIterator first, ForwardIterator last,
                    const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr bool
      binary_search(ForwardIterator first, ForwardIterator last,
                    const T& value, Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<const T*, projected<I, Proj>> Comp = ranges::less>
      constexpr bool binary_search(I first, S last, const T& value, Comp comp = {},
                                   Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<const T*, projected<iterator_t<R>, Proj>> Comp =
               ranges::less>
      constexpr bool binary_search(R&& r, const T& value, Comp comp = {},
                                   Proj proj = {});
  }

  // [:en] [#alg.partitions], partitions \
     [:zh_CN] [#alg.partitions]，分区
  template<class InputIterator, class Predicate>
    constexpr bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool is_partitioned(ExecutionPolicy&& exec,                 // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                        ForwardIterator first, ForwardIterator last, Predicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool is_partitioned(R&& r, Pred pred, Proj proj = {});
  }

  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator partition(ForwardIterator first,
                                        ForwardIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator partition(ExecutionPolicy&& exec,           // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                              ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]permutable I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      constexpr subrange<I>
        partition(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      requires [[redoc("`:c>")]]permutable<iterator_t<R>>
      constexpr borrowed_subrange_t<R>
        partition(R&& r, Pred pred, Proj proj = {});
  }

  template<class BidirectionalIterator, class Predicate>
    BidirectionalIterator stable_partition(BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
  template<class ExecutionPolicy, class BidirectionalIterator, class Predicate>
    BidirectionalIterator stable_partition(ExecutionPolicy&& exec,  // [:en] see [#algorithms.parallel.overloads] \
                                                                       [:zh_CN] 参见 [#algorithms.parallel.overloads]
                                           BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]bidirectional_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      requires [[redoc("`:c>")]]permutable<I>
      subrange<I> stable_partition(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]bidirectional_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      requires [[redoc("`:c>")]]permutable<iterator_t<R>>
      borrowed_subrange_t<R> stable_partition(R&& r, Pred pred, Proj proj = {});
  }

  template<class InputIterator, class OutputIterator1,
           class OutputIterator2, class Predicate>
    constexpr pair<OutputIterator1, OutputIterator2>
      partition_copy(InputIterator first, InputIterator last,
                     OutputIterator1 out_true, OutputIterator2 out_false,
                     Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class ForwardIterator1,
           class ForwardIterator2, class Predicate>
    pair<ForwardIterator1, ForwardIterator2>
      partition_copy(ExecutionPolicy&& exec,                    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                     ForwardIterator first, ForwardIterator last,
                     ForwardIterator1 out_true, ForwardIterator2 out_false,
                     Predicate pred);

  namespace ranges {
    template<class I, class O1, class O2>
      using partition_copy_result = in_out_out_result<I, O1, O2>;

    template<[[redoc("`:c>")]]input_iterator I, [[redoc("`:c>")]]sentinel_for<I> S,
             [[redoc("`:c>")]]weakly_incrementable O1, [[redoc("`:c>")]]weakly_incrementable O2,
             class Proj = identity, [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      requires [[redoc("`:c>")]]indirectly_copyable<I, O1> && [[redoc("`:c>")]]indirectly_copyable<I, O2>
      constexpr partition_copy_result<I, O1, O2>
        partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                       Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, [[redoc("`:c>")]]weakly_incrementable O1, [[redoc("`:c>")]]weakly_incrementable O2,
             class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      requires [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O1> &&
               [[redoc("`:c>")]]indirectly_copyable<iterator_t<R>, O2>
      constexpr partition_copy_result<borrowed_iterator_t<R>, O1, O2>
        partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});
  }

  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator
      partition_point(ForwardIterator first, ForwardIterator last,
                      Predicate pred);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<I, Proj>> Pred>
      constexpr I partition_point(I first, S last, Pred pred, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_unary_predicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr borrowed_iterator_t<R>
        partition_point(R&& r, Pred pred, Proj proj = {});
  }

  // [:en] [#alg.merge], merge \
     [:zh_CN] [#alg.merge]，归并
  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      merge(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator,
           class Compare>
    constexpr OutputIterator
      merge(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      merge(ExecutionPolicy&& exec,                             // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
            ForwardIterator1 first1, ForwardIterator1 last1,
            ForwardIterator2 first2, ForwardIterator2 last2,
            ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      merge(ExecutionPolicy&& exec,                             // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
            ForwardIterator1 first1, ForwardIterator1 last1,
            ForwardIterator2 first2, ForwardIterator2 last2,
            ForwardIterator result, Compare comp);

  namespace ranges {
    template<class I1, class I2, class O>
      using merge_result = in_in_out_result<I1, I2, O>;

    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             [[redoc("`:c>")]]weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity,
             class Proj2 = identity>
      requires [[redoc("`:c>")]]mergeable<I1, I2, O, Comp, Proj1, Proj2>
      constexpr merge_result<I1, I2, O>
        merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, [[redoc("`:c>")]]weakly_incrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr merge_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
        merge(R1&& r1, R2&& r2, O result,
              Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class BidirectionalIterator>
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);
  template<class ExecutionPolicy, class BidirectionalIterator>
    void inplace_merge(ExecutionPolicy&& exec,                  // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template<class ExecutionPolicy, class BidirectionalIterator, class Compare>
    void inplace_merge(ExecutionPolicy&& exec,                  // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]bidirectional_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      I inplace_merge(I first, I middle, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]bidirectional_range R, class Comp = ranges::less, class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      borrowed_iterator_t<R>
        inplace_merge(R&& r, iterator_t<R> middle, Comp comp = {},
                      Proj proj = {});
  }

  // [:en] [#alg.set.operations], set operations \
     [:zh_CN] [#alg.set.operations]，集合运算
  template<class InputIterator1, class InputIterator2>
    constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class Compare>
    constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool includes(ExecutionPolicy&& exec,                       // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Compare>
    bool includes(ExecutionPolicy&& exec,                       // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2,
                  Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             class Proj1 = identity, class Proj2 = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
               ranges::less>
      constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, class Proj1 = identity,
             class Proj2 = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                        projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
      constexpr bool includes(R1&& r1, R2&& r2, Comp comp = {},
                              Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_union(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
                set_union(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_union(ExecutionPolicy&& exec,                         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_union(ExecutionPolicy&& exec,                         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                ForwardIterator result, Compare comp);

  namespace ranges {
    template<class I1, class I2, class O>
      using set_union_result = in_in_out_result<I1, I2, O>;

    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             [[redoc("`:c>")]]weakly_incrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]mergeable<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_union_result<I1, I2, O>
        set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},
                  Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, [[redoc("`:c>")]]weakly_incrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_union_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
        set_union(R1&& r1, R2&& r2, O result, Comp comp = {},
                  Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_intersection(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_intersection(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_intersection(ExecutionPolicy&& exec,                  // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, ForwardIterator2 last2,
                       ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_intersection(ExecutionPolicy&& exec,                  // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, ForwardIterator2 last2,
                       ForwardIterator result, Compare comp);

  namespace ranges {
    template<class I1, class I2, class O>
      using set_intersection_result = in_in_out_result<I1, I2, O>;

    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             [[redoc("`:c>")]]weakly_incrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]mergeable<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_intersection_result<I1, I2, O>
        set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                         Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, [[redoc("`:c>")]]weakly_incrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_intersection_result<borrowed_iterator_t<R1>, borrowed_iterator_t<R2>, O>
        set_intersection(R1&& r1, R2&& r2, O result,
                         Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_difference(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_difference(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_difference(ExecutionPolicy&& exec,                    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_difference(ExecutionPolicy&& exec,                    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result, Compare comp);

  namespace ranges {
    template<class I, class O>
      using set_difference_result = in_out_result<I, O>;

    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             [[redoc("`:c>")]]weakly_incrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]mergeable<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_difference_result<I1, O>
        set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, [[redoc("`:c>")]]weakly_incrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_difference_result<borrowed_iterator_t<R1>, O>
        set_difference(R1&& r1, R2&& r2, O result,
                       Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_symmetric_difference(ExecutionPolicy&& exec,          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                               ForwardIterator1 first1, ForwardIterator1 last1,
                               ForwardIterator2 first2, ForwardIterator2 last2,
                               ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_symmetric_difference(ExecutionPolicy&& exec,          // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                               ForwardIterator1 first1, ForwardIterator1 last1,
                               ForwardIterator2 first2, ForwardIterator2 last2,
                               ForwardIterator result, Compare comp);

  namespace ranges {
    template<class I1, class I2, class O>
      using set_symmetric_difference_result = in_in_out_result<I1, I2, O>;

    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             [[redoc("`:c>")]]weakly_incrementable O, class Comp = ranges::less,
             class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]mergeable<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_symmetric_difference_result<I1, I2, O>
        set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                 Comp comp = {}, Proj1 proj1 = {},
                                 Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, [[redoc("`:c>")]]weakly_incrementable O,
             class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity>
      requires [[redoc("`:c>")]]mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_symmetric_difference_result<borrowed_iterator_t<R1>,
                                                borrowed_iterator_t<R2>, O>
        set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = {},
                                 Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // [:en] [#alg.heap.operations], heap operations \
     [:zh_CN] [#alg.heap.operations]，堆运算：
  template<class RandomAccessIterator>
    constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                             Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      constexpr I
        push_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]random_access_range R, class Comp = ranges::less, class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        push_heap(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                            Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      constexpr I
        pop_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]random_access_range R, class Comp = ranges::less, class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        pop_heap(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                             Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      constexpr I
        make_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]random_access_range R, class Comp = ranges::less, class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        make_heap(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                             Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      constexpr I
        sort_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]random_access_range R, class Comp = ranges::less, class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      constexpr borrowed_iterator_t<R>
        sort_heap(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    bool is_heap(ExecutionPolicy&& exec,                        // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                 RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    bool is_heap(ExecutionPolicy&& exec,                        // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                 RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
      constexpr bool is_heap(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]random_access_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr bool is_heap(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class RandomAccessIterator>
    constexpr RandomAccessIterator
      is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr RandomAccessIterator
      is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    RandomAccessIterator
      is_heap_until(ExecutionPolicy&& exec,                     // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                    RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    RandomAccessIterator
      is_heap_until(ExecutionPolicy&& exec,                     // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                    RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]random_access_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
      constexpr I is_heap_until(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]random_access_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr borrowed_iterator_t<R>
        is_heap_until(R&& r, Comp comp = {}, Proj proj = {});
  }

  // [:en] [#alg.min.max], minimum and maximum \
     [:zh_CN] [#alg.min.max]，最大值与最小值
  template<class T> constexpr const T& min(const T& a, const T& b);
  template<class T, class Compare>
    constexpr const T& min(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr T min(initializer_list<T> t);
  template<class T, class Compare>
    constexpr T min(initializer_list<T> t, Compare comp);

  namespace ranges {
    template<class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
      constexpr const T& min(const T& a, const T& b, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]copyable T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
      constexpr T min(initializer_list<T> r, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      requires [[redoc("`:c>")]]indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
      constexpr range_value_t<R>
        min(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class T> constexpr const T& max(const T& a, const T& b);
  template<class T, class Compare>
    constexpr const T& max(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr T max(initializer_list<T> t);
  template<class T, class Compare>
    constexpr T max(initializer_list<T> t, Compare comp);

  namespace ranges {
    template<class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
      constexpr const T& max(const T& a, const T& b, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]copyable T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
      constexpr T max(initializer_list<T> r, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      requires [[redoc("`:c>")]]indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
      constexpr range_value_t<R>
        max(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class T> constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
  template<class T, class Compare>
    constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr pair<T, T> minmax(initializer_list<T> t);
  template<class T, class Compare>
    constexpr pair<T, T> minmax(initializer_list<T> t, Compare comp);

  namespace ranges {
    template<class T>
      using minmax_result = min_max_result<T>;

    template<class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
      constexpr minmax_result<const T&>
        minmax(const T& a, const T& b, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]copyable T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
      constexpr minmax_result<T>
        minmax(initializer_list<T> r, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]input_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      requires [[redoc("`:c>")]]indirectly_copyable_storable<iterator_t<R>, range_value_t<R>*>
      constexpr minmax_result<range_value_t<R>>
        minmax(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator>
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator min_element(ExecutionPolicy&& exec,         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                                ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator min_element(ExecutionPolicy&& exec,         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                                ForwardIterator first, ForwardIterator last,
                                Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
      constexpr I min_element(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr borrowed_iterator_t<R>
        min_element(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator>
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator max_element(ExecutionPolicy&& exec,         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                                ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator max_element(ExecutionPolicy&& exec,         // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                                ForwardIterator first, ForwardIterator last,
                                Compare comp);

 namespace ranges {
    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
      constexpr I max_element(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr borrowed_iterator_t<R>
        max_element(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class ForwardIterator>
    constexpr pair<ForwardIterator, ForwardIterator>
      minmax_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr pair<ForwardIterator, ForwardIterator>
      minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    pair<ForwardIterator, ForwardIterator>
      minmax_element(ExecutionPolicy&& exec,                    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                     ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    pair<ForwardIterator, ForwardIterator>
      minmax_element(ExecutionPolicy&& exec,                    // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                     ForwardIterator first, ForwardIterator last, Compare comp);

  namespace ranges {
    template<class I>
      using minmax_element_result = min_max_result<I>;

    template<[[redoc("`:c>")]]forward_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<I, Proj>> Comp = ranges::less>
      constexpr minmax_element_result<I>
        minmax_element(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]forward_range R, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R>, Proj>> Comp = ranges::less>
      constexpr minmax_element_result<borrowed_iterator_t<R>>
        minmax_element(R&& r, Comp comp = {}, Proj proj = {});
  }

  // [:en] [#alg.clamp], bounded value \
     [:zh_CN] [#alg.clamp]，有界值
  template<class T>
    constexpr const T& clamp(const T& v, const T& lo, const T& hi);
  template<class T, class Compare>
    constexpr const T& clamp(const T& v, const T& lo, const T& hi, Compare comp);

  namespace ranges {
    template<class T, class Proj = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<const T*, Proj>> Comp = ranges::less>
      constexpr const T&
        clamp(const T& v, const T& lo, const T& hi, Comp comp = {}, Proj proj = {});
  }

  // [:en] [#alg.lex.comparison], lexicographical comparison \
     [:zh_CN] [#alg.lex.comparison]，字典序比较
  template<class InputIterator1, class InputIterator2>
    constexpr bool
      lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class Compare>
    constexpr bool
      lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2,
                              Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool
      lexicographical_compare(ExecutionPolicy&& exec,           // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                              ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Compare>
    bool
      lexicographical_compare(ExecutionPolicy&& exec,           // [:en] see [#algorithms.parallel.overloads] \
                                                                   [:zh_CN] 参见 [#algorithms.parallel.overloads]
                              ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2,
                              Compare comp);

  namespace ranges {
    template<[[redoc("`:c>")]]input_iterator I1, [[redoc("`:c>")]]sentinel_for<I1> S1, [[redoc("`:c>")]]input_iterator I2, [[redoc("`:c>")]]sentinel_for<I2> S2,
             class Proj1 = identity, class Proj2 = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<I1, Proj1>, projected<I2, Proj2>> Comp =
               ranges::less>
      constexpr bool
        lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
    template<[[redoc("`:c>")]]input_range R1, [[redoc("`:c>")]]input_range R2, class Proj1 = identity,
             class Proj2 = identity,
             [[redoc("`:c>")]]indirect_strict_weak_order<projected<iterator_t<R1>, Proj1>,
                                        projected<iterator_t<R2>, Proj2>> Comp = ranges::less>
      constexpr bool
        lexicographical_compare(R1&& r1, R2&& r2, Comp comp = {},
                                Proj1 proj1 = {}, Proj2 proj2 = {});
  }

  // [:en] [#alg.three.way], three-way comparison algorithms \
     [:zh_CN] [#alg.three.way]，三路比较算法
  template<class InputIterator1, class InputIterator2, class Cmp>
    constexpr auto
      lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
                                        InputIterator2 b2, InputIterator2 e2,
                                        Cmp comp)
        -> decltype(comp(*b1, *b2));
  template<class InputIterator1, class InputIterator2>
    constexpr auto
      lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,
                                        InputIterator2 b2, InputIterator2 e2);

  // [:en] [#alg.permutation.generators], permutations \
     [:zh_CN] [#alg.permutation.generators]，排列
  template<class BidirectionalIterator>
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);

  namespace ranges {
    template<class I>
      using next_permutation_result = in_found_result<I>;

    template<[[redoc("`:c>")]]bidirectional_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      constexpr next_permutation_result<I>
        next_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]bidirectional_range R, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      constexpr next_permutation_result<borrowed_iterator_t<R>>
        next_permutation(R&& r, Comp comp = {}, Proj proj = {});
  }

  template<class BidirectionalIterator>
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);

  namespace ranges {
    template<class I>
      using prev_permutation_result = in_found_result<I>;

    template<[[redoc("`:c>")]]bidirectional_iterator I, [[redoc("`:c>")]]sentinel_for<I> S, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<I, Comp, Proj>
      constexpr prev_permutation_result<I>
        prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});
    template<[[redoc("`:c>")]]bidirectional_range R, class Comp = ranges::less,
             class Proj = identity>
      requires [[redoc("`:c>")]]sortable<iterator_t<R>, Comp, Proj>
      constexpr prev_permutation_result<borrowed_iterator_t<R>>
        prev_permutation(R&& r, Comp comp = {}, Proj proj = {});
  }
}
[codeblock:end]
